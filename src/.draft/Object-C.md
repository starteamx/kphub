

第 1 章 面向对象的编程

1.1 对象的概念
- 1.1.1 面向功能的软件设计的局限性
- 1.1.2 面向对象的模块化
- 1.1.3 消息传递
- 1.1.4 模块的抽象化
- 1.1.5 对象的属性
- 专栏 面向对象的方方面面
- 1.1.6 类
- 专栏 Cocoa 和 Objective-C 的历史

1.2 模块和对象
- 1.2.1 软件模块
- 1.2.2 高独立性的模块
- 1.2.3 模块的信息隐蔽
- 1.2.4 类的定义和接口
- 1.2.5 消息发送的实现
- 专栏 C 语言的新标准

第 2 章 Objective-C 程序设计

2.1 对象和消息
- 2.1.1 消息表达式
- 2.1.2 消息选择器
- 2.1.3 实例变量的生成和初始化

2.2 类的定义
- 2.2.1 类的接口声明
- 专栏 各种各样的布尔类型
- 专栏 不指定方法的返回值
- 2.2.2 类的实现
- 2.2.3 一个遥控器的例子

2.3 编译
- 2.3.1 简单的编译方法
- 2.3.2 多文件编译

2.4 程序的书写风格
- 2.4.1 混合编程
- 2.4.2 C 语言函数的使用方法
- 2.4.3 静态变量的定义
- 2.4.4 头文件的引入
- 专栏 参考文档和 SDK
- 专栏 Xcode 的安装



第 3 章 类和继承

3.1 继承的概念
- 3.1.1 父类和子类
- 3.1.2 类的层次结构

3.2 利用继承定义新类
- 3.2.1 继承的定义
- 3.2.2 类定义和头文件
- 3.2.3 继承和方法调用
- 3.2.4 调用父类的方法
- 3.2.5 初始化方法的定义

3.3 使用继承的程序示例
- 3.3.1 追加新方法的例子
- 3.3.2 方法重写的例子

3.4 继承和方法调用
- 3.4.1 使用 self 调用方法
- 3.4.2 使用 super 调用方法
- 3.4.3 测试程序

3.5 方法定义时的注意事项
- 3.5.1 局部方法
- 3.5.2 指定初始化方法

专栏 Objective-C 与开源软件



第 4 章 对象的类型和动态绑定

4.1 动态绑定
- 4.1.1 什么是动态绑定
- 4.1.2 多态

4.2 作为类型的类
- 4.2.1 把类作为一种类型
- 4.2.2 空指针 nil
- 专栏 关系表达式
- 4.2.3 静态类型检查
- 4.2.4 静态类型检查的总结

4.3 编程中的类型定义
- 4.3.1 签名不一致时的情况
- 专栏 重载
- 4.3.2 类的前置声明
- 4.3.3 强制类型转换的使用示例

4.4 实例变量的数据封装
- 4.4.1 实例变量的访问权限
- 4.4.2 访问器
- 4.4.3 实例变量的可见性
- 4.4.4 在实现部分中定义实例变量

4.5 类对象
- 4.5.1 什么是类对象
- 4.5.2 类对象的类型
- 4.5.3 类方法的定义
- 4.5.4 类变量
- 4.5.5 类对象的初始化
- 4.5.6 初始化方法的返回值



第 5 章 基于引用计数的内存管理

5.1 动态内存管理
- 5.1.1 内存管理的必要性
- 5.1.2 引用计数、自动引用计数和自动垃圾回收

5.2 手动引用计数内存管理
- 5.2.1 引用计数
- 5.2.2 测试引用计数的例子
- 5.2.3 释放对象的方法
- 5.2.4 访问方法和对象所有权
- 专栏 静态对象
- 5.2.5 自动释放
- 5.2.6 使用自动释放池时需要注意的地方
- 5.2.7 临时对象的生成
- 5.2.8 运行回路和自动释放池
- 专栏 常量修饰符 const

5.3 分数计算器的例子
- 5.3.1 分数类 Faction
- 5.3.2 保存计算结果的 FracRegister 类
- 5.3.3 主函数和执行示例

5.4 ARC 概要
- 5.4.1 什么是 ARC
- 5.4.2 禁止调用引用计数的相关函数
- 5.4.3 管理自动释放池的新语法
- 5.4.4 变量的初始值
- 5.4.5 方法族
- 5.4.6 方法 dealloc 的定义
- 5.4.7 使用 ARC 的程序的编译
- 5.4.8 ARC 的基本注意事项
- 5.4.9 使用 ARC 重构分数计算器

5.5 循环引用和弱引用
- 5.5.1 循环引用
- 5.5.2 所有权和对象间的关系
- 5.5.3 弱引用
- 5.5.4 自动 nil 化的弱引用
- 5.5.5 对象之间引用关系的基本原则

5.6 ARC 编程时其他一些注意事项
- 5.6.1 可以像通常的指针一样使用的对象
- 5.6.2 setter 方法的注意事项
- 5.6.3 通过函数的参数返回结果对象
- 5.6.4 C 语言数组保存 Objective-C 对象
- 5.6.5 ARC 对结构体的一些限制
- 5.6.6 提示编译器进行特别处理



第 6 章 垃圾回收
- 6.1 垃圾回收的概要
  - 6.1.1 查找不再使用的对象
  - 6.1.2 编程时的注意事项
  - 6.1.3 垃圾收集器
  - 6.1.4 finalize 方法的定义
  - 6.1.5 编译时的设定
  - 6.1.6 引用计数管理方式中方法的处理
  - 6.1.7 使用垃圾回收编程小结
- 6.2 垃圾回收的详细功能
  - 6.2.1 分代垃圾回收
  - 6.2.2 弱引用
  - 6.2.3 自动 nil 化
  - 6.2.4 通过垃圾回收回收动态分配的内存
  - 6.2.5 __strong 修饰符的使用方法
  - 6.2.6 NSGarbageCollector 类
  - 6.2.7 实时 API
- 6.3 内存管理方式的比较
  - 6.3.1 引用计数和垃圾回收
  - 6.3.2 更改内存管理方式
  - 6.3.3 各种内存管理方式的比较

第 7 章 属性声明
- 7.1 属性是什么
  - 7.1.1 使用属性编程
  - 7.1.2 属性的概念
- 专栏 内省
- 7.2 属性的声明和功能
  - 7.2.1 显式声明属性
  - 7.2.2 属性的实现
  - 7.2.3 @synthesize 和实例变量
  - 7.2.4 通过 @synthesize 生成实例变量
  - 7.2.5 给属性指定选项
  - 7.2.6 赋值时的选项
  - 7.2.7 原子性
  - 7.2.8 属性声明和继承
  - 7.2.9 方法族和属性的关系
- 7.3 通过点操作符访问属性
  - 7.3.1 点操作符的使用方法
  - 7.3.2 复杂的点操作符的使用方法
  - 7.3.3 何时使用点操作符

  

第 8 章 类 NSObject 和运行时系统

8.1 类 NSObject
- 8.1.1 根类的作用
- 8.1.2 类和实例
- 8.1.3 实例对象的生成和释放
- 8.1.4 初始化
- 8.1.5 对象的比较
- 8.1.6 对象的内容描述

8.2 消息发送机制
- 8.2.1 选择器和 SEL 类型
- 8.2.2 消息搜索
- 8.2.3 以函数的形式来调用方法
- 专栏 函数指针
- 8.2.4 对 self 进行赋值
- 8.2.5 发送消息的速度
- 8.2.6 类对象和根类
- 8.2.7 Target-action paradigm
- 8.2.8 Xcode 中的动作方法和 Outlet 的写法

8.3 Objective-C 和 Cocoa 环境
- 8.3.1 Cocoa 环境和 Mac OS X
- 8.3.2 Cocoa Touch 和 iOS
- 8.3.3 框架
- 8.3.4 框架的构成和头文件

8.4 全新的运行时系统
- 8.4.1 对 64 位的对应和现代运行时系统
- 8.4.2 数据模型
- 8.4.3 64 位模型和整数类型
- 8.4.4 Core Graphics 的浮点数类型
- 8.4.5 健壮实例变量
- 专栏 条件编译



第 9 章 Foundation 框架中常用的类

9.1 对象的可变性
- 9.1.1 可变对象和不可变对象
- 9.1.2 可变对象的生成

9.2 字符串类 NSString
- 9.2.1 常量字符串
- 9.2.2 NSString
- 9.2.3 NSMutableString

9.3 NSData
- 9.3.1 NSData
- 9.3.2 NSMutableData

9.4 数组类
- 9.4.1 NSArray
- 9.4.2 NSMutableArray
- 9.4.3 数组对象的所有权
- 9.4.4 快速枚举
- 9.4.5 枚举器 NSEnumerator
- 9.4.6 快速枚举和枚举器
- 9.4.7 集合类

9.5 词典类

9.6 包裹类
- 9.6.1 NSNumber
- 9.6.2 NSValue
- 9.6.3 类型编码和 @encode()
- 9.6.4 NSNull

9.7 NSURL
- 9.7.1 关于 URL
- 9.7.2 NSURL 的概要
- 9.7.3 使用 NSURL 来访问资源

第 10 章 范畴

10.1 范畴
- 10.1.1 范畴
- 10.1.2 范畴和文件的组织
- 10.1.3 作为子模块的范畴
- 10.1.4 方法的前向声明
- 10.1.5 私有方法
- 10.1.6 类扩展
- 10.1.7 范畴和属性声明

10.2 给现有类追加范畴
- 10.2.1 追加新的方法
- 10.2.2 追加方法的例子
- 专栏 可变参数的方法的定义
- 10.2.3 覆盖已有的方法

10.3 关联引用
- 10.3.1 关联引用的概念
- 10.3.2 添加和检索关联
- 10.3.3 对象的存储方法
- 10.3.4 断开关联
- 10.3.5 利用范畴的例子



第 11 章 抽象类和类簇
- 11.1 抽象类
  - 11.1.1 什么是抽象类
  - 11.1.2 抽象类的例子
- 11.2 类簇
  - 11.2.1 类簇的概念
  - 11.2.2 测试程序
  - 11.2.3 编程中的注意事项
- 11.3 生成类簇的子类
  - 11.3.1 使用范畴
  - 11.3.2 基本方法的重定义
  - 11.3.3 生成字符串的子类

第 12 章 协议
- 12.1 协议的概念
  - 12.1.1 什么是协议
  - 12.1.2 对象的协议
- 12.2 Objective-C 中协议的声明
  - 12.2.1 协议的声明
  - 12.2.2 协议的采用
  - 12.2.3 协议的继承
  - 12.2.4 指定协议的类型声明
  - 12.2.5 协议的前置声明
  - 12.2.6 协议适用性检查
  - 12.2.7 必选功能和可选功能
  - 12.2.8 使用协议的程序示例
  - 专栏 类的多重继承
- 12.3 非正式协议
  - 12.3.1 什么是非正式协议
  - 12.3.2 非正式协议的用途
  - 专栏 使用宏（macro）来区分系统版本的差异

第 13 章 对象的复制及存储
- 13.1 对象的复制
  - 13.1.1 浅复制和深复制
  - 13.1.2 区域
  - 13.1.3 复制方法的定义
  - 13.1.4 复制方法的例子
  - 13.1.5 实现可变复制
- 13.2 归档
  - 13.2.1 对象的归档
  - 13.2.2 Foundation 框架的归档功能
  - 13.2.3 归档方法的定义
  - 13.2.4 归档方法定义
  - 13.2.5 归档和解档的初始化方法
- 13.3 属性表
  - 13.3.1 属性表概况
  - 13.3.2 ASCII 码格式属性表
  - 13.3.3 XML 格式属性表
  - 13.3.4 属性表的变换和检查

  

第 14 章 块对象
- 14.1 什么是块对象
  - 14.1.1 C 编译器和 GCD
  - 14.1.2 块对象的定义
  - 14.1.3 块对象和类型声明
  - 14.1.4 块对象中的变量行为
  - 14.1.5 排序函数和块对象
- 14.2 块对象的构成
  - 14.2.1 块对象的实例和生命周期
  - 14.2.2 应该避免的编码模式
  - 14.2.3 块对象的复制
  - 14.2.4 指定特殊变量 _block
- 14.3 Objective-C 和块对象
  - 14.3.1 方法定义和块对象
  - 14.3.2 作为 Objective-C 对象的块对象
  - 14.3.3 ARC 和块对象
  - 14.3.4 对象内变量的行为
  - 14.3.5 集合类中添加的方法
  - 14.3.6 在窗体中使用块对象
  - 14.3.7 ARC 中使用块对象的注意事项

第 15 章 消息发送模式
- 15.1 应用和运行回路
  - 15.1.1 运行回路
  - 15.1.2 定时器对象
  - 15.1.3 消息的延迟执行
- 15.2 委托
  - 15.2.1 委托的概念
  - 15.2.2 Cocoa 环境中的委托
  - 15.2.3 委托的设置和协议
  - 15.2.4 使用委托的程序
- 15.3 通知
  - 15.3.1 通知和通知中心的概念
  - 15.3.2 通知对象
  - 15.3.3 通知中心
  - 15.3.4 通知队列
  - 专栏 通知名或异常名的定义
- 15.4 反应链
  - 15.4.1 反应链概述
  - 15.4.2 应用中的反应链
- 15.5 消息转送
  - 15.5.1 消息转送的构成
  - 15.5.2 消息转送需要的信息
  - 15.5.3 消息转送的定义
  - 15.5.4 禁止使用消息
  - 15.5.5 程序示例
- 15.6 撤销构造
  - 15.6.1 撤销构造的概念
  - 15.6.2 在撤销管理器中记录操作

  

第 16 章 应用的构造

16.1 应用束
- 16.1.1 应用束的构造
- 16.1.2 nib 文件和各语言资源
- 专栏 指定语言和地区
- 16.1.3 信息文件的主要内容
- 16.1.4 通过 NSBundle 访问资源
- 16.1.5 iOS 中资源的访问
- 16.1.6 通用二进制

16.2 加载 nib 文件
- 16.2.1 nib 文件实例化
- 16.2.2 在 Mac OS X 中加载 nib 文件
- 16.2.3 在 iOS 中加载 nib 文件
- 16.2.4 nib 文件内的包含循环
- 16.2.5 nib 文件内对象的初始化
- 16.2.6 启动应用

16.3 iOS 的文件保存场所
- 16.3.1 主要目录及功能
- 16.3.2 获取目录路径

16.4 用户默认
- 16.4.1 保存设定值
- 16.4.2 默认域
- 16.4.3 查找用户默认的工具
- 16.4.4 NSUserDefaults 概要

16.5 应用的本地化
- 16.5.1 消息的本地化
- 16.5.2 本地化指针
- 专栏 本地化应用名
- 16.5.3 本地化
- 专栏 消息内的语序

16.6 模块的动态加载
- 16.6.1 可加载束
- 16.6.2 使用可加载束的程序
- 16.6.3 插件概述
- 专栏 沙盒（App Sandbox）

第 17 章 实例：简单图像视图

17.1 Application 框架和 Interface Builder

17.2 程序概况
- 17.2.1 对象间的关系
- 17.2.2 通知
- 17.2.3 撤销和重做
- 17.2.4 可加载束和本地化
- 17.2.5 用户默认

17.3 编程介绍
- 17.3.1 main 函数和 MyViewerCtrl 类
- 17.3.2 类 WinCtr
- 17.3.3 类 MyInspector

17.4 应用束的组织
- 17.4.1 创建编译和设置文件
- 17.4.2 程序运行例子
- 17.4.3 GUI 定义文件和程序
- 专栏 Objective-C 调试器的功能


第 18 章 异常和错误

18.1 异常
- 18.1.1 异常处理的概念
- 18.1.2 Objective-C 中的异常处理

18.2 异常处理机制概述
- 18.2.1 异常句柄和异常处理域
- 18.2.2 异常表示类 NSException
- 18.2.3 异常处理机制的语法
- 18.2.4 简单的异常处理的示例程序
- 专栏 日志输出函数 NSLog()

18.3 异常的发生和传播
- 18.3.1 异常的传播
- 18.3.2 自己触发异常
- 18.3.3 用 @throw 语法产生异常
- 18.3.4 @catch 的特殊语法
- 18.3.5 异常传播和 @finally
- 18.3.6 异常处理程序的注意点

18.4 断言
- 18.4.1 断言是什么
- 18.4.2 断言宏
- 专栏 包含可变个数的参数的宏

18.5 错误处理
- 18.5.1 错误处理结构的目的
- 18.5.2 表示错误的类 NSError 的使用方法
- 18.5.3 获取错误对象的信息
- 18.5.4 生成自定义错误对象

18.6 错误反应链
- 18.6.1 错误反应链的结构
- 18.6.2 错误对象的更改和恢复
- 专栏 单元测试


第 19 章 并行编程

19.1 多线程
- 19.1.1 线程的基本概念
- 19.1.2 线程安全
- 19.1.3 注意点
- 19.1.4 使用 NSThread 创建线程
- 19.1.5 当前线程
- 19.1.6 GUI 应用和线程

19.2 互斥
- 19.2.1 需要互斥的例子
- 19.2.2 锁
- 19.2.3 死锁
- 19.2.4 尝试获得锁
- 19.2.5 条件锁
- 19.2.6 NSRecursiveLock
- 19.2.7 @synchronized

19.3 操作对象和并行处理
- 19.3.1 新的并行处理程序
- 19.3.2 使用 NSOperation 的处理概述
- 19.3.3 NSOperation 和 NSOperationQueue 的简单用法
- 19.3.4 等待至聚合任务终止
- 19.3.5 使用操作对象的简单程序
- 19.3.6 NSInvocationOperation 的使用方法
- 19.3.7 NSBlockOperation 的使用方法
- 19.3.8 NSBlockOperation 中添加多个块对象
- 19.3.9 设置任务间的依赖
- 19.3.10 任务的优先级设置
- 19.3.11 设置最大并行任务数
- 19.3.12 终止任务
- 19.3.13 设置队列调度为中断状态

19.4 并行处理的示例程序
- 19.4.1 程序概要
- 19.4.2 类 BrowsingViewCtrl
- 19.4.3 类 BrowsingWinCtrl
- 19.4.4 类 DrawOperation
- 19.4.5 其他改变

19.5 使用连接的通信
- 19.5.1 连接
- 19.5.2 代理
- 19.5.3 方法的指针参数
- 19.5.4 对象的副本传递
- 19.5.5 异步通信
- 19.5.6 设置协议
- 19.5.7 运行回路的开始
- 19.5.8 接收消息时的处理

19.9 线程间连接
- 19.9.9 线程间连接
- 19.5.10 进程间连接的例子



第 20 章 键值编码

20.1 键值编码概况
- 20.1.1 什么是键值编码
- 20.1.2 键值编码的基本处理

20.2 访问属性
- 20.2.1 键值编码的方法的行为
- 20.2.2 属性值的自动转换
- 20.2.3 字典对象和键值编码
- 20.2.4 根据键路径进行访问
- 20.2.5 一对一关系和一对多关系
- 20.2.6 数组对象和键值编码

20.3 一对多关系的访问
- 20.3.1 带索引的访问器模式
- 20.3.2 一对多关系的可变访问

20.4 KVC 标准
- 20.4.1 验证属性值
- 20.4.2 键值编码的准则

20.5 键值观察
- 20.5.1 键值观察的基础
- 20.5.2 示例程序
- 20.5.3 一对多关系的属性监视
- 20.5.4 依赖键的登记

20.6 Cocoa 绑定概述
- 20.6.1 目标－行为－模式的弱点
- 20.6.2 什么是 Cocoa 绑定
- 20.6.3 Cocoa 绑定所需的方法
- 20.6.4 例题：绘制二次函数图的软件
- 20.6.5 自定义视图的方法定义


第21章 现代Objective-C开发
- 21.1 Swift互操作
- 21.2 Modern Objective-C特性
- 21.3 新框架集成
- 21.4 混合开发策略

第22章 开发工具与调试
- 22.1 Xcode高级使用
- 22.2 调试技巧
- 22.3 性能优化
- 22.4 持续集成

第23章 设计模式与架构
- 23.1 常用设计模式
- 23.2 架构设计原则
- 23.3 组件化开发
- 23.4 代码重构

第24章 测试与质量保证
- 24.1 单元测试
- 24.2 UI测试
- 24.3 性能测试
- 24.4 代码覆盖率

第25章 安全开发指南
- 25.1 数据安全
- 25.2 网络安全
- 25.3 加密技术
- 25.4 安全最佳实践
### 第1章 Java程序设计概述
1.1 Java程序设计平台  
1.2 Java白皮书的关键术语  
1.2.1 简单性  
1.2.2 面向对象  
1.2.3 分布式  
1.2.4 健壮性  
1.2.5 安全性  
1.2.6 体系结构中立  
1.2.7 可移植性  
1.2.8 解释性  
1.2.9 高性能  
1.2.10 多线程  
1.2.11 动态性  
1.3 Java applet与Internet  
1.4 Java发展简史  
1.5 关于Java的常见误解  

### 第2章 Java编程环境
2.1 安装Java开发工具包  
2.1.1 下载JDK  
2.1.2 设置JDK  
2.1.3 安装源文件和文档  
2.2 使用命令行工具  
2.3 使用集成开发环境  
2.4 JShell  

### 第3章 Java的基本程序设计结构
3.1 一个简单的Java程序  
3.2 注释  
3.3 数据类型  
3.3.1 整型  
3.3.2 浮点类型  
3.3.3 char类型  
3.3.4 Unicode和char类型  
3.3.5 boolean类型  
3.4 变量与常量  
3.4.1 声明变量  
3.4.2 初始化变量  
3.4.3 常量  
3.4.4 枚举类型  
3.5 运算符  
3.5.1 算术运算符  
3.5.2 数学函数与常量  
3.5.3 数值类型之间的转换  
3.5.4 强制类型转换  
3.5.5 赋值  
3.5.6 自增与自减运算符  
3.5.7 关系和boolean运算符  
3.5.8 条件运算符  
3.5.9 switch表达式  
3.5.10 位运算符  
3.5.11 括号与运算符级别  
3.6 字符串  
3.6.1 子串  
3.6.2 拼接  
3.6.3 字符串不可变  
3.6.4 检测字符串是否相等  
3.6.5 空串与Null串  
3.6.6 码点与代码单元  
3.6.7 String API  
3.6.8 阅读联机API文档  
3.6.9 构建字符串  
3.6.10 文本块  
3.7 输入与输出  
3.7.1 读取输入  
3.7.2 格式化输出  
3.7.3 文件输入与输出  
3.8 控制流程  
3.8.1 块作用域  
3.8.2 条件语句  
3.8.3 循环  
3.8.4 确定性循环  
3.8.5 多重选择：switch语句  
3.8.6 中断控制流程的语句  
3.9 大数  
3.10.1 声明数组  
3.10.2 访问数组元素  
3.10.3 for each循环  
3.10.4 数组拷贝  
3.10.5 命令行参数  
3.10.6 数组排序  
3.10.7 多维数组  
3.10.8 不规则数组  

### 第4章 对象与类
4.1 面向对象程序设计概述  
4.1.1 类  
4.1.2 对象  
4.1.3 识别类  
4.2 使用预定义类  
4.2.1 对象与对象变量  
4.2.2 Java类库中的LocalDate类  
4.2.3 更改器方法与访问器方法  
4.3 自定义类  
4.3.1 Employee类  
4.3.2 使用多个源文件  
4.3.3 剖析Employee类  
4.3.4 从构造器开始  
4.3.5 用var声明局部变量  
4.3.6 使用null引用  
4.3.7 隐式参数与显式参数  
4.3.8 封装的优点  
4.3.9 基于类的访问权限  
4.3.10 私有方法  
4.3.11 final实例字段  
4.4 静态字段与静态方法  
4.4.1 静态字段  
4.4.2 静态常量  
4.4.3 静态方法  
4.4.4 工厂方法  
4.4.5 main方法  
4.5 方法参数  
4.6 对象构造  
4.6.1 重载  
4.6.2 默认字段初始化  
4.6.3 无参数的构造器  
4.6.4 显式字段初始化  
4.6.5 参数名  
4.6.6 调用另一个构造器  
4.6.7 初始化块  
4.6.8 对象析构与finalize方法  
4.7 记录  
4.7.1 记录概念  
4.7.2 构造器：标准、自定义和简洁  
4.8 包  
4.8.1 包名  
4.8.2 类的导入  
4.8.3 静态导入  
4.8.4 在包中增加类  
4.8.5 包访问  
4.8.6 类路径  
4.8.7 设置类路径  
4.9 JAR文件  
4.9.1 创建JAR文件  
4.9.2 清单文件  
4.9.3 可执行JAR文件  
4.9.4 多版本JAR文件  
4.9.5 关于命令行选项的说明  
4.10 文档注释  
4.10.1 注释的插入  
4.10.2 类注释  
4.10.3 方法注释  
4.10.4 字段注释  
4.10.5 通用注释  
4.10.6 包注释  
4.10.7 注释提取  
4.10.8 类设计技巧  

### 第5章 继承
5.1 类、超类和子类  
5.1.1 定义子类  
5.1.2 覆盖方法  
5.1.3 子类构造器  
5.1.4 继承层次结构  
5.1.5 多态  
5.1.6 理解方法调用  
5.1.7 阻止继承：final类和方法  
5.1.8 强制类型转换  
5.1.9 强制cast模式匹配  
5.1.10 受保护访问  
5.2 Object：所有类的超类  
5.2.1 Object类型的变量  
5.2.2 equals方法  
5.2.3 相等测试与继承  
5.2.4 hashCode方法  
5.2.5 toString方法  
5.3 泛型数组列表  
5.3.1 声明数组列表  
5.3.2 访问数组列表元素  
5.3.3 类型化与原始数组列表的兼容性  
5.4 对象包装器与自动装箱  
5.5 参数个数可变的方法  

### 第6章 接口、lambda表达式与内部类
6.1 接口  
6.1.1 接口的概念  
6.1.2 接口的属性  
6.1.3 接口与抽象类  
6.1.4 静态和私有方法  
6.1.5 默认方法  
6.1.6 解决默认方法冲突  
6.1.7 接口与回调  
6.1.8 Comparator接口  
6.1.9 对象克隆  
6.2 lambda表达式  
6.2.1 为什么引入lambda表达式  
6.2.2 lambda表达式的语法  
6.2.3 函数式接口  
6.2.4 方法引用  
6.2.5 构造器引用  
6.2.6 变量作用域  
6.2.7 处理lambda表达式  
6.2.8 再谈Comparator  
6.3 内部类  
6.3.1 使用内部类访问对象状态  
6.3.2 内部类的特殊语法规则  
6.3.3 内部类是否有用、必要和安全  
6.3.4 局部内部类  
6.3.5 由外部方法访问变量  
6.3.6 匿名内部类  
6.4 服务加载器  
6.5 代理  
6.5.1 何时使用代理  
6.5.2 创建代理对象  
6.5.3 代理模式应用  

以下是从图片中识别出的目录信息：

### 第7章 异常、断言和日志
7.1 处理错误  
7.1.1 异常分类  
7.1.2 声明检查型异常  
7.1.3 如何抛出异常  
7.1.4 创建异常类  
7.2 捕获异常  
7.2.1 捕获异常概述  
7.2.2 捕获多个异常  
7.2.3 再次抛出异常与异常链  
7.2.4 finally子句  
7.2.5 try-with-Resources语句  
7.2.6 分析栈轨迹元素  
7.3 使用异常的技巧  
7.4 使用断言  
7.4.1 断言的概念  
7.4.2 启用和禁用断言  
7.4.3 使用断言完成参数检查  
7.4.4 使用断言提供假设文档  
7.5 日志  
7.5.1 基本日志  
7.5.2 高级日志  
7.5.3 修改日志管理器配置  
7.5.4 本地化  
7.5.5 处理器  
7.5.6 格式化器  
7.5.7 日志技巧  
7.6 调试技巧  

### 第8章 泛型程序设计
8.1 为什么要使用泛型程序设计  
8.1.1 类型参数的好处  
8.1.2 谁想成为泛型程序员  
8.2 定义简单泛型类  
8.3 泛型方法  
8.4 类型变量的限定  
8.5.1 类型擦除  
8.5.2 转换泛型表达式  
8.5.3 转换方法  
8.5 限制与局限性  
8.6.1 不能用基本类型实例化类型参数  
8.6.2 运行时类型查询只适用于原始类型  
8.6.3 不能创建参数化类型的数组  
8.6.4 Varargs警告  
8.6.5 不能实例化类型变量  
8.6.6 不能构造泛型数组  
8.6.7 泛型类的静态上下文中类型变量无效  
8.6.8 不能抛出或捕获泛型类的实例  
8.6.9 可以取消对检查型异常的检查  
8.6.10 注意擦除后的冲突  
8.7 泛型类型的继承规则  
8.8 通配符类型  
8.8.1 通配符概念  
8.8.2 通配符的超类型限定  
8.8.3 无限定通配符  
8.8.4 通配符捕获  
8.9 反射和泛型  
8.9.1 泛型Class类  
8.9.2 使用Class<T>参数进行类型匹配  
8.9.3 虚拟机中的泛型类型信息  
8.9.4 类型字面量  

### 第9章 集合
9.1 Java集合框架  
9.1.1 集合接口与实现分离  
9.1.2 Collection接口  
9.1.3 迭代器  
9.1.4 泛型实用方法  
9.2 集合框架中的接口  
9.3 具体集合  
9.3.1 链表  
9.3.2 数组列表  
9.3.3 散列表  
9.3.4 树集  
9.3.5 队列与双端队列  
9.3.6 优先队列  
9.4 映射  
9.4.1 基本映射操作  
9.4.2 更新映射条目  
9.4.3 映射视图  
9.4.4 弱散列映射  
9.4.5 链接散列表与映射  
9.4.6 枚举集与映射  
9.4.7 标识散列映射  
9.5 副本与视图  
9.5.1 小集合  
9.5.2 不可修改的副本和视图  
9.5.3 子范围  
9.5.4 检查型视图  
9.5.5 同步视图  
9.5.6 关于可选操作的说明  
9.6 算法  
9.6.1 为什么使用泛型算法  
9.6.2 排序与混排  
9.6.3 二分查找  
9.6.4 简单算法  
9.6.5 批操作  
9.6.6 集合与数组的转换  
9.6.7 编写自己的算法  
9.7 遗留的集合  
9.7.1 Hashtable类  
9.7.2 枚举  
9.7.3 属性映射  
9.7.4 栈  
9.7.5 位集  

### 第10章 并发

10.1 什么是线程  
10.2 线程状态  
10.2.1 新建线程  
10.2.2 可运行线程  
10.2.3 阻塞和等待线程  
10.2.4 终止线程  
10.3 线程属性  
10.3.1 中断线程  
10.3.2 守护线程  
10.3.3 线程名  
10.3.4 未捕获异常的处理器  
10.3.5 线程优先级  
10.4 同步  
10.4.1 竞态条件的一个例子  
10.4.2 竞态条件详解  
10.4.3 锁对象  
10.4.4 条件对象  
10.4.5 synchronized关键字  
10.4.6 同步块  
10.4.7 监视器概念  
10.4.8 volatile字段  
10.4.9 final变量  
10.4.10 原子性  
10.4.11 死锁  
10.4.12 为什么废弃stop和suspend方法  
10.4.13 按需初始化  
10.4.14 线程局部变量  
10.5 线程安全的集合  
10.5.1 阻塞队列  
10.5.2 高效的映射、集和队列  
10.5.3 映射条目的原子更新  
10.5.4 并发散列映射的批操作  
10.5.5 并发视图  
10.5.6 写时拷贝数组  
10.5.7 并行数组算法  
10.5.8 较早的线程安全集合  
10.6 Java并发工具包(JUC)
10.6.1 原子变量类
10.6.2 锁与条件
10.6.3 读写锁
10.6.4 信号量
10.6.5 倒计时门闩
10.6.6 循环栅栏
10.6.7 交换器
10.6.8 同步队列
10.6.9 Phaser
10.6.10 并发工具类的选择
10.7 任务和线程池  
10.7.1 Callable与Future  
10.7.2 执行器  
10.7.3 控制任务组  
10.7.4 fork-join框架  
10.8 异步计算  
10.8.1 可完成Future  
10.8.2 组合可完成Future  
10.8.3 异步编程模式
10.8.4 响应式编程基础
10.9 虚拟线程
10.9.1 虚拟线程概念
10.9.2 创建虚拟线程
10.9.3 虚拟线程与平台线程的区别
10.9.4 线程挂起点
10.9.5 性能考量
10.9.6 迁移策略
10.10 结构化并发
10.10.1 结构化任务作用域
10.10.2 作用域内的异常处理
10.10.3 取消传播
10.10.4 最佳实践
10.10.5 与虚拟线程的协同
10.11 进程  
10.11.1 建立进程  
10.11.2 运行进程  
10.11.3 进程句柄
10.11.4 进程通信



### 第11章 流  
11.1 从迭代到流的操作  
11.2 流的创建  
11.3 filter、map 和 flatMap 方法  
11.4 抽取子流和组合流  
11.5 其他的流转换  
11.6 简单约简  
11.7 Optional 类型  
11.7.1 获取 Optional 值  
11.7.2 消费 Optional 值  
11.7.3 管道化 Optional 值  
11.7.4 不适合使用 Optional 值的方式  
11.7.5 创建 Optional 值  
11.7.6 用 flatMap 构建 Optional 值的函数  
11.7.7 将 Optional 转换为流  
11.8 收集结果  
11.9 收集到映射表中  
11.10 群组和分区  
11.11 下游收集器  
11.12 约简操作  
11.13 基本类型流  
11.14 并行流  



### 第12章 输入与输出  
12.1 输入 / 输出流  
12.1.1 读写字节  
12.1.2 完整的流家族  
12.1.3 组合输入 / 输出流过滤器  
12.1.4 文本输入与输出  
12.1.5 如何写出文本输出  
12.1.6 如何读入文本输入  
12.1.7 以文本格式存储对象  
12.1.8 字符编码方式  
12.2 读写二进制数据  
12.2.1 DataInput 和 DataOutput 接口  
12.2.2 随机访问文件  
12.2.3 ZIP 文档  
12.3 对象输入 / 输出流与序列化  
12.3.1 保存和加载序列化对象  
12.3.2 理解对象序列化的文件格式  
12.3.3 修改默认的序列化机制  
12.3.4 readResolve 和 writeReplace 方法  
12.3.5 版本管理  
12.3.6 为克隆使用序列化  
12.3.7 反序列化和安全  
12.4 操作文件  
12.4.1 Path  
12.4.2 读写文件  
12.4.3 创建文件和目录  
12.4.4 复制、移动和删除文件  
12.4.5 获取文件信息  
12.4.6 访问目录中的项  
12.4.7 使用目录流  
12.4.8 ZIP 文件系统  
12.5 内存映射文件  
12.5.1 内存映射文件的性能  
12.5.2 缓冲区数据结构  
12.6 文件加锁机制  
12.7 正则表达式  
12.7.1 正则表达式语法  
12.7.2 匹配整个字符串  
12.7.3 找出字符串中的所有匹配  
12.7.4 群组  
12.7.5 用分隔符来分割  
12.7.6 替换匹配  
12.7.7 标志  



### 第13章 XML  
13.1 XML 概述  
13.2 XML 文档的结构  
13.3 解析 XML 文档  
13.4 验证 XML 文档  
13.4.1 文档类型定义  
13.4.2 XML Schema  
13.4.3 一个实践示例  
13.5 使用 XPath 来定位信息  
13.6 使用命名空间  
13.7 流机制解析器  
13.7.1 使用 SAX 解析器  
13.7.2 使用 StAX 解析器  
13.8 生成 XML 文档  
13.8.1 不带命名空间的文档  
13.8.2 带命名空间的文档  
13.8.3 写出文档  
13.8.4 使用 StAX 写出 XML 文档  
13.8.5 示例：生成 SVG 文件  
13.9 XSL 转换  



### 第14章 网络  
14.1 连接到服务器  
14.1.1 使用 telnet  
14.1.2 用 Java 连接到服务器  
14.1.3 套接字超时  
14.1.4 因特网地址  
14.2 实现服务器  
14.2.1 服务器套接字  
14.2.2 为多个客户端服务  
14.2.3 半关闭  
14.2.4 可中断套接字  
14.3 获取 Web 数据  
14.3.1 URL 和 URI  
14.3.2 使用 URLConnection 获取信息  
14.3.3 提交表单数据  
14.4 HTTP 客户端  
14.4.1 HttpClient 类  
14.4.2 HttpRequest 类和体发布器  
14.4.3 HttpResponse 接口和体处理器  
14.4.4 异步处理  
14.5 发送 E-mail  



### 第15章 数据库编程  
15.1 JDBC 的设计  
15.1.1 JDBC 驱动程序类型  
15.1.2 JDBC 的典型用法  
15.2 结构化查询语言  
15.3 JDBC 配置  
15.3.1 数据库 URL  
15.3.2 驱动程序 JAR 文件  
15.3.3 启动数据库  
15.3.4 注册驱动器类  
15.3.5 连接到数据库  
15.4 使用 JDBC 语句  
15.4.1 执行 SQL 语句  
15.4.2 管理连接、语句和结果集  
15.4.3 分析 SQL 异常  
15.4.4 组装数据库  
15.5 执行查询操作  
15.5.1 预备语句  
15.5.2 读写 LOB  
15.5.3 SQL 转义  
15.5.4 多结果集  
15.5.5 获取自动生成的键  
15.6 可滚动和可更新的结果集  
15.6.1 可滚动的结果集  
15.6.2 可更新的结果集  
15.7 行集  
15.7.1 构建行集  
15.7.2 被缓存的行集  
15.8 元数据  
15.9 事务  
15.9.1 用 JDBC 对事务编程  
15.9.2 保存点  
15.9.3 批量更新  
15.9.4 高级 SQL 类型  
15.10 Web 与企业应用中的连接管理  



### 第16章 日期和时间 API  
16.1 时间线  
16.2 本地日期  
16.3 日期调整器  
16.4 本地时间  
16.5 时区时间  
16.6 格式化和解析  
16.7 与遗留代码的互操作  



### 第17章 国际化  
17.1 locale  
17.1.1 为什么需要 locale  
17.1.2 指定 locale  
17.1.3 默认 locale  
17.1.4 显示名字  
17.2 数字格式  
17.2.1 格式化数字值  
17.2.2 DecimalFormat 类  
17.2.3 货币  
17.3 日期和时间  
17.4 排序和规范化  
17.5 消息格式化  
17.5.1 格式化数字和日期  
17.5.2 选择格式  
17.6 文本输入和输出  
17.6.1 文本文件  
17.6.2 行结束符  
17.6.3 控制台  
17.6.4 日志文件  
17.6.5 UTF-8 字节顺序标志  
17.6.6 源文件的字符编码  
17.7 资源包  
17.7.1 定位资源包  
17.7.2 属性文件  
17.7.3 包类  
17.8 一个完整的例子  



### 第18章 脚本、编译与注解处理  
18.1 Java 平台的脚本机制  
18.1.1 获取脚本引擎  
18.1.2 脚本计算与绑定  
18.1.3 重定向输入和输出  
18.1.4 调用脚本的函数和方法  
18.1.5 编译脚本  
18.1.6 示例：用脚本处理 GUI 事件  
18.2 编译器 API  
18.2.1 调用编译器  
18.2.2 发起编译任务  
18.2.3 捕获诊断消息  
18.2.4 从内存中读取源文件  
18.2.5 将字节码写出到内存中  
18.2.6 示例：动态 Java 代码生成  
18.3 使用注解  
18.3.1 注解简介  
18.3.2 示例：注解事件处理器  
18.4 注解语法  
18.4.1 注解接口  
18.4.2 注解  
18.4.3 注解各类声明  
18.4.4 注解类型用法  
18.4.5 注解 this  
18.5 标准注解  
18.5.1 用于编译的注解  
18.5.2 元注解  
18.6 源码级注解处理  
18.6.1 注解处理器  
18.6.2 语言模型 API  
18.6.3 使用注解来生成源码  
18.7 字节码工程  
18.7.1 修改类文件  
18.7.2 在加载时修改字节码  



### 第19章 Java平台模块系统  
19.1 模块的概念  
19.2 对模块命名  
19.3 模块化的 “Hello, World!” 程序  
19.4 对模块的需求  
19.5 导出包  
19.6 模块化的 JAR  
19.7 模块和反射式访问  
19.8 自动模块  
19.9 不具名模块  
19.10 用于迁移的命令行标识  
19.11 传递的需求和静态的需求  
19.12 限定导出和开放  
19.13 服务加载  
19.14 操作模块的工具  



### 第20章 安全  
20.1 类加载器  
20.1.1 类加载过程  
20.1.2 类加载器的层次结构  
20.1.3 将类加载器用作命名空间  
20.1.4 编写你自己的类加载器  
20.1.5 字节码校验  
20.2 用户认证  
20.2.1 JAAS 框架  
20.2.2 JAAS 登录模块  
20.3 数字签名  
20.3.1 消息摘要  
20.3.2 消息签名  
20.3.3 校验签名  
20.3.4 认证问题  
20.3.5 证书签名  
20.3.6 证书请求  
20.3.7 代码签名  
20.4 加密  
20.4.1 对称密码  
20.4.2 密钥生成  
20.4.3 密码流  
20.4.4 公开密钥密码  



### 第21章 本地方法  
21.1 从 Java 程序中调用 C 函数  
21.2 数值参数与返回值  
21.3 字符串参数  
21.4 访问域  
21.4.1 访问实例域  
21.4.2 访问静态域  
21.5 编码签名  
21.6 调用 Java 方法  
21.6.1 实例方法  
21.6.2 静态方法  
21.6.3 构造器  
21.6.4 另一种方法调用  
21.7 访问数组元素  
21.8 错误处理  
21.9 使用调用 API  
21.10 完整的示例：访问 Windows 注册表  
21.10.1 Windows 注册表概述  
21.10.2 访问注册表的 Java 平台接口  
21.10.3 以本地方法实现注册表访问函数  
21.11 外部函数：展望未来


### 第22章 Java新特性专题
22.1 Java版本演进概述
  22.1.1 Java 9-21主要特性一览
  22.1.2 版本发布节奏与支持策略
  22.1.3 预览特性与孵化器模块

22.2 模式匹配
  22.2.1 instanceof模式匹配
  22.2.2 switch表达式基础
  22.2.3 switch模式匹配
  22.2.4 记录模式
  22.2.5 类型模式
  22.2.6 解构模式
  22.2.7 模式匹配的最佳实践

22.3 记录类型
  22.3.1 记录类型的设计初衷
  22.3.2 记录类型的基本语法
  22.3.3 紧凑构造器
  22.3.4 自定义方法与构造器
  22.3.5 记录类型的局限性
  22.3.6 与模式匹配的协同使用
  22.3.7 记录类型的最佳实践

22.4 密封类
  22.4.1 密封类的概念与目标
  22.4.2 permits子句
  22.4.3 密封接口
  22.4.4 与模式匹配和记录的结合
  22.4.5 代数数据类型的实现
  22.4.6 密封类的最佳实践

22.5 文本块与字符串增强
  22.5.1 文本块语法
  22.5.2 格式控制与转义序列
  22.5.3 字符串模板(预览)
  22.5.4 字符串API增强
  22.5.5 文本块的最佳实践

22.6 语言级虚拟线程支持
  22.6.1 虚拟线程的设计目标
  22.6.2 创建与管理虚拟线程
  22.6.3 结构化并发
  22.6.4 从传统线程迁移
  22.6.5 性能考量与最佳实践

22.7 外部内存访问API
  22.7.1 外部内存概念
  22.7.2 内存段与内存地址
  22.7.3 安全访问模型
  22.7.4 与本地方法的对比
  22.7.5 性能优化场景

22.8 向量计算API
  22.8.1 SIMD指令集简介
  22.8.2 向量操作基础
  22.8.3 向量掩码与条件操作
  22.8.4 性能优化案例
  22.8.5 与并行流的对比

22.9 其他语言特性增强
  22.9.1 局部变量类型推断(var)
  22.9.2 增强型switch
  22.9.3 实例化私有构造器
  22.9.4 隐式类型转换
  22.9.5 未命名模式与变量
  22.9.6 未命名类与实例主方法

22.10 API增强
  22.10.1 集合工厂方法
  22.10.2 Stream API增强
  22.10.3 Optional API增强
  22.10.4 HTTP客户端
  22.10.5 进程API
  22.10.6 反应式流

### 第23章 函数式编程深化
23.1 函数式编程范式
  23.1.1 命令式vs函数式
  23.1.2 函数式编程的核心概念
  23.1.3 不变性与副作用
  23.1.4 声明式编程
  23.1.5 Java中的函数式支持历程

23.2 函数式接口深入
  23.2.1 常用函数式接口回顾
  23.2.2 自定义函数式接口设计
  23.2.3 函数式接口组合模式
  23.2.4 多参数函数式接口
  23.2.5 异常处理与函数式接口

23.3 高阶函数
  23.3.1 高阶函数概念
  23.3.2 函数作为参数
  23.3.3 函数作为返回值
  23.3.4 闭包与环境捕获
  23.3.5 高阶函数实战案例

23.4 函数组合
  23.4.1 函数组合基本概念
  23.4.2 andThen与compose方法
  23.4.3 构建函数管道
  23.4.4 函数组合与Stream操作对比
  23.4.5 函数组合最佳实践

23.5 柯里化与部分应用
  23.5.1 柯里化概念
  23.5.2 在Java中实现柯里化
  23.5.3 部分应用函数
  23.5.4 柯里化与函数组合结合
  23.5.5 实际应用场景

23.6 函数式数据结构
  23.6.1 不可变集合
  23.6.2 持久化数据结构
  23.6.3 惰性求值
  23.6.4 自定义函数式数据结构
  23.6.5 第三方库介绍(Vavr, Cyclops)

23.7 模式匹配与代数数据类型
  23.7.1 函数式编程中的模式匹配
  23.7.2 代数数据类型概念
  23.7.3 和记录类型与密封类结合
  23.7.4 访问者模式的函数式替代
  23.7.5 模式匹配最佳实践

23.8 函数式错误处理
  23.8.1 传统异常处理的问题
  23.8.2 Optional深入应用
  23.8.3 Either类型实现
  23.8.4 Try类型实现
  23.8.5 函数式错误处理最佳实践

23.9 函数式并发编程
  23.9.1 并发编程的函数式方法
  23.9.2 CompletableFuture深入
  23.9.3 不变性与并发安全
  23.9.4 并行Stream操作优化
  23.9.5 函数式反应式编程简介

23.10 函数式设计模式
  23.10.1 传统设计模式的函数式实现
  23.10.2 单子(Monad)模式
  23.10.3 应用函子(Applicative)
  23.10.4 装饰器的函数式实现
  23.10.5 依赖注入的函数式方法
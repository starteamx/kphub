#TypeScript知识库
##第1章TypeScript基础
1.1TypeScript简介
1.1.1什么是TypeScript
1.1.2TypeScript与JavaScript的关系
1.1.3TypeScript的优势与应用场景
1.2开发环境搭建
1.2.1安装TypeScript
1.2.2编辑器配置（VSCode/WebStorm）
1.2.3TypeScript编译器（tsc）
1.2.45分钟上手TypeScript
1.3基础类型
1.3.1布尔值、数字和字符串
1.3.2数组和元组
1.3.3枚举
1.3.4any、unknown和void
1.3.5null和undefined
1.3.6never类型
1.3.7object类型
1.4变量声明
1.4.1var声明
1.4.2let声明
1.4.3const声明
1.4.4解构赋值
1.4.5展开运算符
##第2章TypeScript类型系统
2.1接口
2.1.1接口基础
2.1.2可选属性与只读属性
2.1.3函数类型接口
2.1.4索引签名
2.1.5类类型接口
2.1.6接口继承
2.1.7混合类型接口
2.1.8接口与类型别名的区别
2.2类
2.2.1类的基本语法
2.2.2继承
2.2.3公共、私有与受保护的修饰符
2.2.4readonly修饰符
2.2.5存取器
2.2.6静态属性
2.2.7抽象类
2.2.8类与接口结合
2.3函数
2.3.1函数类型
2.3.2可选参数和默认参数
2.3.3剩余参数
2.3.4函数重载
2.3.5this参数
2.3.6箭头函数与this
2.4泛型
2.4.1泛型基础
2.4.2泛型函数
2.4.3泛型接口
2.4.4泛型类
2.4.5泛型约束
2.4.6泛型参数默认值
2.4.7泛型条件类型
2.4.8实用泛型工具类型
2.5高级类型
2.5.1交叉类型
2.5.2联合类型
2.5.3类型保护与区分类型
2.5.4类型别名
2.5.5字面量类型
2.5.6可辨识联合
2.5.7索引类型
2.5.8映射类型
2.5.9条件类型
2.5.10infer关键字
##第3章TypeScript模块与命名空间
3.1模块
3.1.1导出
3.1.2导入
3.1.3默认导出
3.1.4重新导出
3.1.5动态导入
3.2命名空间
3.2.1命名空间基础
3.2.2嵌套命名空间
3.2.3命名空间别名
3.2.4多文件中的命名空间
3.3命名空间与模块
3.3.1命名空间和模块的区别
3.3.2何时使用命名空间
3.3.3何时使用模块
3.4模块解析
3.4.1相对与非相对模块导入
3.4.2模块解析策略
3.4.3路径映射
3.4.4解析JSON模块
3.4.5解决模块解析问题
##第4章TypeScript声明文件
4.1声明文件介绍
4.1.1什么是声明文件
4.1.2声明文件的作用
4.1.3.d.ts文件
4.2声明文件结构
4.2.1全局变量
4.2.2全局函数
4.2.3带属性的对象
4.2.4函数重载
4.2.5可索引类型
4.2.6类类型
4.2.7命名空间
4.3编写声明文件
4.3.1全局库
4.3.2模块库
4.3.3UMD库
4.3.4模块插件
4.3.5全局插件
4.4使用声明文件
4.4.1使用@types
4.4.2查找声明文件
4.4.3自动生成声明文件
4.4.4发布声明文件
4.4.5声明文件最佳实践
##第5章TypeScript高级特性
5.1装饰器
5.1.1装饰器基础
5.1.2类装饰器
5.1.3方法装饰器
5.1.4访问器装饰器
5.1.5属性装饰器
5.1.6参数装饰器
5.1.7装饰器工厂
5.1.8装饰器组合
5.2Mixins
5.2.1Mixin模式
5.2.2构造函数的类型
5.2.3实现Mixin
5.2.4约束Mixin
5.3三斜线指令
5.3.1///<referencepath="..."/>
5.3.2///<referencetypes="..."/>
5.3.3///<referencelib="..."/>
5.3.4///<amd-module/>
5.3.5///<amd-dependency/>
5.4Symbols
5.4.1Symbol基础
5.4.2唯一性与描述
5.4.3内置Symbols
5.4.4Symbol作为属性键
5.5迭代器和生成器
5.5.1可迭代性
5.5.2for..of语句
5.5.3迭代器接口
5.5.4生成器函数
5.5.5异步迭代器
##第6章TypeScript项目配置
6.1tsconfig.json
6.1.1文件结构
6.1.2常用配置选项
6.1.3extends配置继承
6.1.4文件包含与排除
6.2编译选项详解
6.2.1基本选项
6.2.2严格类型检查选项
6.2.3模块解析选项
6.2.4源映射选项
6.2.5实验性选项
6.3项目引用
6.3.1项目引用基础
6.3.2复合项目
6.3.3构建模式
6.3.4项目引用的最佳实践
6.4构建工具集成
6.4.1Webpack集成
6.4.2Rollup集成
6.4.3Gulp集成
6.4.4Babel集成
6.4.5ESLint集成
##第7章TypeScript与框架集成
7.1TypeScript与React
7.1.1创建React+TypeScript项目
7.1.2组件类型定义
7.1.3Props与State类型
7.1.4事件处理
7.1.5Hooks类型定义
7.1.6高阶组件类型
7.1.7ContextAPI类型
7.1.8Redux与TypeScript
7.2TypeScript与Vue
7.2.1Vue3与TypeScript
7.2.2组件定义
7.2.3Props类型
7.2.4CompositionAPI类型
7.2.5Vuex与TypeScript
7.3TypeScript与Angular
7.3.1Angular中的TypeScript
7.3.2组件与服务类型
7.3.3依赖注入类型
7.3.4RxJS与TypeScript
7.4TypeScript与Node.js
7.4.1Node.js项目配置
7.4.2Express与TypeScript
7.4.3NestJS框架
7.4.4TypeORM与数据库交互
##第8章TypeScript最佳实践
8.1类型设计原则
8.1.1类型优先设计
8.1.2接口与类型别名选择
8.1.3泛型设计模式
8.1.4类型安全的API设计
8.2代码组织
8.2.1目录结构
8.2.2模块化设计
8.2.3barrel文件
8.2.4类型定义文件组织
8.3错误处理
8.3.1类型化错误
8.3.2异常处理模式
8.3.3Result类型模式
8.3.4可空类型处理
8.4性能优化
8.4.1类型系统性能考量
8.4.2编译性能优化
8.4.3类型检查优化
8.4.4增量编译
8.5迁移策略
8.5.1JavaScript到TypeScript渐进式迁移
8.5.2any类型的合理使用
8.5.3严格模式迁移
8.5.4遗留代码处理
##第9章TypeScript高级模式与技巧
9.1类型体操
9.1.1递归类型
9.1.2分布式条件类型
9.1.3类型推导与提取
9.1.4高级映射类型
9.1.5模板字面量类型
9.2函数式编程
9.2.1函数式编程基础
9.2.2高阶函数类型
9.2.3函数组合
9.2.4不可变数据结构
9.2.5函数式库与TypeScript
9.3设计模式
9.3.1单例模式
9.3.2工厂模式
9.3.3观察者模式
9.3.4策略模式
9.3.5装饰器模式
9.4测试
9.4.1单元测试
9.4.2Jest与TypeScript
9.4.3类型测试
9.4.4模拟与存根类型
9.5工具类型实现
9.5.1Partial实现
9.5.2Required实现
9.5.3Pick与Omit实现
9.5.4ReturnType实现
9.5.5自定义工具类型
##第10章TypeScript生态系统
10.1类型定义仓库
10.1.1DefinitelyTyped
10.1.2@types包
10.1.3贡献类型定义
10.2TypeScript工具
10.2.1ts-node
10.2.2tsc-watch
10.2.3ts-jest
10.2.4typescript-eslint
10.2.5type-fest
10.3编辑器支持
10.3.1VSCode与TypeScript
10.3.2WebStorm与TypeScript
10.3.3编辑器插件
10.3.4代码片段与快捷方式
10.4社区资源
10.4.1学习资源
10.4.2博客与文章
10.4.3视频教程
10.4.4开源项目
10.4.5TypeScript会议与活动
---
title: 自动化脚本开发基础
icon: practice
order: 5
---

# 自动化脚本开发基础

自动化脚本是实现自动化运维的基础工具，本文将详细介绍Shell、Python等常用脚本语言在运维自动化中的应用，包括基础语法、最佳实践和常见场景示例。

## 1. 自动化脚本概述

### 1.1 什么是自动化脚本

自动化脚本是一系列预先编写的指令集合，用于自动执行重复性任务、标准化操作流程或复杂的系统管理工作，无需或仅需少量人工干预。在运维领域，自动化脚本是提高效率、减少人为错误、确保一致性的关键工具。

自动化脚本的主要特点：
- **自动执行**：无需或仅需少量人工干预
- **可重复**：确保每次执行的一致性
- **可编程**：可以处理条件判断、循环和异常情况
- **可扩展**：可以组合多个脚本形成更复杂的自动化流程
- **可维护**：良好的脚本设计便于后期维护和更新

### 1.2 自动化脚本的价值

在运维工作中，自动化脚本带来的价值主要体现在以下几个方面：

#### 1.2.1 效率提升

- **减少重复工作**：将日常重复性任务自动化，释放运维人员时间
- **加速执行速度**：脚本执行速度通常快于手动操作
- **批量处理**：同时处理多个系统或服务器的任务

#### 1.2.2 质量保障

- **减少人为错误**：避免手动操作中的疏忽和错误
- **标准化操作**：确保每次操作遵循相同的流程和标准
- **一致性结果**：保证在不同环境中获得一致的结果

#### 1.2.3 知识沉淀

- **经验固化**：将运维经验和最佳实践固化到脚本中
- **知识共享**：脚本可以作为知识共享和培训的工具
- **文档化**：良好的脚本本身就是一种文档

#### 1.2.4 成本节约

- **人力成本**：减少需要投入的人力资源
- **时间成本**：缩短任务完成时间
- **错误成本**：减少因人为错误导致的损失

### 1.3 常用自动化脚本语言

在运维自动化领域，常用的脚本语言主要有以下几种：

#### 1.3.1 Shell脚本

Shell脚本是Unix/Linux系统中最基础、最常用的脚本语言，直接与操作系统交互。

**优势**：
- 系统原生支持，无需额外安装
- 直接调用系统命令和工具
- 适合系统管理和简单自动化任务
- 学习曲线相对平缓

**局限性**：
- 跨平台能力有限
- 复杂逻辑处理能力较弱
- 错误处理机制简单
- 代码复用性较低

#### 1.3.2 Python

Python是当前运维自动化领域最流行的语言之一，具有强大的生态系统和丰富的库。

**优势**：
- 语法简洁清晰，易于学习和使用
- 丰富的标准库和第三方库
- 优秀的跨平台能力
- 强大的文本处理和数据分析能力
- 完善的错误处理机制

**局限性**：
- 需要安装Python环境
- 执行速度相对较慢
- 版本兼容性问题(Python 2 vs Python 3)

#### 1.3.3 PowerShell

PowerShell是Microsoft开发的任务自动化和配置管理框架，特别适合Windows环境。

**优势**：
- Windows系统原生支持
- 面向对象的设计
- 与.NET框架紧密集成
- 强大的远程管理能力
- 丰富的内置cmdlet

**局限性**：
- 主要针对Windows环境
- 跨平台版本(PowerShell Core)功能有限
- 学习曲线较陡峭

#### 1.3.4 其他脚本语言

除了上述主要语言外，还有一些在特定场景下常用的脚本语言：

- **Perl**：强大的文本处理能力，曾是运维自动化的主流语言
- **Ruby**：简洁优雅的语法，特别是在配置管理工具(如Chef)中广泛使用
- **JavaScript/Node.js**：在Web服务和云原生环境中的自动化应用
- **Go**：高性能，适合构建运维工具和服务

### 1.4 选择合适的脚本语言

选择合适的脚本语言应考虑以下因素：

1. **目标环境**：目标系统是Windows、Linux还是混合环境
2. **任务复杂度**：简单系统操作还是复杂逻辑处理
3. **团队技能**：团队已有的技术栈和熟悉程度
4. **生态系统**：是否需要特定的库或工具支持
5. **性能要求**：脚本执行效率的要求
6. **维护考虑**：长期维护和扩展的需求

选择建议：
- 对于Linux/Unix系统的简单任务，Shell脚本是最直接的选择
- 对于跨平台、复杂逻辑的任务，Python是最佳选择
- 对于Windows环境的自动化，PowerShell是首选
- 对于特定领域的任务，可以选择该领域常用的专业语言

## 2. Shell脚本基础

Shell脚本是运维自动化的基础工具，特别适合Linux/Unix环境下的系统管理任务。

### 2.1 Shell脚本基础语法

#### 2.1.1 脚本文件和执行

创建Shell脚本文件通常以`.sh`为扩展名，并在文件首行指定解释器：

```bash
#!/bin/bash
# 这是一个简单的Shell脚本示例
echo "Hello, Shell Automation!"
```

执行Shell脚本的方法：

```bash
# 方法1：使用bash命令
bash myscript.sh

# 方法2：添加执行权限后直接执行
chmod +x myscript.sh
./myscript.sh
```

#### 2.1.2 变量定义和使用

Shell变量定义和使用的基本语法：

```bash
#!/bin/bash

# 变量定义（注意等号两边不能有空格）
name="Shell Automation"
current_date=$(date +%Y-%m-%d)  # 命令替换
count=10

# 变量使用（使用$符号引用变量）
echo "Welcome to $name"
echo "Today is $current_date"
echo "Count: $count"

# 变量作用域
local_var="Local"  # 局部变量
export global_var="Global"  # 环境变量

# 特殊变量
echo "脚本名称: $0"
echo "第一个参数: $1"
echo "参数个数: $#"
echo "所有参数: $@"
echo "脚本PID: $$"
```

#### 2.1.3 条件判断

Shell脚本中的条件判断结构：

```bash
#!/bin/bash

# if-else语句
if [ $# -eq 0 ]; then
    echo "请提供至少一个参数"
    exit 1
elif [ $# -eq 1 ]; then
    echo "提供了一个参数: $1"
else
    echo "提供了多个参数: $@"
fi

# 文件测试
if [ -f "/etc/passwd" ]; then
    echo "/etc/passwd 文件存在"
fi

if [ -d "/tmp" ]; then
    echo "/tmp 目录存在"
fi

# 字符串比较
name="admin"
if [ "$name" = "admin" ]; then
    echo "用户是管理员"
fi

# 数值比较
count=10
if [ $count -gt 5 ]; then
    echo "count大于5"
fi

# 逻辑运算
if [ $count -gt 5 ] && [ "$name" = "admin" ]; then
    echo "条件都满足"
fi

# case语句
fruit="apple"
case $fruit in
    "apple")
        echo "这是一个苹果"
        ;;
    "banana"|"orange")
        echo "这是一个香蕉或橙子"
        ;;
    *)
        echo "未知水果"
        ;;
esac
```

#### 2.1.4 循环结构

Shell脚本中的循环结构：

```bash
#!/bin/bash

# for循环
echo "for循环示例:"
for i in 1 2 3 4 5; do
    echo "数字: $i"
done

# 使用序列
for i in $(seq 1 5); do
    echo "序列数字: $i"
done

# 遍历文件
for file in /etc/*.conf; do
    echo "配置文件: $file"
done

# while循环
echo "while循环示例:"
count=1
while [ $count -le 5 ]; do
    echo "计数: $count"
    count=$((count + 1))
done

# until循环
echo "until循环示例:"
count=1
until [ $count -gt 5 ]; do
    echo "until计数: $count"
    count=$((count + 1))
done

# break和continue
for i in $(seq 1 10); do
    if [ $i -eq 3 ]; then
        continue  # 跳过当前迭代
    fi
    if [ $i -eq 8 ]; then
        break  # 终止循环
    fi
    echo "数字(带break/continue): $i"
done
```

#### 2.1.5 函数定义和使用

Shell脚本中的函数定义和使用：

```bash
#!/bin/bash

# 函数定义
function say_hello() {
    echo "Hello, $1!"
}

# 另一种函数定义方式
check_file() {
    if [ -f "$1" ]; then
        echo "文件 $1 存在"
        return 0
    else
        echo "文件 $1 不存在"
        return 1
    fi
}

# 函数调用
say_hello "World"

# 带返回值的函数调用
check_file "/etc/passwd"
if [ $? -eq 0 ]; then
    echo "检查成功"
fi

# 函数输出捕获
result=$(check_file "/etc/nonexistent")
echo "检查结果: $result"
```

### 2.2 Shell脚本常用操作

#### 2.2.1 文件操作

Shell脚本中常见的文件操作：

```bash
#!/bin/bash

# 创建目录
mkdir -p /tmp/test/subdir

# 复制文件
cp /etc/passwd /tmp/test/

# 移动/重命名文件
mv /tmp/test/passwd /tmp/test/passwd.bak

# 删除文件
rm -f /tmp/test/passwd.bak

# 查找文件
find /etc -name "*.conf" -type f

# 文件权限修改
chmod 755 /tmp/test/script.sh
chown user:group /tmp/test/script.sh

# 读取文件内容
cat /etc/hostname

# 按行读取文件
while read line; do
    echo "行内容: $line"
done < /etc/hosts

# 写入文件
echo "新内容" > /tmp/test/newfile.txt
echo "追加内容" >> /tmp/test/newfile.txt
```

#### 2.2.2 文本处理

Shell脚本中常用的文本处理工具：

```bash
#!/bin/bash

# grep - 文本搜索
grep "root" /etc/passwd
grep -i "error" /var/log/syslog  # 忽略大小写

# sed - 流编辑器
sed 's/old/new/g' file.txt  # 替换文本
sed -i '1d' file.txt  # 删除第一行

# awk - 文本分析
awk -F: '{print $1}' /etc/passwd  # 打印第一列
awk '{sum+=$1} END {print sum}' numbers.txt  # 计算总和

# cut - 提取列
cut -d: -f1 /etc/passwd  # 提取用户名

# sort - 排序
sort -n numbers.txt  # 数字排序
sort -k2 -t: /etc/passwd  # 按第二列排序

# uniq - 去重
sort names.txt | uniq  # 去除重复行
sort names.txt | uniq -c  # 统计出现次数

# wc - 计数
wc -l /etc/passwd  # 计算行数
wc -w file.txt  # 计算单词数
```

#### 2.2.3 系统信息获取

Shell脚本中获取系统信息的常用命令：

```bash
#!/bin/bash

# 系统和内核信息
uname -a
cat /etc/os-release

# CPU信息
cat /proc/cpuinfo
nproc  # CPU核心数

# 内存信息
free -h
cat /proc/meminfo

# 磁盘信息
df -h
du -sh /var

# 网络信息
ifconfig
ip addr show
netstat -tuln
ss -tuln

# 进程信息
ps aux
top -b -n 1

# 用户信息
who
w
last
```

#### 2.2.4 错误处理

Shell脚本中的错误处理机制：

```bash
#!/bin/bash

# 设置错误处理选项
set -e  # 遇到错误立即退出
set -u  # 使用未定义变量时报错
set -o pipefail  # 管道中的错误不会被忽略

# 捕获错误
trap 'echo "发生错误: $?"' ERR

# 自定义错误处理函数
error_handler() {
    echo "错误发生在第 $1 行"
    exit 1
}

# 设置错误处理函数
trap 'error_handler $LINENO' ERR

# 检查命令执行状态
if ! command -v curl &> /dev/null; then
    echo "curl命令不存在"
    exit 1
fi

# 使用 || 运算符处理错误
grep "pattern" file.txt || echo "未找到匹配项"

# 使用临时文件时确保清理
temp_file=$(mktemp)
trap 'rm -f $temp_file' EXIT
```

### 2.3 Shell脚本最佳实践

#### 2.3.1 脚本结构和风格

良好的Shell脚本结构和风格：

```bash
#!/bin/bash
#
# 脚本名称: system_check.sh
# 描述: 系统健康检查脚本
# 作者: Your Name
# 创建日期: 2023-01-01
# 版本: 1.0
#
# 使用方法:
#   ./system_check.sh [选项]
#
# 选项:
#   -v, --verbose    显示详细信息
#   -h, --help       显示帮助信息
#

# 严格模式设置
set -euo pipefail

# 全局变量
VERBOSE=false
LOG_FILE="/var/log/system_check.log"

# 函数定义
usage() {
    echo "使用方法: $0 [选项]"
    echo "选项:"
    echo "  -v, --verbose    显示详细信息"
    echo "  -h, --help       显示帮助信息"
    exit 0
}

log() {
    local message="$1"
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    echo "[$timestamp] $message" >> "$LOG_FILE"
    if $VERBOSE; then
        echo "[$timestamp] $message"
    fi
}

check_disk_space() {
    log "检查磁盘空间..."
    df -h | grep -vE '^Filesystem|tmpfs|cdrom'
}

check_memory() {
    log "检查内存使用情况..."
    free -h
}

check_cpu_load() {
    log "检查CPU负载..."
    uptime
}

main() {
    # 参数解析
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -h|--help)
                usage
                ;;
            *)
                echo "未知选项: $1"
                usage
                ;;
        esac
    done

    # 主要逻辑
    log "开始系统检查..."
    check_disk_space
    check_memory
    check_cpu_load
    log "系统检查完成"
}

# 脚本入口
main "$@"
```

#### 2.3.2 安全性考虑

Shell脚本编写中的安全性考虑：

```bash
#!/bin/bash

# 安全处理用户输入
user_input="$1"
# 避免直接使用用户输入执行命令
# 错误示例: eval "ls $user_input"
# 正确处理:
if [ -d "$user_input" ]; then
    ls -la "$user_input"
fi

# 安全处理文件名
filename="$2"
# 使用引号避免空格和特殊字符问题
touch "$filename"

# 安全处理密码
read -s -p "输入密码: " password
echo  # 换行
# 不要在命令行中直接使用密码
# 错误示例: echo $password
# 可以使用环境变量或配置文件

# 安全处理临时文件
temp_file=$(mktemp)
# 确保脚本结束时删除临时文件
trap 'rm -f "$temp_file"' EXIT

# 限制文件权限
umask 077  # 创建的文件默认只有所有者可读写
touch sensitive_data.txt

# 避免使用危险命令
# 错误示例: rm -rf $dir/
# 正确示例:
dir="/path/to/dir"
if [ -d "$dir" ] && [ "$dir" != "/" ]; then
    rm -rf "$dir/"
fi

# 使用受限环境
# 可以考虑使用 chroot 或容器
```

#### 2.3.3 性能优化

Shell脚本性能优化技巧：

```bash
#!/bin/bash

# 减少外部命令调用
# 低效方式
for i in {1..1000}; do
    date >> dates.txt
done

# 优化方式
{
    for i in {1..1000}; do
        date
    done
} > dates.txt

# 使用内置命令替代外部命令
# 低效: grep "pattern" file
# 优化: 使用bash内置功能
while read -r line; do
    [[ $line == *pattern* ]] && echo "$line"
done < file

# 避免不必要的管道
# 低效: cat file | grep pattern
# 优化: grep pattern file

# 批量处理而非逐行处理
# 低效:
for file in *.txt; do
    scp "$file" server:/destination/
done

# 优化:
tar czf - *.txt | ssh server "cd /destination && tar xzf -"

# 并行处理（适用于独立任务）
for server in server1 server2 server3; do
    ssh "$server" "uptime" &
done
wait  # 等待所有后台任务完成

# 使用更高效的工具
# 例如，对于大文件处理，考虑使用awk而非多个sed/grep组合
```

#### 2.3.4 可维护性提升

提高Shell脚本可维护性的实践：

```bash
#!/bin/bash

# 使用有意义的变量名
# 不好: t=60
# 好:
timeout_seconds=60

# 添加注释说明复杂逻辑
# 这个函数计算给定目录的总大小，并根据阈值返回不同状态码
calculate_directory_size() {
    local dir="$1"
    local threshold="$2"
    
    # 计算目录大小（以KB为单位）
    local size=$(du -sk "$dir" | cut -f1)
    
    # 根据阈值返回状态
    if [ "$size" -gt "$threshold" ]; then
        return 1  # 超过阈值
    else
        return 0  # 在阈值内
    fi
}

# 模块化设计
# 将相关功能分组到单独的函数或脚本中
source ./lib/common_functions.sh  # 导入共享函数

# 使用配置文件而非硬编码值
config_file="/etc/myapp/config.conf"
if [ -f "$config_file" ]; then
    source "$config_file"
else
    echo "配置文件不存在: $config_file"
    exit 1
fi

# 版本控制和变更记录
# 在脚本头部添加版本和变更历史
# v1.0 (2023-01-01): 初始版本
# v1.1 (2023-02-01): 添加新功能X

# 一致的缩进和格式
if [ "$condition" = true ]; then
    # 使用4个空格的一致缩进
    echo "条件为真"
else
    echo "条件为假"
fi

# 使用函数返回值表示状态
validate_input() {
    if [ -z "$1" ]; then
        echo "输入不能为空" >&2
        return 1
    fi
    return 0
}

# 调用并检查返回值
if ! validate_input "$user_input"; then
    exit 1
fi
```

## 3. Python脚本基础

Python是当前运维自动化领域最流行的语言之一，具有强大的生态系统和丰富的库。

### 3.1 Python脚本基础语法

#### 3.1.1 脚本文件和执行

创建Python脚本文件通常以`.py`为扩展名，并可以在文件首行指定解释器：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
这是一个简单的Python脚本示例
"""

print("Hello, Python Automation!")

if __name__ == "__main__":
    print("脚本直接执行")
```

执行Python脚本的方法：

```bash
# 方法1：使用python命令
python3 myscript.py

# 方法2：添加执行权限后直接执行
chmod +x myscript.py
./myscript.py
```

#### 3.1.2 变量和数据类型

Python中的变量和基本数据类型：

```python
#!/usr/bin/env python3

# 变量定义和基本数据类型
name = "Python Automation"  # 字符串
count = 10  # 整数
price = 9.99  # 浮点数
is_active = True  # 布尔值

# 打印变量
print(f"Name: {name}")
print(f"Count: {count}")
print(f"Price: {price}")
print(f"Active: {is_active}")

# 列表
servers = ["server1", "server2", "server3"]
print(f"Servers: {servers}")
print(f"First server: {servers[0]}")
servers.append("server4")
print(f"Updated servers: {servers}")

# 元组（不可变列表）
versions = (2, 7, 3, 9)
print(f"Versions: {versions}")
print(f"First version: {versions[0]}")

# 字典
server_info = {
    "hostname": "web-server",
    "ip": "192.168.1.100",
    "os": "Ubuntu",
    "ram_gb": 16
}
print(f"Server info: {server_info}")
print(f"Hostname: {server_info['hostname']}")
server_info["location"] = "Data Center 1"
print(f"Updated server info: {server_info}")

# 集合
unique_users = {"admin", "user1", "user2", "admin"}
print(f"Unique users: {unique_users}")  # 自动去重
```

#### 3.1.3 条件判断

Python中的条件判断结构：

```python
#!/usr/bin/env python3

import sys

# if-elif-else语句
if len(sys.argv) == 1:
    print("请提供至少一个参数")
    sys.exit(1)
elif len(sys.argv) == 2:
    print(f"提供了一个参数: {sys.argv[1]}")
else:
    print(f"提供了多个参数: {sys.argv[1:]}")

# 文件检查
import os
if os.path.isfile("/etc/passwd"):
    print("/etc/passwd 文件存在")

if os.path.isdir("/tmp"):
    print("/tmp 目录存在")

# 字符串比较
name = "admin"
if name == "admin":
    print("用户是管理员")

# 数值比较
count = 10
if count > 5:
    print("count大于5")

# 逻辑运算
if count > 5 and name == "admin":
    print("条件都满足")

# 三元运算符
status = "在线" if is_active else "离线"
print(f"状态: {status}")

# match-case语句 (Python 3.10+)
# fruit = "apple"
# match fruit:
#     case "apple":
#         print("这是一个苹果")
#     case "banana" | "orange":
#         print("这是一个香蕉或橙子")
#     case _:
#         print("未知水果")
```

#### 3.1.4 循环结构

Python中的循环结构：

```python
#!/usr/bin/env python3

import os

# for循环
print("for循环示例:")
for i in range(1, 6):
    print(f"数字: {i}")

# 遍历列表
servers = ["server1", "server2", "server3"]
for server in servers:
    print(f"服务器: {server}")

# 遍历字典
server_info = {"hostname": "web-server", "ip": "192.168.1.100"}
for key, value in server_info.items():
    print(f"{key}: {value}")

# 遍历文件
for filename in os.listdir("/etc"):
    if filename.endswith(".conf"):
        print(f"配置文件: {filename}")

# while循环
print("while循环示例:")
count = 1
while count <= 5:
    print(f"计数: {count}")
    count += 1

# break和continue
for i in range(1, 11):
    if i == 3:
        continue  # 跳过当前迭代
    if i == 8:
        break  # 终止循环
    print(f"数字(带break/continue): {i}")

# 列表推导式
squares = [x**2 for x in range(1, 6)]
print(f"平方数: {squares}")

# 字典推导式
square_dict = {x: x**2 for x in range(1, 6)}
print(f"平方字典: {square_dict}")
```

#### 3.1.5 函数定义和使用

Python中的函数定义和使用：

```python
#!/usr/bin/env python3

# 基本函数定义
def say_hello(name):
    """打印问候语"""
    return f"Hello, {name}!"

# 函数调用
message = say_hello("World")
print(message)

# 默认参数
def create_user(username, role="user", active=True):
    """创建用户"""
    return {
        "username": username,
        "role": role,
        "active": active
    }

# 使用默认参数
user1 = create_user("john")
print(f"User1: {user1}")

# 覆盖默认参数
user2 = create_user("admin", role="administrator", active=False)
print(f"User2: {user2}")

# 关键字参数
user3 = create_user(role="guest", username="visitor")
print(f"User3: {user3}")

# 可变参数
def sum_all(*numbers):
    """计算所有数字的和"""
    return sum(numbers)

total = sum_all(1, 2, 3, 4, 5)
print(f"总和: {total}")

# 关键字可
让我继续完成自动化脚本开发基础的内容：

#### 3.1.5 函数定义和使用（续）

```python
# 关键字可变参数
def create_server(**properties):
    """创建服务器配置"""
    print(f"创建服务器，属性: {properties}")
    return properties

server = create_server(hostname="web01", ip="192.168.1.10", os="Ubuntu", ram_gb=16)
print(f"服务器配置: {server}")

# 函数注解（类型提示）
def calculate_disk_usage(path: str, unit: str = "MB") -> float:
    """
    计算指定路径的磁盘使用量
    
    Args:
        path: 要计算的路径
        unit: 单位(KB, MB, GB)
        
    Returns:
        磁盘使用量（浮点数）
    """
    import os
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            if os.path.exists(fp):
                total_size += os.path.getsize(fp)
    
    # 转换单位
    if unit == "KB":
        return total_size / 1024
    elif unit == "MB":
        return total_size / (1024 * 1024)
    elif unit == "GB":
        return total_size / (1024 * 1024 * 1024)
    else:
        return total_size

# 使用带类型注解的函数
size = calculate_disk_usage("/tmp", unit="MB")
print(f"/tmp目录大小: {size:.2f} MB")
```

### 3.2 Python常用模块

Python标准库和第三方库为自动化脚本提供了强大的功能支持。

#### 3.2.1 文件和目录操作

使用Python进行文件和目录操作：

```python
#!/usr/bin/env python3

import os
import shutil
import glob
import tempfile

# 目录操作
print(f"当前工作目录: {os.getcwd()}")
os.makedirs("/tmp/python_test/subdir", exist_ok=True)
print(f"目录内容: {os.listdir('/tmp')}")

# 路径操作
file_path = "/tmp/python_test/test.txt"
print(f"目录名: {os.path.dirname(file_path)}")
print(f"文件名: {os.path.basename(file_path)}")
print(f"绝对路径: {os.path.abspath('test.txt')}")
print(f"规范化路径: {os.path.normpath('/tmp/../etc')}")

# 文件操作
# 写入文件
with open("/tmp/python_test/test.txt", "w") as f:
    f.write("Hello, Python Automation!\n")
    f.write("This is a test file.\n")

# 读取文件
with open("/tmp/python_test/test.txt", "r") as f:
    content = f.read()
    print(f"文件内容:\n{content}")

# 按行读取
with open("/tmp/python_test/test.txt", "r") as f:
    for line in f:
        print(f"行: {line.strip()}")

# 文件复制、移动和删除
shutil.copy("/tmp/python_test/test.txt", "/tmp/python_test/test_copy.txt")
shutil.move("/tmp/python_test/test_copy.txt", "/tmp/python_test/test_moved.txt")
os.remove("/tmp/python_test/test_moved.txt")

# 使用glob查找文件
conf_files = glob.glob("/etc/*.conf")
print(f"找到 {len(conf_files)} 个配置文件")
for conf in conf_files[:3]:  # 只显示前3个
    print(f"  - {conf}")

# 使用临时文件
with tempfile.NamedTemporaryFile(suffix=".txt") as temp:
    temp.write(b"Temporary content\n")
    temp.flush()
    print(f"临时文件: {temp.name}")
    # 文件会在with块结束时自动删除

# 文件权限
os.chmod("/tmp/python_test/test.txt", 0o755)  # rwxr-xr-x
file_stat = os.stat("/tmp/python_test/test.txt")
print(f"文件权限: {oct(file_stat.st_mode)}")
```

#### 3.2.2 系统和进程管理

使用Python进行系统和进程管理：

```python
#!/usr/bin/env python3

import os
import sys
import platform
import psutil  # 需要安装: pip install psutil
import subprocess
import time

# 系统信息
print(f"操作系统: {platform.system()}")
print(f"操作系统版本: {platform.version()}")
print(f"Python版本: {sys.version}")
print(f"主机名: {platform.node()}")

# CPU信息
print(f"CPU核心数: {os.cpu_count()}")
print(f"CPU使用率: {psutil.cpu_percent(interval=1)}%")

# 内存信息
memory = psutil.virtual_memory()
print(f"总内存: {memory.total / (1024*1024*1024):.2f} GB")
print(f"可用内存: {memory.available / (1024*1024*1024):.2f} GB")
print(f"内存使用率: {memory.percent}%")

# 磁盘信息
disk = psutil.disk_usage('/')
print(f"磁盘总空间: {disk.total / (1024*1024*1024):.2f} GB")
print(f"磁盘可用空间: {disk.free / (1024*1024*1024):.2f} GB")
print(f"磁盘使用率: {disk.percent}%")

# 网络信息
net_io = psutil.net_io_counters()
print(f"网络发送: {net_io.bytes_sent / (1024*1024):.2f} MB")
print(f"网络接收: {net_io.bytes_recv / (1024*1024):.2f} MB")

# 进程管理
# 列出所有进程
print("\n当前运行的进程:")
for proc in psutil.process_iter(['pid', 'name', 'username']):
    try:
        print(f"PID: {proc.info['pid']}, 名称: {proc.info['name']}, 用户: {proc.info['username']}")
    except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):
        pass
    # 只显示前5个进程
    if proc.info['pid'] > 5:
        print("...")
        break

# 执行外部命令
print("\n执行外部命令:")
result = subprocess.run(["ls", "-la", "/tmp"], 
                        capture_output=True, 
                        text=True)
print(f"返回码: {result.returncode}")
print(f"输出:\n{result.stdout[:200]}...")  # 只显示前200个字符

# 使用Popen更灵活地控制进程
process = subprocess.Popen(["ping", "-c", "3", "google.com"],
                          stdout=subprocess.PIPE,
                          stderr=subprocess.PIPE,
                          text=True)

# 实时获取输出
while True:
    output = process.stdout.readline()
    if output == '' and process.poll() is not None:
        break
    if output:
        print(output.strip())

# 获取返回码
return_code = process.poll()
print(f"命令返回码: {return_code}")
```

#### 3.2.3 网络操作

使用Python进行网络操作：

```python
#!/usr/bin/env python3

import socket
import requests  # 需要安装: pip install requests
import json
import urllib.request
import ftplib
import paramiko  # 需要安装: pip install paramiko

# 基本网络信息
hostname = socket.gethostname()
ip_address = socket.gethostbyname(hostname)
print(f"主机名: {hostname}")
print(f"IP地址: {ip_address}")

# DNS查询
try:
    ip = socket.gethostbyname("www.google.com")
    print(f"www.google.com 的IP地址: {ip}")
except socket.gaierror:
    print("无法解析域名")

# 使用requests库进行HTTP请求
try:
    response = requests.get("https://api.github.com/users/octocat")
    if response.status_code == 200:
        user_data = response.json()
        print(f"GitHub用户: {user_data['login']}")
        print(f"名称: {user_data['name']}")
        print(f"位置: {user_data['location']}")
    else:
        print(f"请求失败，状态码: {response.status_code}")
except requests.exceptions.RequestException as e:
    print(f"请求错误: {e}")

# 发送POST请求
try:
    data = {"name": "test", "value": 123}
    headers = {"Content-Type": "application/json"}
    response = requests.post("https://httpbin.org/post", 
                            data=json.dumps(data), 
                            headers=headers)
    if response.status_code == 200:
        print(f"POST响应: {response.json()}")
    else:
        print(f"POST请求失败，状态码: {response.status_code}")
except requests.exceptions.RequestException as e:
    print(f"POST请求错误: {e}")

# 下载文件
try:
    urllib.request.urlretrieve("https://www.python.org/static/img/python-logo.png", 
                              "/tmp/python-logo.png")
    print("文件下载成功")
except Exception as e:
    print(f"下载错误: {e}")

# FTP操作
def ftp_example():
    try:
        # 连接到FTP服务器
        ftp = ftplib.FTP("ftp.example.com")
        ftp.login("username", "password")
        
        # 列出目录内容
        files = ftp.nlst()
        print(f"FTP目录内容: {files}")
        
        # 上传文件
        with open("/tmp/test.txt", "rb") as file:
            ftp.storbinary("STOR test.txt", file)
        
        # 下载文件
        with open("/tmp/download.txt", "wb") as file:
            ftp.retrbinary("RETR test.txt", file.write)
        
        ftp.quit()
    except Exception as e:
        print(f"FTP错误: {e}")

# SSH操作
def ssh_example():
    try:
        # 创建SSH客户端
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
        # 连接到SSH服务器
        client.connect("example.com", username="user", password="password")
        
        # 执行命令
        stdin, stdout, stderr = client.exec_command("ls -la")
        output = stdout.read().decode()
        print(f"SSH命令输出:\n{output}")
        
        # 关闭连接
        client.close()
    except Exception as e:
        print(f"SSH错误: {e}")

# 注意：这些示例需要有效的服务器和凭据才能运行
print("FTP和SSH示例需要有效的服务器和凭据才能运行")
# ftp_example()
# ssh_example()
```

#### 3.2.4 数据处理

使用Python进行数据处理：

```python
#!/usr/bin/env python3

import csv
import json
import xml.etree.ElementTree as ET
import yaml  # 需要安装: pip install pyyaml
import sqlite3
import pandas as pd  # 需要安装: pip install pandas

# CSV文件处理
# 写入CSV
with open("/tmp/servers.csv", "w", newline="") as csvfile:
    writer = csv.writer(csvfile)
    writer.writerow(["Hostname", "IP", "OS", "RAM(GB)"])
    writer.writerow(["web01", "192.168.1.101", "Ubuntu", 16])
    writer.writerow(["web02", "192.168.1.102", "CentOS", 32])
    writer.writerow(["db01", "192.168.1.201", "RHEL", 64])

# 读取CSV
print("CSV数据:")
with open("/tmp/servers.csv", "r") as csvfile:
    reader = csv.reader(csvfile)
    for row in reader:
        print(f"  {row}")

# 使用DictReader/DictWriter
with open("/tmp/servers_dict.csv", "w", newline="") as csvfile:
    fieldnames = ["hostname", "ip", "os", "ram"]
    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
    writer.writeheader()
    writer.writerow({"hostname": "web01", "ip": "192.168.1.101", "os": "Ubuntu", "ram": 16})
    writer.writerow({"hostname": "web02", "ip": "192.168.1.102", "os": "CentOS", "ram": 32})

with open("/tmp/servers_dict.csv", "r") as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        print(f"  {row['hostname']}: {row['ip']} ({row['os']})")

# JSON处理
# 创建JSON数据
servers = [
    {"hostname": "web01", "ip": "192.168.1.101", "os": "Ubuntu", "ram": 16},
    {"hostname": "web02", "ip": "192.168.1.102", "os": "CentOS", "ram": 32},
    {"hostname": "db01", "ip": "192.168.1.201", "os": "RHEL", "ram": 64}
]

# 写入JSON文件
with open("/tmp/servers.json", "w") as jsonfile:
    json.dump(servers, jsonfile, indent=4)

# 读取JSON文件
with open("/tmp/servers.json", "r") as jsonfile:
    loaded_servers = json.load(jsonfile)
    print("\nJSON数据:")
    for server in loaded_servers:
        print(f"  {server['hostname']}: {server['ip']} ({server['os']})")

# XML处理
# 创建XML
root = ET.Element("servers")
for server_data in servers:
    server = ET.SubElement(root, "server")
    for key, value in server_data.items():
        ET.SubElement(server, key).text = str(value)

# 写入XML文件
tree = ET.ElementTree(root)
tree.write("/tmp/servers.xml")

# 读取XML文件
tree = ET.parse("/tmp/servers.xml")
root = tree.getroot()
print("\nXML数据:")
for server in root.findall("server"):
    hostname = server.find("hostname").text
    ip = server.find("ip").text
    os_type = server.find("os").text
    print(f"  {hostname}: {ip} ({os_type})")

# YAML处理
# 写入YAML文件
with open("/tmp/servers.yaml", "w") as yamlfile:
    yaml.dump(servers, yamlfile, default_flow_style=False)

# 读取YAML文件
with open("/tmp/servers.yaml", "r") as yamlfile:
    yaml_servers = yaml.safe_load(yamlfile)
    print("\nYAML数据:")
    for server in yaml_servers:
        print(f"  {server['hostname']}: {server['ip']} ({server['os']})")

# SQLite数据库操作
conn = sqlite3.connect("/tmp/servers.db")
cursor = conn.cursor()

# 创建表
cursor.execute('''
CREATE TABLE IF NOT EXISTS servers (
    id INTEGER PRIMARY KEY,
    hostname TEXT,
    ip TEXT,
    os TEXT,
    ram INTEGER
)
''')

# 插入数据
for server in servers:
    cursor.execute('''
    INSERT INTO servers (hostname, ip, os, ram)
    VALUES (?, ?, ?, ?)
    ''', (server['hostname'], server['ip'], server['os'], server['ram']))

conn.commit()

# 查询数据
cursor.execute("SELECT * FROM servers")
rows = cursor.fetchall()
print("\nSQLite数据:")
for row in rows:
    print(f"  ID: {row[0]}, 主机名: {row[1]}, IP: {row[2]}, OS: {row[3]}, RAM: {row[4]}GB")

conn.close()

# 使用pandas进行数据分析
df = pd.DataFrame(servers)
print("\nPandas DataFrame:")
print(df)

# 基本统计
print("\n基本统计:")
print(df.describe())

# 分组统计
print("\n按操作系统分组:")
print(df.groupby('os').mean())

# 导出到不同格式
df.to_csv("/tmp/servers_pandas.csv", index=False)
df.to_excel("/tmp/servers.xlsx", index=False)  # 需要安装: pip install openpyxl
```

### 3.3 Python脚本最佳实践

#### 3.3.1 脚本结构和风格

良好的Python脚本结构和风格：

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
脚本名称: system_monitor.py
描述: 系统资源监控脚本
作者: Your Name
创建日期: 2023-01-01
版本: 1.0

使用方法:
    python system_monitor.py [选项]

选项:
    -v, --verbose    显示详细信息
    -h, --help       显示帮助信息
"""

# 导入标准库
import os
import sys
import time
import argparse
import logging
from datetime import datetime

# 导入第三方库
try:
    import psutil
except ImportError:
    print("请安装psutil库: pip install psutil")
    sys.exit(1)

# 常量定义
DEFAULT_INTERVAL = 5  # 默认监控间隔（秒）
LOG_FORMAT = "%(asctime)s - %(levelname)s - %(message)s"
VERSION = "1.0"

# 全局变量
verbose = False

# 函数定义
def setup_logging(verbose=False):
    """设置日志记录"""
    level = logging.DEBUG if verbose else logging.INFO
    logging.basicConfig(
        level=level,
        format=LOG_FORMAT,
        handlers=[
            logging.FileHandler("/tmp/system_monitor.log"),
            logging.StreamHandler()
        ]
    )
    return logging.getLogger(__name__)

def get_system_info():
    """获取系统信息"""
    info = {
        "cpu_percent": psutil.cpu_percent(interval=1),
        "memory_percent": psutil.virtual_memory().percent,
        "disk_percent": psutil.disk_usage('/').percent,
        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    }
    return info

def monitor_system(interval, logger):
    """监控系统资源"""
    logger.info(f"开始监控系统资源，间隔: {interval}秒")
    try:
        while True:
            info = get_system_info()
            logger.info(
                f"CPU: {info['cpu_percent']}%, "
                f"内存: {info['memory_percent']}%, "
                f"磁盘: {info['disk_percent']}%"
            )
            time.sleep(interval)
    except KeyboardInterrupt:
        logger.info("监控已停止")

def parse_arguments():
    """解析命令行参数"""
    parser = argparse.ArgumentParser(
        description="系统资源监控脚本",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument(
        "-i", "--interval",
        type=int,
        default=DEFAULT_INTERVAL,
        help="监控间隔（秒）"
    )
    parser.add_argument(
        "-v", "--verbose",
        action="store_true",
        help="显示详细信息"
    )
    parser.add_argument(
        "--version",
        action="version",
        version=f"%(prog)s {VERSION}"
    )
    return parser.parse_args()

def main():
    """主函数"""
    # 解析命令行参数
    args = parse_arguments()
    
    # 设置日志
    logger = setup_logging(args.verbose)
    logger.debug("调试模式已启用")
    
    # 监控系统
    monitor_system(args.interval, logger)

# 脚本入口
if __name__ == "__main__":
    main()
```

#### 3.3.2 错误处理和日志记录

Python脚本中的错误处理和日志记录：

```python
#!/usr/bin/env python3

import os
import sys
import logging
import traceback
from logging.handlers import RotatingFileHandler

# 配置日志记录
def setup_logging(log_file="/tmp/script.log", level=logging.INFO):
    """设置日志记录器"""
    # 创建日志目录
    log_dir = os.path.dirname(log_file)
    if log_dir and not os.path.exists(log_dir):
        os.makedirs(log_dir)
    
    # 创建日志记录器
    logger = logging.getLogger()
    logger.setLevel(level)
    
    # 创建控制台处理器
    console_handler = logging.StreamHandler()
    console_handler.setLevel(level)
    console_format = logging.Formatter('%(levelname)s: %(message)s')
    console_handler.setFormatter(console_format)
    
    # 创建文件处理器（滚动日志）
    file_handler = RotatingFileHandler(
        log_file, maxBytes=10*1024*1024, backupCount=5
    )
    file_handler.setLevel(level)
    file_format = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    file_handler.setFormatter(file_format)
    
    # 添加处理器到记录器
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    
    return logger

# 异常处理示例
def process_file(filename):
    """处理文件的示例函数"""
    logger = logging.getLogger(__name__)
    
    try:
        logger.info(f"开始处理文件: {filename}")
        
        # 检查文件是否存在
        if not os.path.exists(filename):
            raise FileNotFoundError(f"文件不存在: {filename}")
        
        # 检查文件权限
        if not os.access(filename, os.R_OK):
            raise PermissionError(f"没有读取权限: {filename}")
        
        # 读取文件内容
        with open(filename, 'r') as f:
            content = f.read()
            logger.debug(f"文件内容长度: {len(content)} 字节")
        
        # 处理文件内容
        result = len(content.split())
        logger.info(f"文件处理完成，单词数: {result}")
        return result
    
    except FileNotFoundError as e:
        logger.error(f"文件错误: {e}")
        return None
    
    except PermissionError as e:
        logger.error(f"权限错误: {e}")
        return None
    
    except Exception as e:
        # 记录未预期的异常和堆栈跟踪
        logger.error(f"处理文件时发生错误: {e}")
        logger.debug(f"异常详情: {traceback.format_exc()}")
        return None

# 自定义异常类
class ConfigError(Exception):
    """配置错误异常"""
    pass

def load_config(config_file):
    """加载配置文件"""
    logger = logging.getLogger(__name__)
    
    try:
        logger.info(f"加载配置文件: {config_file}")
        
        if not os.path.exists(config_file):
            raise ConfigError(f"配置文件不存在: {config_file}")
        
        # 这里简化了配置加载过程
        with open(config_file, 'r') as f:
            config = {}
            for line in f:
                line = line.strip()
                if line and not line.startswith('#'):
                    key, value = line.split('=', 1)
                    config[key.strip()] = value.strip()
        
        # 验证必要的配置项
        required_keys = ['host', 'port', 'username']
        missing_keys = [key for key in required_keys if key not in config]
        
        if missing_keys:
            raise ConfigError(f"配置缺少必要项: {', '.join(missing_keys)}")
        
        logger.info("配置加载成功")
        return config
    
    except ConfigError as e:
        logger.error(f"配置错误: {e}")
        return None
    
    except Exception as e:
        logger.error(f"加载配置时发生错误: {e}")
        logger.debug(f"异常详情: {traceback.format_exc()}")
        return None

# 上下文管理器示例
class TempFileManager:
    """临时文件管理器"""
    def __init__(self, filename):
        self.filename = filename
        self.logger = logging.getLogger(__name__)
    
    def __enter__(self):
        self.logger.debug(f"创建临时文件: {self.filename}")
        self.file = open(self.filename, 'w')
        return self.file
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        self.file.close()
        self.logger.debug(f"关闭临时文件: {self.filename}")
        
        # 如果发生异常，记录异常信息
        if exc_type is not None:
            self.logger.error(f"处理临时文件时发生错误: {exc_val}")
            return False  # 不抑制异常
        
        # 清理临时文件
        try:
            os.remove(self.filename)
            self.logger.debug(f"删除临时文件: {self.filename}")
        except OSError as e:
            self.logger.warning(f"无法删除临时文件: {e}")

# 主函数
def main():
    # 设置日志
    logger = setup_logging(level=logging.DEBUG)
    logger.info("脚本开始执行")
    
    try:
        # 使用上下文管理器
        with TempFileManager("/tmp/temp_config.txt") as f:
            f.write("host=localhost\nport=8080\nusername=admin\n")
        
        # 加载配置
        config = load_config("/tmp/temp_config.txt")
        if not config:
            logger.error("无法加载配置，脚本终止")
            sys.exit(1)
        
        # 处理文件
        result = process_file("/etc/hosts")
        if result is None:
            logger.warning("文件处理失败")
        else:
            logger.info(f"处理结果: {result}")
        
        logger.info("脚本执行完成")
    
    except Exception as e:
        logger.critical(f"脚本执行过程中发生未处理的异常: {e}")
        logger.debug(f"异常详情: {traceback.format_exc()}")
        sys.exit(1)

if __name__ == "__main__":
    main()
```

#### 3.3.3 测试和调试

Python脚本的测试和调试技巧：

```python
#!/usr/bin/env python3

import unittest
import logging
import tempfile
import os
import pdb  # Python调试器

# 要测试的函数
def calculate_disk_usage(path):
    """计算目录的磁盘使用量（MB）"""
    if not os.path.exists(path):
        raise ValueError(f"路径不存在: {path}")
    
    if not os.path.isdir(path):
        raise ValueError(f"路径不是目录: {path}")
    
    total_size = 0
    for dirpath, dirnames, filenames in os.walk(path):
        for f in filenames:
            fp = os.path.join(dirpath, f)
            if os.path.exists(fp):
                total_size += os.path.getsize(fp)
    
    # 转换为MB
    return total_size / (1024 * 1024)

# 单元测试
class TestDiskUsage(unittest.TestCase):
    """测试磁盘使用量计算函数"""
    
    def setUp(self):
        """测试前准备"""
        # 创建临时目录
        self.temp_dir = tempfile.mkdtemp()
        
        # 创建测试文件
        self.test_files = []
        for i in range(5):
            file_path = os.path.join(self.temp_dir, f"test_file_{i}.txt")
            with open(file_path, 'wb') as f:
                # 每个文件写入1MB数据
                f.write(b'0' * 1024 * 1024)
            self.test_files.append(file_path)
        
        # 创建子目录和文件
        self.sub_dir = os.path.join(self.temp_dir, "subdir")
        os.mkdir(self.sub_dir)
        self.sub_file = os.path.join(self.sub_dir, "sub_file.txt")
        with open(self.sub_file, 'wb') as f:
            # 子目录文件写入2MB数据
            f.write(b'0' * 2 * 1024 * 1024)
    
让我继续完成自动化脚本开发基础的内容：

#### 3.3.3 测试和调试（续）

```python
    def tearDown(self):
        """测试后清理"""
        # 删除测试文件
        for file_path in self.test_files:
            os.remove(file_path)
        
        # 删除子目录文件和子目录
        os.remove(self.sub_file)
        os.rmdir(self.sub_dir)
        
        # 删除临时目录
        os.rmdir(self.temp_dir)
    
    def test_calculate_disk_usage(self):
        """测试正常情况下的磁盘使用计算"""
        usage = calculate_disk_usage(self.temp_dir)
        # 预期使用量：5个1MB文件 + 1个2MB文件 = 7MB
        expected = 7.0
        # 允许0.1MB的误差
        self.assertAlmostEqual(usage, expected, delta=0.1)
    
    def test_nonexistent_path(self):
        """测试不存在的路径"""
        with self.assertRaises(ValueError):
            calculate_disk_usage("/path/does/not/exist")
    
    def test_file_path(self):
        """测试文件路径而非目录"""
        with self.assertRaises(ValueError):
            calculate_disk_usage(self.test_files[0])

# 调试示例
def debug_example():
    """调试示例函数"""
    print("开始调试示例...")
    
    # 创建一些测试数据
    data = [1, 2, 3, 4, 5]
    result = 0
    
    # 设置断点
    # pdb.set_trace()  # 取消注释以启用调试器
    
    # 一些可能有问题的代码
    for i in range(len(data)):
        print(f"处理项目 {i}: {data[i]}")
        result += data[i]
        # 故意引入的错误，用于演示调试
        if i == 3:
            # 这里有一个逻辑错误
            result += 1  # 应该是 result += data[i]
    
    print(f"最终结果: {result}")
    return result

# 使用断言进行简单测试
def assert_example():
    """使用断言进行简单测试"""
    print("开始断言示例...")
    
    # 一些需要验证的条件
    value = 5
    assert value > 0, "值必须大于0"
    
    # 验证函数结果
    result = debug_example()
    expected = 15  # 1+2+3+4+5
    assert result == expected, f"结果应为{expected}，实际为{result}"
    
    print("所有断言通过")

# 使用日志进行调试
def logging_debug_example():
    """使用日志进行调试"""
    # 配置日志
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(levelname)s - %(message)s'
    )
    logger = logging.getLogger(__name__)
    
    logger.debug("开始日志调试示例...")
    
    # 一些需要调试的代码
    data = {"name": "test", "values": [1, 2, 3]}
    logger.debug(f"数据: {data}")
    
    try:
        # 尝试一些可能出错的操作
        result = sum(data["values"])
        logger.info(f"计算结果: {result}")
        
        # 故意引入错误
        missing_value = data.get("missing_key", None)
        logger.debug(f"缺失值: {missing_value}")
        
        if missing_value is None:
            logger.warning("缺失键'missing_key'")
    
    except Exception as e:
        logger.error(f"发生错误: {e}")
        logger.exception("详细错误信息")
    
    logger.debug("日志调试示例结束")

# 运行测试和调试示例
if __name__ == "__main__":
    # 运行单元测试
    unittest.main(argv=['first-arg-is-ignored'], exit=False)
    
    # 运行调试示例
    # debug_example()
    
    # 运行断言示例
    # assert_example()
    
    # 运行日志调试示例
    # logging_debug_example()
```

#### 3.3.4 性能优化

Python脚本性能优化技巧：

```python
#!/usr/bin/env python3

import time
import cProfile
import pstats
import io
import os
import sys
import multiprocessing
import concurrent.futures
import functools

# 性能测量装饰器
def timing_decorator(func):
    """测量函数执行时间的装饰器"""
    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"{func.__name__} 执行时间: {end_time - start_time:.4f} 秒")
        return result
    return wrapper

# 使用cProfile进行性能分析
def profile_function(func, *args, **kwargs):
    """使用cProfile分析函数性能"""
    profiler = cProfile.Profile()
    profiler.enable()
    result = func(*args, **kwargs)
    profiler.disable()
    
    # 打印分析结果
    s = io.StringIO()
    ps = pstats.Stats(profiler, stream=s).sort_stats('cumulative')
    ps.print_stats(10)  # 只显示前10行
    print(s.getvalue())
    
    return result

# 低效的示例函数
@timing_decorator
def inefficient_function(n):
    """低效的函数实现"""
    result = []
    for i in range(n):
        result.append(i)  # 逐个追加元素
        
    # 低效的字符串拼接
    text = ""
    for item in result:
        text += str(item) + ","  # 每次都创建新字符串
    
    # 低效的列表搜索
    count = 0
    for i in range(n):
        if i in result:  # 线性搜索
            count += 1
    
    return len(text), count

# 优化后的函数
@timing_decorator
def efficient_function(n):
    """优化后的函数实现"""
    # 预分配列表或使用列表推导
    result = list(range(n))  # 或 [i for i in range(n)]
    
    # 高效的字符串拼接
    text = ",".join(str(i) for i in result)  # 使用join
    
    # 使用集合进行高效搜索
    result_set = set(result)
    count = sum(1 for i in range(n) if i in result_set)  # 常数时间搜索
    
    return len(text), count

# 内存优化示例
@timing_decorator
def memory_efficient_function(n):
    """内存优化的函数实现"""
    # 使用生成器而非列表
    result_gen = (i for i in range(n))
    
    # 流式处理而非一次性加载
    text_length = 0
    for i in result_gen:
        text_length += len(str(i)) + 1  # +1 for comma
    
    # 避免创建大型中间结果
    count = 0
    for i in range(n):
        if i < n:  # 这里简化了条件，实际中可能是更复杂的逻辑
            count += 1
    
    return text_length, count

# 并行处理示例
def process_chunk(chunk):
    """处理数据块的函数"""
    result = 0
    for i in chunk:
        # 模拟计算密集型任务
        result += sum(j * j for j in range(1000))
    return result

@timing_decorator
def parallel_processing(data, num_processes=None):
    """使用多进程并行处理数据"""
    if num_processes is None:
        num_processes = multiprocessing.cpu_count()
    
    # 将数据分割成多个块
    chunk_size = len(data) // num_processes
    chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]
    
    # 使用进程池并行处理
    with multiprocessing.Pool(processes=num_processes) as pool:
        results = pool.map(process_chunk, chunks)
    
    return sum(results)

@timing_decorator
def sequential_processing(data):
    """顺序处理数据"""
    return process_chunk(data)

# 使用concurrent.futures进行并行处理
@timing_decorator
def concurrent_processing(data, num_workers=None):
    """使用concurrent.futures并行处理数据"""
    if num_workers is None:
        num_workers = multiprocessing.cpu_count()
    
    # 将数据分割成多个块
    chunk_size = len(data) // num_workers
    chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]
    
    # 使用线程池或进程池并行处理
    with concurrent.futures.ProcessPoolExecutor(max_workers=num_workers) as executor:
        futures = [executor.submit(process_chunk, chunk) for chunk in chunks]
        results = [future.result() for future in concurrent.futures.as_completed(futures)]
    
    return sum(results)

# 主函数
def main():
    print("性能优化示例")
    
    # 比较低效和高效函数
    n = 10000
    print(f"\n比较函数效率 (n={n}):")
    inefficient_result = inefficient_function(n)
    efficient_result = efficient_function(n)
    memory_result = memory_efficient_function(n)
    
    print(f"低效函数结果: {inefficient_result}")
    print(f"高效函数结果: {efficient_result}")
    print(f"内存优化函数结果: {memory_result}")
    
    # 使用cProfile分析
    print("\ncProfile分析:")
    profile_function(inefficient_function, 1000)
    
    # 并行处理示例
    print("\n并行处理示例:")
    data = list(range(1000))
    
    sequential_result = sequential_processing(data)
    parallel_result = parallel_processing(data)
    concurrent_result = concurrent_processing(data)
    
    print(f"顺序处理结果: {sequential_result}")
    print(f"多进程处理结果: {parallel_result}")
    print(f"concurrent.futures处理结果: {concurrent_result}")

if __name__ == "__main__":
    main()
```

## 4. PowerShell脚本基础

PowerShell是Microsoft开发的任务自动化和配置管理框架，特别适合Windows环境。

### 4.1 PowerShell基础语法

#### 4.1.1 脚本文件和执行

创建PowerShell脚本文件通常以`.ps1`为扩展名：

```powershell
# 这是一个简单的PowerShell脚本示例
Write-Host "Hello, PowerShell Automation!"
```

执行PowerShell脚本的方法：

```powershell
# 方法1：使用PowerShell命令行
powershell -File myscript.ps1

# 方法2：在PowerShell控制台中执行
.\myscript.ps1

# 方法3：使用绝对路径
& "C:\Scripts\myscript.ps1"

# 注意：可能需要设置执行策略
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser
```

#### 4.1.2 变量和数据类型

PowerShell中的变量和基本数据类型：

```powershell
# 变量定义（使用$符号）
$name = "PowerShell Automation"
$count = 10
$isActive = $true
$currentDate = Get-Date

# 显示变量
Write-Host "Name: $name"
Write-Host "Count: $count"
Write-Host "Active: $isActive"
Write-Host "Current Date: $currentDate"

# 数组
$servers = @("server1", "server2", "server3")
Write-Host "Servers: $servers"
Write-Host "First server: $servers[0]"
$servers += "server4"
Write-Host "Updated servers: $servers"

# 哈希表（类似字典）
$serverInfo = @{
    Hostname = "web-server"
    IP = "192.168.1.100"
    OS = "Windows Server 2019"
    RAM_GB = 16
}
Write-Host "Server info: $serverInfo"
Write-Host "Hostname: $($serverInfo.Hostname)"
$serverInfo["Location"] = "Data Center 1"
Write-Host "Updated server info: $serverInfo"

# 类型转换
$numberString = "42"
$number = [int]$numberString
Write-Host "Number: $number"

# 强类型变量
[string]$typedName = "PowerShell"
[int]$typedCount = 10
Write-Host "Typed variables: $typedName, $typedCount"
```

#### 4.1.3 条件判断

PowerShell中的条件判断结构：

```powershell
# if-elseif-else语句
$count = 10

if ($count -eq 0) {
    Write-Host "Count is zero"
} elseif ($count -lt 5) {
    Write-Host "Count is less than 5"
} elseif ($count -gt 5 -and $count -lt 15) {
    Write-Host "Count is between 5 and 15"
} else {
    Write-Host "Count is 15 or greater"
}

# 文件检查
if (Test-Path "C:\Windows\System32\notepad.exe") {
    Write-Host "Notepad exists"
}

if (Test-Path "C:\Temp" -PathType Container) {
    Write-Host "Temp directory exists"
}

# 字符串比较
$name = "admin"
if ($name -eq "admin") {
    Write-Host "User is an administrator"
}

# 不区分大小写比较（PowerShell默认不区分大小写）
if ($name -eq "ADMIN") {
    Write-Host "Case-insensitive match"
}

# 区分大小写比较
if ($name -ceq "admin") {
    Write-Host "Case-sensitive match"
}

# 逻辑运算
if ($count -gt 5 -and $name -eq "admin") {
    Write-Host "Both conditions are true"
}

# switch语句
$fruit = "apple"
switch ($fruit) {
    "apple" { Write-Host "This is an apple" }
    "banana" { Write-Host "This is a banana" }
    "orange" { Write-Host "This is an orange" }
    default { Write-Host "Unknown fruit" }
}

# switch语句支持通配符和正则表达式
$filename = "document.txt"
switch -Wildcard ($filename) {
    "*.txt" { Write-Host "Text file" }
    "*.docx" { Write-Host "Word document" }
    "*.xlsx" { Write-Host "Excel spreadsheet" }
    default { Write-Host "Unknown file type" }
}
```

#### 4.1.4 循环结构

PowerShell中的循环结构：

```powershell
# foreach循环
Write-Host "foreach循环示例:"
$servers = @("server1", "server2", "server3")
foreach ($server in $servers) {
    Write-Host "Server: $server"
}

# for循环
Write-Host "for循环示例:"
for ($i = 1; $i -le 5; $i++) {
    Write-Host "Number: $i"
}

# while循环
Write-Host "while循环示例:"
$count = 1
while ($count -le 5) {
    Write-Host "Count: $count"
    $count++
}

# do-while循环（至少执行一次）
Write-Host "do-while循环示例:"
$count = 1
do {
    Write-Host "Do-While Count: $count"
    $count++
} while ($count -le 5)

# do-until循环（至少执行一次，直到条件为真）
Write-Host "do-until循环示例:"
$count = 1
do {
    Write-Host "Do-Until Count: $count"
    $count++
} until ($count -gt 5)

# break和continue
for ($i = 1; $i -le 10; $i++) {
    if ($i -eq 3) {
        continue  # 跳过当前迭代
    }
    if ($i -eq 8) {
        break  # 终止循环
    }
    Write-Host "Number (with break/continue): $i"
}

# ForEach-Object cmdlet（管道处理）
Write-Host "ForEach-Object示例:"
1..5 | ForEach-Object {
    Write-Host "Pipeline number: $_"
}

# 处理文件
Get-ChildItem "C:\Windows" -Filter "*.exe" -File |
    Select-Object -First 3 |
    ForEach-Object {
        Write-Host "Executable: $($_.Name)"
    }
```

#### 4.1.5 函数定义和使用

PowerShell中的函数定义和使用：

```powershell
# 基本函数定义
function Say-Hello {
    param (
        [string]$Name
    )
    
    Write-Host "Hello, $Name!"
}

# 函数调用
Say-Hello -Name "World"

# 带返回值的函数
function Get-Square {
    param (
        [int]$Number
    )
    
    return $Number * $Number
}

$result = Get-Square -Number 5
Write-Host "Square of 5 is $result"

# 带参数验证的函数
function Test-Path {
    param (
        [Parameter(Mandatory=$true)]
        [string]$Path,
        
        [Parameter()]
        [ValidateSet("File", "Directory")]
        [string]$Type = "File"
    )
    
    if ($Type -eq "File") {
        return [System.IO.File]::Exists($Path)
    } else {
        return [System.IO.Directory]::Exists($Path)
    }
}

$fileExists = Test-Path -Path "C:\Windows\System32\notepad.exe"
Write-Host "Notepad exists: $fileExists"

# 高级函数（支持管道输入）
function Get-FileInfo {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]
        [string]$Path
    )
    
    process {
        if (Test-Path $Path -PathType Leaf) {
            $file = Get-Item $Path
            [PSCustomObject]@{
                Name = $file.Name
                Size = $file.Length
                LastModified = $file.LastWriteTime
            }
        } else {
            Write-Warning "File not found: $Path"
        }
    }
}

# 使用管道调用函数
"C:\Windows\System32\notepad.exe" | Get-FileInfo

# 使用参数集
function Copy-FileWithOptions {
    [CmdletBinding(DefaultParameterSetName="Path")]
    param (
        [Parameter(Mandatory=$true, ParameterSetName="Path")]
        [string]$Path,
        
        [Parameter(Mandatory=$true, ParameterSetName="Paths")]
        [string[]]$Paths,
        
        [Parameter(Mandatory=$true)]
        [string]$Destination,
        
        [switch]$Force
    )
    
    if ($PSCmdlet.ParameterSetName -eq "Path") {
        Write-Host "Copying single file: $Path to $Destination"
        Copy-Item -Path $Path -Destination $Destination -Force:$Force
    } else {
        Write-Host "Copying multiple files to $Destination"
        foreach ($p in $Paths) {
            Write-Host "  Copying: $p"
            Copy-Item -Path $p -Destination $Destination -Force:$Force
        }
    }
}

# 调用带参数集的函数
Copy-FileWithOptions -Path "C:\temp\test.txt" -Destination "C:\temp\backup"
```

### 4.2 PowerShell常用操作

#### 4.2.1 文件和目录操作

使用PowerShell进行文件和目录操作：

```powershell
# 获取当前目录内容
Get-ChildItem

# 创建目录
New-Item -Path "C:\Temp\Test" -ItemType Directory

# 创建文件
New-Item -Path "C:\Temp\Test\test.txt" -ItemType File -Value "Hello, PowerShell!"

# 复制文件
Copy-Item -Path "C:\Temp\Test\test.txt" -Destination "C:\Temp\Test\test_copy.txt"

# 移动文件
Move-Item -Path "C:\Temp\Test\test_copy.txt" -Destination "C:\Temp\Test\test_moved.txt"

# 重命名文件
Rename-Item -Path "C:\Temp\Test\test_moved.txt" -NewName "test_renamed.txt"

# 删除文件
Remove-Item -Path "C:\Temp\Test\test_renamed.txt"

# 读取文件内容
Get-Content -Path "C:\Temp\Test\test.txt"

# 写入文件内容
Set-Content -Path "C:\Temp\Test\test.txt" -Value "New content"
Add-Content -Path "C:\Temp\Test\test.txt" -Value "Appended content"

# 检查路径是否存在
if (Test-Path -Path "C:\Temp\Test") {
    Write-Host "Path exists"
}

# 获取文件属性
$file = Get-Item -Path "C:\Temp\Test\test.txt"
Write-Host "Name: $($file.Name)"
Write-Host "Size: $($file.Length) bytes"
Write-Host "Last Modified: $($file.LastWriteTime)"

# 查找文件
Get-ChildItem -Path "C:\Windows" -Filter "*.exe" -Recurse -File -ErrorAction SilentlyContinue |
    Select-Object -First 5 |
    Format-Table Name, Length, LastWriteTime

# 设置文件权限
$acl = Get-Acl -Path "C:\Temp\Test\test.txt"
$permission = "BUILTIN\Users", "FullControl", "Allow"
$accessRule = New-Object System.Security.AccessControl.FileSystemAccessRule $permission
$acl.SetAccessRule($accessRule)
Set-Acl -Path "C:\Temp\Test\test.txt" -AclObject $acl
```

#### 4.2.2 系统管理

使用PowerShell进行系统管理：

```powershell
# 获取系统信息
Get-ComputerInfo

# 获取操作系统信息
Get-CimInstance -ClassName Win32_OperatingSystem |
    Select-Object Caption, Version, OSArchitecture, LastBootUpTime

# 获取处理器信息
Get-CimInstance -ClassName Win32_Processor |
    Select-Object Name, NumberOfCores, NumberOfLogicalProcessors

# 获取内存信息
Get-CimInstance -ClassName Win32_PhysicalMemory |
    Measure-Object -Property Capacity -Sum |
    ForEach-Object { "Total Memory: {0:N2} GB" -f ($_.Sum / 1GB) }

# 获取磁盘信息
Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DriveType=3" |
    Select-Object DeviceID, @{Name="Size(GB)";Expression={$_.Size/1GB}}, @{Name="FreeSpace(GB)";Expression={$_.FreeSpace/1GB}}

# 获取网络适配器信息
Get-NetAdapter |
    Select-Object Name, InterfaceDescription, Status, LinkSpeed

# 获取IP配置
Get-NetIPConfiguration |
    Select-Object InterfaceAlias, IPv4Address, IPv6Address

# 获取进程信息
Get-Process |
    Sort-Object -Property CPU -Descending |
    Select-Object -First 5 |
    Format-Table Name, Id, CPU, WorkingSet

# 获取服务信息
Get-Service |
    Where-Object {$_.Status -eq "Running"} |
    Select-Object -First 5 |
    Format-Table Name, DisplayName, Status

# 获取事件日志
Get-EventLog -LogName System -Newest 5 |
    Format-Table TimeGenerated, EntryType, Source, Message -AutoSize -Wrap

# 获取已安装的软件
Get-CimInstance -ClassName Win32_Product |
    Select-Object Name, Version, Vendor |
    Sort-Object Name

# 获取启动项
Get-CimInstance -ClassName Win32_StartupCommand |
    Select-Object Name, Command, Location, User

# 获取计划任务
Get-ScheduledTask |
    Where-Object {$_.State -ne "Disabled"} |
    Select-Object -First 5 |
    Format-Table TaskName, State, LastRunTime
```

#### 4.2.3 网络操作

使用PowerShell进行网络操作：

```powershell
# 测试网络连接
Test-Connection -ComputerName "google.com" -Count 4

# 测试端口连接
Test-NetConnection -ComputerName "google.com" -Port 443

# 获取DNS记录
Resolve-DnsName -Name "google.com" -Type A

# 获取网络统计信息
Get-NetTCPConnection |
    Group-Object -Property State, RemotePort |
    Sort-Object -Property Count -Descending |
    Select-Object -First 5 |
    Format-Table Name, Count

# 获取路由表
Get-NetRoute |
    Where-Object { $_.NextHop -ne "0.0.0.0" -and $_.NextHop -ne "::" } |
    Select-Object -First 5 |
    Format-Table DestinationPrefix, NextHop, RouteMetric

# 下载文件
Invoke-WebRequest -Uri "https://www.example.com/file.txt" -OutFile "C:\Temp\file.txt"

# 发送HTTP请求
$response = Invoke-RestMethod -Uri "https://api.github.com/users/octocat"
$response | Format-List login, name, location

# 创建网络共享
New-SmbShare -Name "TempShare" -Path "C:\Temp" -FullAccess "Everyone"

# 获取网络共享
Get-SmbShare |
    Where-Object { $_.Special -eq $false } |
    Format-Table Name, Path, Description

# 移除网络共享
Remove-SmbShare -Name "TempShare" -Force

# 获取防火墙规则
Get-NetFirewallRule |
    Where-Object { $_.Enabled -eq $true -and $_.Direction -eq "Inbound" } |
    Select-Object -First 5 |
    Format-Table Name, DisplayName, Direction, Action

# 创建防火墙规则
New-NetFirewallRule -DisplayName "Allow Port 8080" -Direction Inbound -Protocol TCP -LocalPort 8080 -Action Allow

# 禁用防火墙规则
Disable-NetFirewallRule -DisplayName "Allow Port 8080"

# 移除防火墙规则
Remove-NetFirewallRule -DisplayName "Allow Port 8080"
```

#### 4.2.4 远程管理

使用PowerShell进行远程管理：

```powershell
# 启用远程管理（在目标计算机上运行）
Enable-PSRemoting -Force

# 配置信任的主机
Set-Item WSMan:\localhost\Client\TrustedHosts -Value "computer1,computer2" -Force

# 创建远程会话
$session = New-PSSession -ComputerName "computer1" -Credential (Get-Credential)

# 在远程会话中执行命令
Invoke-Command -Session $session -ScriptBlock {
    Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5
}

# 将本地脚本复制到远程会话并执行
Invoke-Command -Session $session -FilePath "C:\Scripts\Get-SystemInfo.ps1"

# 在多台计算机上执行命令
Invoke-Command -ComputerName "computer1", "computer2" -ScriptBlock {
    Get-Service | Where-Object { $_.Status -eq "Running" }
} -Credential (Get-Credential)

# 将文件复制到远程计算机
Copy-Item -Path "C:\Scripts\script.ps1" -Destination "C:\Scripts\" -ToSession $session

# 从远程计算机复制文件
Copy-Item -Path "C:\Logs\system.log" -Destination "C:\Logs\" -FromSession $session

# 进入交互式远程会话
Enter-PSSession -Session $session

# 退出交互式远程会话
Exit-PSSession

# 关闭远程会话
Remove-PSSession -Session $session

# 使用WMI/CIM远程管理
Get-CimInstance -ClassName Win32_OperatingSystem -ComputerName "computer1" |
    Select-Object CSName, Caption, Version, LastBootUpTime

# 远程注册表访问
Invoke-Command -ComputerName "computer1" -ScriptBlock {
    Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion" |
    Select-Object ProductName, ReleaseId, CurrentBuild
}
```

### 4.3 PowerShell脚本最佳实践

#### 4.3.1 脚本结构和风格

良好的PowerShell脚本结构和风格：

```powershell
<#
.SYNOPSIS
    系统资源监控脚本
.DESCRIPTION
    监控系统CPU、内存和
让我继续完成自动化脚本开发基础的内容：

#### 4.3.1 脚本结构和风格（续）

```powershell
<#
.SYNOPSIS
    系统资源监控脚本
.DESCRIPTION
    监控系统CPU、内存和磁盘使用情况，并生成报告
.PARAMETER Interval
    监控间隔（秒）
.PARAMETER OutputPath
    报告输出路径
.PARAMETER Verbose
    显示详细信息
.EXAMPLE
    .\Monitor-SystemResources.ps1 -Interval 10 -OutputPath "C:\Reports"
.NOTES
    作者: Your Name
    创建日期: 2023-01-01
    版本: 1.0
#>

[CmdletBinding()]
param (
    [Parameter(Mandatory=$false)]
    [int]$Interval = 5,
    
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp\Reports",
    
    [Parameter(Mandatory=$false)]
    [switch]$Verbose
)

# 导入模块
Import-Module Microsoft.PowerShell.Utility
Import-Module Microsoft.PowerShell.Management

# 常量定义
$MAX_SAMPLES = 100
$CPU_THRESHOLD = 80
$MEMORY_THRESHOLD = 80
$DISK_THRESHOLD = 90

# 函数定义
function Initialize-Environment {
    [CmdletBinding()]
    param()
    
    Write-Verbose "初始化环境..."
    
    # 创建输出目录
    if (-not (Test-Path -Path $OutputPath)) {
        New-Item -Path $OutputPath -ItemType Directory -Force | Out-Null
        Write-Verbose "创建输出目录: $OutputPath"
    }
    
    # 创建日志文件
    $logFile = Join-Path -Path $OutputPath -ChildPath "SystemMonitor_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
    Write-Verbose "日志文件: $logFile"
    
    return $logFile
}

function Get-SystemMetrics {
    [CmdletBinding()]
    param()
    
    Write-Verbose "获取系统指标..."
    
    # 获取CPU使用率
    $cpuUsage = (Get-Counter '\Processor(_Total)\% Processor Time').CounterSamples.CookedValue
    
    # 获取内存使用率
    $osInfo = Get-CimInstance -ClassName Win32_OperatingSystem
    $memoryUsage = [math]::Round(($osInfo.TotalVisibleMemorySize - $osInfo.FreePhysicalMemory) / $osInfo.TotalVisibleMemorySize * 100, 2)
    
    # 获取磁盘使用率
    $diskInfo = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DriveType=3"
    $diskUsage = @()
    foreach ($disk in $diskInfo) {
        if ($disk.Size -gt 0) {
            $usedPercent = [math]::Round(($disk.Size - $disk.FreeSpace) / $disk.Size * 100, 2)
            $diskUsage += [PSCustomObject]@{
                Drive = $disk.DeviceID
                UsedPercent = $usedPercent
            }
        }
    }
    
    # 返回指标
    return [PSCustomObject]@{
        Timestamp = Get-Date
        CPU = $cpuUsage
        Memory = $memoryUsage
        Disk = $diskUsage
    }
}

function Write-MetricsToLog {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [PSCustomObject]$Metrics,
        
        [Parameter(Mandatory=$true)]
        [string]$LogFile
    )
    
    Write-Verbose "记录指标到日志..."
    
    $timestamp = $Metrics.Timestamp.ToString("yyyy-MM-dd HH:mm:ss")
    $logEntry = "[$timestamp] CPU: $($Metrics.CPU)%, Memory: $($Metrics.Memory)%"
    
    foreach ($disk in $Metrics.Disk) {
        $logEntry += ", $($disk.Drive): $($disk.UsedPercent)%"
    }
    
    Add-Content -Path $LogFile -Value $logEntry
    
    # 检查阈值并记录警告
    if ($Metrics.CPU -gt $CPU_THRESHOLD) {
        $warning = "[$timestamp] 警告: CPU使用率超过阈值 ($($Metrics.CPU)% > $CPU_THRESHOLD%)"
        Add-Content -Path $LogFile -Value $warning
        Write-Warning $warning
    }
    
    if ($Metrics.Memory -gt $MEMORY_THRESHOLD) {
        $warning = "[$timestamp] 警告: 内存使用率超过阈值 ($($Metrics.Memory)% > $MEMORY_THRESHOLD%)"
        Add-Content -Path $LogFile -Value $warning
        Write-Warning $warning
    }
    
    foreach ($disk in $Metrics.Disk) {
        if ($disk.UsedPercent -gt $DISK_THRESHOLD) {
            $warning = "[$timestamp] 警告: 磁盘 $($disk.Drive) 使用率超过阈值 ($($disk.UsedPercent)% > $DISK_THRESHOLD%)"
            Add-Content -Path $LogFile -Value $warning
            Write-Warning $warning
        }
    }
}

function Generate-Report {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$LogFile,
        
        [Parameter(Mandatory=$true)]
        [string]$OutputPath
    )
    
    Write-Verbose "生成报告..."
    
    $reportFile = Join-Path -Path $OutputPath -ChildPath "SystemReport_$(Get-Date -Format 'yyyyMMdd_HHmmss').html"
    
    # 读取日志数据
    $logData = Get-Content -Path $LogFile
    
    # 创建HTML报告
    $html = @"
<!DOCTYPE html>
<html>
<head>
    <title>系统资源监控报告</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { color: #2c3e50; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .warning { color: red; font-weight: bold; }
    </style>
</head>
<body>
    <h1>系统资源监控报告</h1>
    <p>生成时间: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')</p>
    <h2>监控日志</h2>
    <table>
        <tr>
            <th>时间戳</th>
            <th>指标</th>
        </tr>
"@

    foreach ($line in $logData) {
        $class = if ($line -match "警告") { "warning" } else { "" }
        $html += @"
        <tr class="$class">
            <td>$(($line -split ']')[0].TrimStart('['))</td>
            <td>$(($line -split ']')[1].TrimStart(' '))</td>
        </tr>
"@
    }

    $html += @"
    </table>
</body>
</html>
"@

    # 保存HTML报告
    $html | Out-File -FilePath $reportFile -Encoding UTF8
    
    Write-Verbose "报告已生成: $reportFile"
    return $reportFile
}

# 主函数
function Main {
    [CmdletBinding()]
    param()
    
    try {
        Write-Host "开始系统资源监控..."
        Write-Host "监控间隔: $Interval 秒"
        Write-Host "输出路径: $OutputPath"
        
        # 初始化环境
        $logFile = Initialize-Environment
        
        # 监控循环
        $sampleCount = 0
        while ($sampleCount -lt $MAX_SAMPLES) {
            # 获取系统指标
            $metrics = Get-SystemMetrics
            
            # 记录指标
            Write-MetricsToLog -Metrics $metrics -LogFile $logFile
            
            # 显示当前指标
            Write-Host "CPU: $($metrics.CPU)%, Memory: $($metrics.Memory)%, Disk C:: $($metrics.Disk[0].UsedPercent)%"
            
            # 增加计数器
            $sampleCount++
            
            # 等待下一个间隔
            if ($sampleCount -lt $MAX_SAMPLES) {
                Start-Sleep -Seconds $Interval
            }
        }
        
        # 生成报告
        $reportFile = Generate-Report -LogFile $logFile -OutputPath $OutputPath
        Write-Host "监控完成，报告已生成: $reportFile"
        
        # 打开报告
        Invoke-Item $reportFile
    }
    catch {
        Write-Error "发生错误: $_"
        Write-Error $_.ScriptStackTrace
        exit 1
    }
}

# 脚本入口
Main
```

#### 4.3.2 安全性考虑

PowerShell脚本编写中的安全性考虑：

```powershell
# 安全处理凭据
function Connect-SecureServer {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$Server,
        
        [Parameter(Mandatory=$true)]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]
        $Credential
    )
    
    # 使用安全凭据而非明文密码
    try {
        $session = New-PSSession -ComputerName $Server -Credential $Credential
        return $session
    }
    catch {
        Write-Error "连接服务器失败: $_"
        return $null
    }
}

# 调用示例
# $cred = Get-Credential -Message "请输入服务器凭据"
# $session = Connect-SecureServer -Server "server01" -Credential $cred

# 安全处理敏感数据
function Save-SecureConfig {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$ConfigPath,
        
        [Parameter(Mandatory=$true)]
        [hashtable]$ConfigData,
        
        [Parameter(Mandatory=$true)]
        [string[]]$SensitiveKeys
    )
    
    # 创建配置副本
    $secureConfig = $ConfigData.Clone()
    
    # 加密敏感数据
    foreach ($key in $SensitiveKeys) {
        if ($secureConfig.ContainsKey($key)) {
            $secureString = ConvertTo-SecureString -String $secureConfig[$key] -AsPlainText -Force
            $secureConfig[$key] = ConvertFrom-SecureString -SecureString $secureString
        }
    }
    
    # 保存加密后的配置
    $secureConfig | ConvertTo-Json | Out-File -FilePath $ConfigPath -Encoding UTF8
    
    # 设置文件权限
    $acl = Get-Acl -Path $ConfigPath
    $acl.SetAccessRuleProtection($true, $false)  # 禁用继承
    $rule = New-Object System.Security.AccessControl.FileSystemAccessRule(
        [System.Security.Principal.WindowsIdentity]::GetCurrent().Name,
        "FullControl",
        "Allow"
    )
    $acl.AddAccessRule($rule)
    Set-Acl -Path $ConfigPath -AclObject $acl
}

# 安全读取配置
function Read-SecureConfig {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$ConfigPath,
        
        [Parameter(Mandatory=$false)]
        [string[]]$DecryptKeys = @()
    )
    
    if (-not (Test-Path -Path $ConfigPath)) {
        Write-Error "配置文件不存在: $ConfigPath"
        return $null
    }
    
    try {
        # 读取配置
        $config = Get-Content -Path $ConfigPath -Raw | ConvertFrom-Json -AsHashtable
        
        # 解密指定的键
        foreach ($key in $DecryptKeys) {
            if ($config.ContainsKey($key)) {
                $secureString = ConvertTo-SecureString -String $config[$key]
                $config[$key] = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto(
                    [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($secureString)
                )
            }
        }
        
        return $config
    }
    catch {
        Write-Error "读取配置失败: $_"
        return $null
    }
}

# 安全执行命令
function Invoke-SafeCommand {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$Command,
        
        [Parameter(Mandatory=$false)]
        [string[]]$AllowedCommands = @("Get-Process", "Get-Service", "Get-ChildItem")
    )
    
    # 检查命令是否在允许列表中
    $commandName = ($Command -split ' ')[0]
    if ($AllowedCommands -notcontains $commandName) {
        Write-Error "不允许执行命令: $commandName"
        return
    }
    
    # 安全执行命令
    try {
        $scriptBlock = [ScriptBlock]::Create($Command)
        Invoke-Command -ScriptBlock $scriptBlock
    }
    catch {
        Write-Error "执行命令失败: $_"
    }
}

# 安全处理用户输入
function Get-SafeUserInput {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$Prompt,
        
        [Parameter(Mandatory=$false)]
        [string]$Pattern = ".*",
        
        [Parameter(Mandatory=$false)]
        [string]$ErrorMessage = "输入格式不正确"
    )
    
    do {
        $input = Read-Host -Prompt $Prompt
        $isValid = $input -match $Pattern
        
        if (-not $isValid) {
            Write-Warning $ErrorMessage
        }
    } while (-not $isValid)
    
    return $input
}

# 安全处理临时文件
function New-SafeTempFile {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$false)]
        [string]$Extension = ".tmp"
    )
    
    # 创建安全的临时文件
    $tempPath = [System.IO.Path]::GetTempPath()
    $tempFileName = [System.IO.Path]::GetRandomFileName() + $Extension
    $tempFilePath = Join-Path -Path $tempPath -ChildPath $tempFileName
    
    # 创建文件并设置安全权限
    $null = New-Item -Path $tempFilePath -ItemType File
    $acl = Get-Acl -Path $tempFilePath
    $acl.SetAccessRuleProtection($true, $false)  # 禁用继承
    $rule = New-Object System.Security.AccessControl.FileSystemAccessRule(
        [System.Security.Principal.WindowsIdentity]::GetCurrent().Name,
        "FullControl",
        "Allow"
    )
    $acl.AddAccessRule($rule)
    Set-Acl -Path $tempFilePath -AclObject $acl
    
    # 注册清理事件
    $scriptBlock = {
        param($FilePath)
        if (Test-Path -Path $FilePath) {
            Remove-Item -Path $FilePath -Force
        }
    }
    Register-EngineEvent -SourceIdentifier ([System.Management.Automation.PsEngineEvent]::Exiting) -Action $scriptBlock -MessageData $tempFilePath
    
    return $tempFilePath
}
```

#### 4.3.3 错误处理和日志记录

PowerShell脚本中的错误处理和日志记录：

```powershell
# 配置日志记录
function Initialize-Logging {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$false)]
        [string]$LogPath = "C:\Logs",
        
        [Parameter(Mandatory=$false)]
        [string]$LogName = "ScriptLog",
        
        [Parameter(Mandatory=$false)]
        [ValidateSet("Error", "Warning", "Information", "Verbose", "Debug")]
        [string]$LogLevel = "Information"
    )
    
    # 创建日志目录
    if (-not (Test-Path -Path $LogPath)) {
        New-Item -Path $LogPath -ItemType Directory -Force | Out-Null
    }
    
    # 创建日志文件路径
    $date = Get-Date -Format "yyyyMMdd"
    $logFile = Join-Path -Path $LogPath -ChildPath "$LogName`_$date.log"
    
    # 创建日志对象
    $script:Logger = [PSCustomObject]@{
        LogFile = $logFile
        LogLevel = $LogLevel
        LevelMap = @{
            Error = 1
            Warning = 2
            Information = 3
            Verbose = 4
            Debug = 5
        }
    }
    
    # 添加日志方法
    $script:Logger | Add-Member -MemberType ScriptMethod -Name Log -Value {
        param (
            [string]$Message,
            [string]$Level = "Information",
            [string]$Source = "Script"
        )
        
        if ($this.LevelMap[$Level] -le $this.LevelMap[$this.LogLevel]) {
            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            $logEntry = "[$timestamp] [$Level] [$Source] $Message"
            Add-Content -Path $this.LogFile -Value $logEntry
            
            # 同时输出到控制台
            switch ($Level) {
                "Error" { Write-Error $Message }
                "Warning" { Write-Warning $Message }
                "Information" { Write-Host $Message }
                "Verbose" { Write-Verbose $Message }
                "Debug" { Write-Debug $Message }
            }
        }
    }
    
    # 记录初始日志
    $script:Logger.Log("日志系统初始化完成", "Information", "LogSystem")
    return $script:Logger
}

# 错误处理函数
function Invoke-WithErrorHandling {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter(Mandatory=$false)]
        [scriptblock]$ErrorAction = { throw $_ },
        
        [Parameter(Mandatory=$false)]
        [scriptblock]$FinallyAction = { },
        
        [Parameter(Mandatory=$false)]
        [string]$ErrorMessage = "执行脚本块时发生错误"
    )
    
    try {
        # 执行脚本块
        & $ScriptBlock
    }
    catch {
        # 记录错误
        if ($script:Logger) {
            $script:Logger.Log("$ErrorMessage`: $_", "Error", "ErrorHandler")
            $script:Logger.Log("错误详情: $($_.ScriptStackTrace)", "Error", "ErrorHandler")
        }
        else {
            Write-Error "$ErrorMessage`: $_"
            Write-Error "错误详情: $($_.ScriptStackTrace)"
        }
        
        # 执行错误处理动作
        & $ErrorAction
    }
    finally {
        # 执行清理动作
        & $FinallyAction
    }
}

# 重试逻辑
function Invoke-WithRetry {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [scriptblock]$ScriptBlock,
        
        [Parameter(Mandatory=$false)]
        [int]$MaxRetries = 3,
        
        [Parameter(Mandatory=$false)]
        [int]$RetryDelaySeconds = 5,
        
        [Parameter(Mandatory=$false)]
        [scriptblock]$RetryCondition = { $true },
        
        [Parameter(Mandatory=$false)]
        [string]$OperationName = "操作"
    )
    
    $retryCount = 0
    $completed = $false
    $result = $null
    
    while (-not $completed -and $retryCount -le $MaxRetries) {
        try {
            if ($retryCount -gt 0) {
                if ($script:Logger) {
                    $script:Logger.Log("$OperationName 第 $retryCount 次重试", "Warning", "RetryHandler")
                }
                else {
                    Write-Warning "$OperationName 第 $retryCount 次重试"
                }
                Start-Sleep -Seconds $RetryDelaySeconds
            }
            
            # 执行操作
            $result = & $ScriptBlock
            $completed = $true
        }
        catch {
            $retryCount++
            $shouldRetry = & $RetryCondition
            
            if ($retryCount -gt $MaxRetries -or -not $shouldRetry) {
                if ($script:Logger) {
                    $script:Logger.Log("$OperationName 失败，已达到最大重试次数或不满足重试条件: $_", "Error", "RetryHandler")
                }
                else {
                    Write-Error "$OperationName 失败，已达到最大重试次数或不满足重试条件: $_"
                }
                throw
            }
            else {
                if ($script:Logger) {
                    $script:Logger.Log("$OperationName 失败，将重试: $_", "Warning", "RetryHandler")
                }
                else {
                    Write-Warning "$OperationName 失败，将重试: $_"
                }
            }
        }
    }
    
    return $result
}

# 使用示例
function Example-ErrorHandling {
    # 初始化日志
    $logger = Initialize-Logging -LogPath "C:\Temp\Logs" -LogName "ErrorHandlingDemo" -LogLevel "Debug"
    
    # 使用错误处理执行操作
    Invoke-WithErrorHandling -ScriptBlock {
        $logger.Log("开始执行危险操作", "Information", "Example")
        
        # 模拟操作
        Get-Process -Name "NonExistentProcess"
        
        $logger.Log("操作完成", "Information", "Example")
    } -ErrorMessage "获取进程失败" -ErrorAction {
        $logger.Log("错误已处理，继续执行", "Warning", "Example")
    } -FinallyAction {
        $logger.Log("清理资源", "Information", "Example")
    }
    
    # 使用重试逻辑
    Invoke-WithRetry -ScriptBlock {
        $logger.Log("尝试连接服务器", "Information", "Example")
        
        # 模拟连接操作
        if ((Get-Random -Minimum 1 -Maximum 4) -eq 1) {
            $logger.Log("连接成功", "Information", "Example")
            return "连接成功"
        }
        else {
            throw "连接超时"
        }
    } -MaxRetries 5 -RetryDelaySeconds 2 -OperationName "服务器连接"
}
```

#### 4.3.4 模块化和可重用性

PowerShell脚本的模块化和可重用性：

```powershell
# 创建模块文件 ServerManagement.psm1
# 保存到 C:\Scripts\Modules\ServerManagement\ServerManagement.psm1

# 模块清单文件 ServerManagement.psd1
# 可以使用 New-ModuleManifest cmdlet 创建

# 服务器管理函数
function Get-ServerHealth {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true, ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)]
        [string[]]$ComputerName,
        
        [Parameter(Mandatory=$false)]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]
        $Credential
    )
    
    begin {
        Write-Verbose "开始获取服务器健康状态"
        $results = @()
    }
    
    process {
        foreach ($computer in $ComputerName) {
            Write-Verbose "处理服务器: $computer"
            
            try {
                # 创建参数哈希表
                $params = @{
                    ComputerName = $computer
                    ErrorAction = "Stop"
                }
                
                if ($Credential) {
                    $params.Credential = $Credential
                }
                
                # 获取系统信息
                $os = Get-CimInstance -ClassName Win32_OperatingSystem @params
                $cs = Get-CimInstance -ClassName Win32_ComputerSystem @params
                $proc = Get-CimInstance -ClassName Win32_Processor @params
                $disk = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DriveType=3" @params
                
                # 计算内存使用率
                $memoryUsage = [math]::Round(($os.TotalVisibleMemorySize - $os.FreePhysicalMemory) / $os.TotalVisibleMemorySize * 100, 2)
                
                # 计算磁盘使用率
                $diskUsage = @()
                foreach ($d in $disk) {
                    if ($d.Size -gt 0) {
                        $usedPercent = [math]::Round(($d.Size - $d.FreeSpace) / $d.Size * 100, 2)
                        $diskUsage += [PSCustomObject]@{
                            Drive = $d.DeviceID
                            Size = [math]::Round($d.Size / 1GB, 2)
                            FreeSpace = [math]::Round($d.FreeSpace / 1GB, 2)
                            UsedPercent = $usedPercent
                        }
                    }
                }
                
                # 创建结果对象
                $result = [PSCustomObject]@{
                    ComputerName = $computer
                    Status = "Online"
                    OperatingSystem = $os.Caption
                    LastBootTime = $os.LastBootUpTime
                    TotalMemoryGB = [math]::Round($os.TotalVisibleMemorySize / 1MB, 2)
                    MemoryUsagePercent = $memoryUsage
                    Processors = $proc.Count
                    Model = $cs.Model
                    Manufacturer = $cs.Manufacturer
                    Disks = $diskUsage
                }
                
                $results += $result
            }
            catch {
                Write-Warning "无法获取服务器 $computer 的健康状态: $_"
                
                # 创建错误结果对象
                $result = [PSCustomObject]@{
                    ComputerName = $computer
                    Status = "Offline"
                    ErrorMessage = $_.Exception.Message
                }
                
                $results += $result
            }
        }
    }
    
    end {
        Write-Verbose "完成获取服务器健康状态"
        return $results
    }
}

function Restart-ServerService {
    [CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
    param (
        [Parameter(Mandatory=$true, ValueFromPipeline=$true, ValueFromPipelineByPropertyName=$true)]
        [string[]]$ComputerName,
        
        [Parameter(Mandatory=$true)]
        [string]$ServiceName,
        
        [Parameter(Mandatory=$false)]
        [System.Management.Automation.PSCredential]
        [System.Management.Automation.Credential()]
        $Credential,
        
        [Parameter(Mandatory=$false)]
        [switch]$Force
    )
    
    begin {
        Write-Verbose "开始重启服务"
        $results = @()
    }
    
    process {
        foreach ($computer in $ComputerName) {
            Write-Verbose "处理服务器: $computer"
            
            try {
                # 创建参数哈希表
                $params = @{
                    ComputerName = $computer
                    ErrorAction = "Stop"
                }
                
                if ($Credential) {
                    $params.Credential = $Credential
                }
                
                # 获取服务状态
                $service = Get-Service -Name $ServiceName @params
                
                # 确认操作
                $shouldProcessMessage = "重启服务器 $computer 上的服务 $ServiceName"
                if ($Force -or $PSCmdlet.ShouldProcess($shouldProcessMessage)) {
                    # 重启服务
                    $service | Restart-Service -Force:$Force
                    
                    # 验证服务状态
                    $updatedService = Get-Service -Name $ServiceName @params
                    
                    # 创建结果对象
                    $result = [PSCustomObject]@{
                        ComputerName = $computer
                        ServiceName = $ServiceName
                        Status = $updatedService.Status
                        Success = ($updatedService.Status -eq "Running")
                    }
                    
                    $results += $result
                }
            }
            catch {
                Write-Warning "无法重启服务器 $computer 上的服务 $ServiceName`: $_"
                
                # 创建错误结果对象
                $result = [PSCustomObject]@{
                    ComputerName = $computer
                    ServiceName = $ServiceName
                    Status = "Unknown"
                    Success = $false
                    ErrorMessage = $_.Exception.Message
                }
                
                $results += $result
            }
        }
    }
    
    end {
        Write-Verbose "完成重启服务"
        return $results
    }
}

# 导出函数
Export-ModuleMember -Function Get-ServerHealth, Restart-ServerService

# 使用模块的示例脚本
# 保存为 C:\Scripts\Monitor-Servers.ps1

<#
.SYNOPSIS
    监控服务器健康状态
.DESCRIPTION
    使用ServerManagement模块监控多台服务器的健康状态
让我继续完成自动化脚本开发基础的内容：

#### 4.3.4 模块化和可重用性（续）

```powershell
<#
.SYNOPSIS
    监控服务器健康状态
.DESCRIPTION
    使用ServerManagement模块监控多台服务器的健康状态
.PARAMETER ComputerName
    要监控的服务器名称数组
.PARAMETER OutputPath
    报告输出路径
.PARAMETER Credential
    连接服务器的凭据
.EXAMPLE
    .\Monitor-Servers.ps1 -ComputerName "server1", "server2" -OutputPath "C:\Reports"
.NOTES
    作者: Your Name
    创建日期: 2023-01-01
    版本: 1.0
#>

[CmdletBinding()]
param (
    [Parameter(Mandatory=$true)]
    [string[]]$ComputerName,
    
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp\Reports",
    
    [Parameter(Mandatory=$false)]
    [System.Management.Automation.PSCredential]
    [System.Management.Automation.Credential()]
    $Credential
)

# 导入模块
Import-Module ServerManagement -ErrorAction Stop

# 创建输出目录
if (-not (Test-Path -Path $OutputPath)) {
    New-Item -Path $OutputPath -ItemType Directory -Force | Out-Null
}

# 获取服务器健康状态
$params = @{
    ComputerName = $ComputerName
    Verbose = $true
}

if ($Credential) {
    $params.Credential = $Credential
}

$results = Get-ServerHealth @params

# 生成HTML报告
$reportFile = Join-Path -Path $OutputPath -ChildPath "ServerHealthReport_$(Get-Date -Format 'yyyyMMdd_HHmmss').html"

$html = @"
<!DOCTYPE html>
<html>
<head>
    <title>服务器健康状态报告</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1 { color: #2c3e50; }
        table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .online { color: green; }
        .offline { color: red; }
        .warning { color: orange; }
    </style>
</head>
<body>
    <h1>服务器健康状态报告</h1>
    <p>生成时间: $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss')</p>
    
    <h2>服务器状态摘要</h2>
    <table>
        <tr>
            <th>服务器</th>
            <th>状态</th>
            <th>操作系统</th>
            <th>上次启动时间</th>
            <th>内存使用率</th>
            <th>型号</th>
        </tr>
"@

foreach ($server in $results) {
    $statusClass = if ($server.Status -eq "Online") { "online" } else { "offline" }
    $memoryClass = if ($server.Status -eq "Online" -and $server.MemoryUsagePercent -gt 80) { "warning" } else { "" }
    
    $html += @"
        <tr>
            <td>$($server.ComputerName)</td>
            <td class="$statusClass">$($server.Status)</td>
"@
    
    if ($server.Status -eq "Online") {
        $html += @"
            <td>$($server.OperatingSystem)</td>
            <td>$($server.LastBootTime)</td>
            <td class="$memoryClass">$($server.MemoryUsagePercent)%</td>
            <td>$($server.Manufacturer) $($server.Model)</td>
"@
    } else {
        $html += @"
            <td colspan="4">$($server.ErrorMessage)</td>
"@
    }
    
    $html += @"
        </tr>
"@
}

$html += @"
    </table>
    
    <h2>磁盘使用情况</h2>
"@

foreach ($server in $results) {
    if ($server.Status -eq "Online") {
        $html += @"
    <h3>$($server.ComputerName)</h3>
    <table>
        <tr>
            <th>驱动器</th>
            <th>总容量 (GB)</th>
            <th>可用空间 (GB)</th>
            <th>使用率</th>
        </tr>
"@
        
        foreach ($disk in $server.Disks) {
            $diskClass = if ($disk.UsedPercent -gt 90) { "warning" } else { "" }
            
            $html += @"
        <tr>
            <td>$($disk.Drive)</td>
            <td>$($disk.Size)</td>
            <td>$($disk.FreeSpace)</td>
            <td class="$diskClass">$($disk.UsedPercent)%</td>
        </tr>
"@
        }
        
        $html += @"
    </table>
"@
    }
}

$html += @"
</body>
</html>
"@

# 保存HTML报告
$html | Out-File -FilePath $reportFile -Encoding UTF8

# 显示结果
Write-Host "服务器健康状态报告已生成: $reportFile"
Write-Host "在线服务器: $($results | Where-Object { $_.Status -eq 'Online' } | Measure-Object | Select-Object -ExpandProperty Count)"
Write-Host "离线服务器: $($results | Where-Object { $_.Status -eq 'Offline' } | Measure-Object | Select-Object -ExpandProperty Count)"

# 打开报告
Invoke-Item $reportFile
```

## 5. 自动化脚本实战案例

### 5.1 系统维护自动化

#### 5.1.1 Windows系统维护脚本

以下是一个Windows系统维护自动化脚本示例：

```powershell
<#
.SYNOPSIS
    Windows系统维护自动化脚本
.DESCRIPTION
    执行常见的Windows系统维护任务，包括：
    - 磁盘清理
    - 系统更新
    - 磁盘碎片整理
    - 系统检查
    - 备份关键文件
.PARAMETER Tasks
    要执行的任务列表
.PARAMETER LogPath
    日志文件路径
.EXAMPLE
    .\Maintain-WindowsSystem.ps1 -Tasks "DiskCleanup", "SystemUpdates"
.NOTES
    作者: Your Name
    创建日期: 2023-01-01
    版本: 1.0
#>

[CmdletBinding()]
param (
    [Parameter(Mandatory=$false)]
    [ValidateSet("DiskCleanup", "SystemUpdates", "DiskDefrag", "SystemCheck", "Backup", "All")]
    [string[]]$Tasks = @("All"),
    
    [Parameter(Mandatory=$false)]
    [string]$LogPath = "C:\Logs\SystemMaintenance"
)

# 初始化日志
function Initialize-Log {
    [CmdletBinding()]
    param()
    
    if (-not (Test-Path -Path $LogPath)) {
        New-Item -Path $LogPath -ItemType Directory -Force | Out-Null
    }
    
    $date = Get-Date -Format "yyyyMMdd_HHmmss"
    $logFile = Join-Path -Path $LogPath -ChildPath "Maintenance_$date.log"
    
    return $logFile
}

# 写入日志
function Write-Log {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet("INFO", "WARNING", "ERROR", "SUCCESS")]
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    # 写入日志文件
    Add-Content -Path $script:LogFile -Value $logEntry
    
    # 输出到控制台
    switch ($Level) {
        "INFO" { Write-Host $Message }
        "WARNING" { Write-Host $Message -ForegroundColor Yellow }
        "ERROR" { Write-Host $Message -ForegroundColor Red }
        "SUCCESS" { Write-Host $Message -ForegroundColor Green }
    }
}

# 执行磁盘清理
function Invoke-DiskCleanup {
    [CmdletBinding()]
    param()
    
    Write-Log "开始执行磁盘清理..." -Level "INFO"
    
    try {
        # 清理临时文件
        $tempFolders = @(
            "$env:TEMP",
            "$env:SystemRoot\Temp",
            "$env:SystemRoot\Prefetch"
        )
        
        foreach ($folder in $tempFolders) {
            if (Test-Path -Path $folder) {
                Write-Log "清理文件夹: $folder" -Level "INFO"
                Get-ChildItem -Path $folder -Force -ErrorAction SilentlyContinue |
                    Where-Object { $_.LastWriteTime -lt (Get-Date).AddDays(-7) } |
                    Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
            }
        }
        
        # 清理回收站
        Write-Log "清空回收站..." -Level "INFO"
        Clear-RecycleBin -Force -ErrorAction SilentlyContinue
        
        # 运行Windows磁盘清理工具
        Write-Log "运行Windows磁盘清理工具..." -Level "INFO"
        Start-Process -FilePath "cleanmgr.exe" -ArgumentList "/sagerun:1" -Wait
        
        Write-Log "磁盘清理完成" -Level "SUCCESS"
    }
    catch {
        Write-Log "磁盘清理过程中发生错误: $_" -Level "ERROR"
    }
}

# 执行系统更新
function Invoke-SystemUpdates {
    [CmdletBinding()]
    param()
    
    Write-Log "开始检查系统更新..." -Level "INFO"
    
    try {
        # 检查PSWindowsUpdate模块
        if (-not (Get-Module -ListAvailable -Name PSWindowsUpdate)) {
            Write-Log "安装PSWindowsUpdate模块..." -Level "INFO"
            Install-Module -Name PSWindowsUpdate -Force -Scope CurrentUser
        }
        
        # 导入模块
        Import-Module PSWindowsUpdate
        
        # 获取可用更新
        $updates = Get-WindowsUpdate
        
        if ($updates.Count -eq 0) {
            Write-Log "没有可用的更新" -Level "INFO"
        }
        else {
            Write-Log "发现 $($updates.Count) 个可用更新" -Level "INFO"
            
            # 安装更新
            Write-Log "开始安装更新..." -Level "INFO"
            Install-WindowsUpdate -AcceptAll -AutoReboot:$false -Verbose | Out-File (Join-Path -Path $LogPath -ChildPath "WindowsUpdate.log")
            
            Write-Log "系统更新完成" -Level "SUCCESS"
        }
    }
    catch {
        Write-Log "系统更新过程中发生错误: $_" -Level "ERROR"
    }
}

# 执行磁盘碎片整理
function Invoke-DiskDefrag {
    [CmdletBinding()]
    param()
    
    Write-Log "开始执行磁盘碎片整理..." -Level "INFO"
    
    try {
        # 获取所有固定磁盘
        $disks = Get-Volume | Where-Object { $_.DriveType -eq 'Fixed' -and $_.DriveLetter -ne $null }
        
        foreach ($disk in $disks) {
            $driveLetter = $disk.DriveLetter
            Write-Log "对驱动器 $driveLetter`: 执行碎片整理" -Level "INFO"
            
            # 检查文件系统类型
            if ($disk.FileSystemType -eq "NTFS") {
                # 对NTFS文件系统执行碎片整理
                Optimize-Volume -DriveLetter $driveLetter -Defrag -Verbose
            }
            else {
                # 对其他文件系统执行优化
                Optimize-Volume -DriveLetter $driveLetter -Verbose
            }
        }
        
        Write-Log "磁盘碎片整理完成" -Level "SUCCESS"
    }
    catch {
        Write-Log "磁盘碎片整理过程中发生错误: $_" -Level "ERROR"
    }
}

# 执行系统检查
function Invoke-SystemCheck {
    [CmdletBinding()]
    param()
    
    Write-Log "开始执行系统检查..." -Level "INFO"
    
    try {
        # 检查系统文件
        Write-Log "检查系统文件完整性..." -Level "INFO"
        $sfc = Start-Process -FilePath "sfc.exe" -ArgumentList "/scannow" -Wait -PassThru -NoNewWindow
        if ($sfc.ExitCode -eq 0) {
            Write-Log "系统文件检查完成" -Level "SUCCESS"
        }
        else {
            Write-Log "系统文件检查返回代码: $($sfc.ExitCode)" -Level "WARNING"
        }
        
        # 检查磁盘
        Write-Log "检查磁盘错误..." -Level "INFO"
        $disks = Get-Volume | Where-Object { $_.DriveType -eq 'Fixed' -and $_.DriveLetter -ne $null }
        
        foreach ($disk in $disks) {
            $driveLetter = $disk.DriveLetter
            Write-Log "检查驱动器 $driveLetter`:" -Level "INFO"
            
            $chkdsk = Start-Process -FilePath "chkdsk.exe" -ArgumentList "$driveLetter`: /scan" -Wait -PassThru -NoNewWindow
            if ($chkdsk.ExitCode -eq 0) {
                Write-Log "驱动器 $driveLetter`: 检查完成" -Level "SUCCESS"
            }
            else {
                Write-Log "驱动器 $driveLetter`: 检查返回代码: $($chkdsk.ExitCode)" -Level "WARNING"
            }
        }
        
        # 检查Windows更新组件
        Write-Log "修复Windows更新组件..." -Level "INFO"
        $dism = Start-Process -FilePath "dism.exe" -ArgumentList "/Online /Cleanup-Image /RestoreHealth" -Wait -PassThru -NoNewWindow
        if ($dism.ExitCode -eq 0) {
            Write-Log "Windows更新组件修复完成" -Level "SUCCESS"
        }
        else {
            Write-Log "Windows更新组件修复返回代码: $($dism.ExitCode)" -Level "WARNING"
        }
        
        Write-Log "系统检查完成" -Level "SUCCESS"
    }
    catch {
        Write-Log "系统检查过程中发生错误: $_" -Level "ERROR"
    }
}

# 执行关键文件备份
function Invoke-Backup {
    [CmdletBinding()]
    param()
    
    Write-Log "开始执行关键文件备份..." -Level "INFO"
    
    try {
        # 备份目标目录
        $backupSources = @(
            "$env:USERPROFILE\Documents",
            "$env:USERPROFILE\Desktop",
            "$env:USERPROFILE\Pictures"
        )
        
        # 备份目标路径
        $backupRoot = "C:\Backups"
        $date = Get-Date -Format "yyyyMMdd"
        $backupDest = Join-Path -Path $backupRoot -ChildPath "Backup_$date"
        
        # 创建备份目录
        if (-not (Test-Path -Path $backupRoot)) {
            New-Item -Path $backupRoot -ItemType Directory -Force | Out-Null
        }
        
        if (-not (Test-Path -Path $backupDest)) {
            New-Item -Path $backupDest -ItemType Directory -Force | Out-Null
        }
        
        # 执行备份
        foreach ($source in $backupSources) {
            if (Test-Path -Path $source) {
                $folderName = Split-Path -Path $source -Leaf
                $destination = Join-Path -Path $backupDest -ChildPath $folderName
                
                Write-Log "备份 $source 到 $destination" -Level "INFO"
                Copy-Item -Path $source -Destination $destination -Recurse -Force
            }
            else {
                Write-Log "源目录不存在: $source" -Level "WARNING"
            }
        }
        
        # 创建备份摘要
        $summary = @{
            BackupDate = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            BackupSources = $backupSources
            BackupDestination = $backupDest
            ComputerName = $env:COMPUTERNAME
            UserName = $env:USERNAME
        }
        
        $summaryFile = Join-Path -Path $backupDest -ChildPath "BackupSummary.json"
        $summary | ConvertTo-Json | Out-File -FilePath $summaryFile
        
        Write-Log "备份完成，保存在: $backupDest" -Level "SUCCESS"
    }
    catch {
        Write-Log "备份过程中发生错误: $_" -Level "ERROR"
    }
}

# 主函数
function Main {
    [CmdletBinding()]
    param()
    
    # 初始化日志
    $script:LogFile = Initialize-Log
    
    Write-Log "开始系统维护..." -Level "INFO"
    Write-Log "计算机名: $env:COMPUTERNAME" -Level "INFO"
    Write-Log "操作系统: $(Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -ExpandProperty Caption)" -Level "INFO"
    Write-Log "执行任务: $($Tasks -join ', ')" -Level "INFO"
    
    # 确定要执行的任务
    $tasksToRun = @()
    if ($Tasks -contains "All") {
        $tasksToRun = @("DiskCleanup", "SystemUpdates", "DiskDefrag", "SystemCheck", "Backup")
    }
    else {
        $tasksToRun = $Tasks
    }
    
    # 执行任务
    foreach ($task in $tasksToRun) {
        Write-Log "===== 执行任务: $task =====" -Level "INFO"
        
        switch ($task) {
            "DiskCleanup" { Invoke-DiskCleanup }
            "SystemUpdates" { Invoke-SystemUpdates }
            "DiskDefrag" { Invoke-DiskDefrag }
            "SystemCheck" { Invoke-SystemCheck }
            "Backup" { Invoke-Backup }
        }
    }
    
    Write-Log "系统维护完成" -Level "SUCCESS"
}

# 执行主函数
Main
```

#### 5.1.2 Linux系统维护脚本

以下是一个Linux系统维护自动化脚本示例：

```bash
#!/bin/bash

# Linux系统维护自动化脚本
# 执行常见的Linux系统维护任务，包括：
# - 系统更新
# - 磁盘清理
# - 系统检查
# - 备份关键文件
# - 日志轮转

# 使用方法: ./maintain_linux_system.sh [选项]
# 选项:
#   --update       执行系统更新
#   --cleanup      执行磁盘清理
#   --check        执行系统检查
#   --backup       执行关键文件备份
#   --logs         执行日志轮转
#   --all          执行所有任务（默认）

# 初始化变量
LOG_DIR="/var/log/system_maintenance"
LOG_FILE="$LOG_DIR/maintenance_$(date +%Y%m%d_%H%M%S).log"
BACKUP_DIR="/var/backups/system"
DO_UPDATE=false
DO_CLEANUP=false
DO_CHECK=false
DO_BACKUP=false
DO_LOGS=false

# 解析命令行参数
if [ $# -eq 0 ]; then
    # 如果没有参数，执行所有任务
    DO_UPDATE=true
    DO_CLEANUP=true
    DO_CHECK=true
    DO_BACKUP=true
    DO_LOGS=true
else
    for arg in "$@"; do
        case $arg in
            --update)
                DO_UPDATE=true
                ;;
            --cleanup)
                DO_CLEANUP=true
                ;;
            --check)
                DO_CHECK=true
                ;;
            --backup)
                DO_BACKUP=true
                ;;
            --logs)
                DO_LOGS=true
                ;;
            --all)
                DO_UPDATE=true
                DO_CLEANUP=true
                DO_CHECK=true
                DO_BACKUP=true
                DO_LOGS=true
                ;;
            *)
                echo "未知选项: $arg"
                exit 1
                ;;
        esac
    done
fi

# 创建日志目录
mkdir -p "$LOG_DIR"

# 日志函数
log() {
    local level="$1"
    local message="$2"
    local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
    echo "[$timestamp] [$level] $message" | tee -a "$LOG_FILE"
}

# 检查命令是否存在
check_command() {
    command -v "$1" >/dev/null 2>&1 || { log "ERROR" "命令 $1 不存在，请安装后再试"; return 1; }
    return 0
}

# 检查是否为root用户
check_root() {
    if [ "$(id -u)" -ne 0 ]; then
        log "ERROR" "此脚本需要root权限，请使用sudo或以root用户运行"
        exit 1
    fi
}

# 执行系统更新
do_system_update() {
    log "INFO" "开始执行系统更新..."
    
    # 检测Linux发行版
    if [ -f /etc/debian_version ]; then
        # Debian/Ubuntu
        log "INFO" "检测到Debian/Ubuntu系统"
        apt-get update
        apt-get -y upgrade
        apt-get -y dist-upgrade
        apt-get -y autoremove
        apt-get -y autoclean
    elif [ -f /etc/redhat-release ]; then
        # RHEL/CentOS/Fedora
        log "INFO" "检测到RHEL/CentOS/Fedora系统"
        yum -y update
        yum -y autoremove
        yum clean all
    elif [ -f /etc/arch-release ]; then
        # Arch Linux
        log "INFO" "检测到Arch Linux系统"
        pacman -Syu --noconfirm
        pacman -Sc --noconfirm
    else
        log "WARNING" "无法识别的Linux发行版，跳过系统更新"
        return 1
    fi
    
    log "SUCCESS" "系统更新完成"
    return 0
}

# 执行磁盘清理
do_disk_cleanup() {
    log "INFO" "开始执行磁盘清理..."
    
    # 清理临时文件
    log "INFO" "清理临时文件..."
    find /tmp -type f -atime +7 -delete
    find /var/tmp -type f -atime +7 -delete
    
    # 清理旧日志
    log "INFO" "清理旧日志文件..."
    find /var/log -type f -name "*.gz" -o -name "*.old" -o -name "*.1" -atime +30 -delete
    
    # 清理软件包缓存
    if [ -f /etc/debian_version ]; then
        log "INFO" "清理APT缓存..."
        apt-get clean
    elif [ -f /etc/redhat-release ]; then
        log "INFO" "清理YUM缓存..."
        yum clean all
    elif [ -f /etc/arch-release ]; then
        log "INFO" "清理Pacman缓存..."
        pacman -Sc --noconfirm
    fi
    
    # 清理用户缓存
    log "INFO" "清理用户缓存..."
    for user_home in /home/*; do
        if [ -d "$user_home/.cache" ]; then
            log "INFO" "清理用户缓存: $user_home/.cache"
            find "$user_home/.cache" -type f -atime +30 -delete
        fi
    done
    
    # 显示磁盘使用情况
    log "INFO" "当前磁盘使用情况:"
    df -h | tee -a "$LOG_FILE"
    
    log "SUCCESS" "磁盘清理完成"
    return 0
}

# 执行系统检查
do_system_check() {
    log "INFO" "开始执行系统检查..."
    
    # 检查磁盘错误
    log "INFO" "检查磁盘错误..."
    for disk in $(lsblk -d -o NAME -n | grep -v loop); do
        if [[ $disk == sd* || $disk == nvme* || $disk == vd* ]]; then
            log "INFO" "检查磁盘: /dev/$disk"
            # 只读检查，不修复
            e2fsck -n "/dev/$disk" || log "WARNING" "磁盘 /dev/$disk 检查失败或有错误"
        fi
    done
    
    # 检查文件系统使用率
    log "INFO" "检查文件系统使用率..."
    df -h | grep -vE '^Filesystem|tmpfs|cdrom' | awk '{ print $5 " " $1 }' | while read -r usage mount; do
        usage_value=${usage%\%}
        if [ "$usage_value" -ge 90 ]; then
            log "WARNING" "文件系统 $mount 使用率高: $usage"
        fi
    done
    
    # 检查内存使用情况
    log "INFO" "检查内存使用情况..."
    free -h | tee -a "$LOG_FILE"
    
    # 检查负载情况
    log "INFO" "检查系统负载..."
    uptime | tee -a "$LOG_FILE"
    
    # 检查运行时间
    log "INFO" "系统运行时间:"
    uptime -p | tee -a "$LOG_FILE"
    
    # 检查失败的服务
    if check_command systemctl; then
        log "INFO" "检查失败的服务..."
        systemctl --failed | tee -a "$LOG_FILE"
    fi
    
    # 检查日志中的错误
    log "INFO" "检查系统日志中的错误..."
    journalctl -p err -b | tail -n 50 | tee -a "$LOG_FILE"
    
    log "SUCCESS" "系统检查完成"
    return 0
}

# 执行关键文件备份
do_backup() {
    log "INFO" "开始执行关键文件备份..."
    
    # 创建备份目录
    local date_str=$(date +%Y%m%d)
    local backup_path="$BACKUP_DIR/$date_str"
    mkdir -p "$backup_path"
    
    # 备份关键配置文件
    log "INFO" "备份系统配置文件..."
    tar -czf "$backup_path/etc_backup.tar.gz" /etc
    
    # 备份用户主目录
    log "INFO" "备份用户主目录配置文件..."
    for user_home in /home/*; do
        user=$(basename "$user_home")
        log "INFO" "备份用户 $user 的配置文件"
        tar -czf "$backup_path/${user}_config_backup.tar.gz" \
            "$user_home/.bashrc" "$user_home/.bash_profile" "$user_home/.ssh" \
            "$user_home/.config" 2>/dev/null || log "WARNING" "备份用户 $user 配置文件时出现错误"
    done
    
    # 备份数据库（如果存在）
    if check_command mysqldump; then
        log "INFO" "备份MySQL数据库..."
        mysqldump --all-databases -u root > "$backup_path/mysql_backup.sql" 2>/dev/null || \
            log "WARNING" "MySQL数据库备份失败，可能需要密码"
    fi
    
    if check_command pg_dumpall; then
        log "INFO" "备份PostgreSQL数据库..."
        su - postgres -c "pg_dumpall > $backup_path/postgresql_backup.sql" 2>/dev/null || \
            log "WARNING" "PostgreSQL数据库备份失败"
    fi
    
    # 创建备份摘要
    log "INFO" "创建备份摘要..."
    {
        echo "备份日期: $(date)"
        echo "主机名: $(hostname)"
        echo "操作系统: $(cat /etc/os-release | grep PRETTY_NAME | cut -d= -f2 | tr -d '"')"
        echo "备份内容:"
        ls -la "$backup_path"
        echo "磁盘使用情况:"
        df -h
    } > "$backup_path/backup_summary.txt"
    
    # 设置权限
    chmod -R 600 "$backup_path"
    
    # 删除旧备
让我继续完成自动化脚本开发基础的内容：

#### 5.1.2 Linux系统维护脚本（续）

```bash
    # 删除旧备份（保留最近30天）
    log "INFO" "清理旧备份..."
    find "$BACKUP_DIR" -type d -mtime +30 -exec rm -rf {} \; 2>/dev/null || true
    
    log "SUCCESS" "备份完成，保存在: $backup_path"
    return 0
}

# 执行日志轮转
do_log_rotation() {
    log "INFO" "开始执行日志轮转..."
    
    # 检查logrotate是否存在
    if ! check_command logrotate; then
        log "ERROR" "logrotate命令不存在，无法执行日志轮转"
        return 1
    fi
    
    # 强制执行日志轮转
    log "INFO" "强制执行logrotate..."
    logrotate -f /etc/logrotate.conf
    
    # 检查自定义日志
    log "INFO" "检查大型日志文件..."
    find /var/log -type f -size +100M | while read -r large_log; do
        log "WARNING" "发现大型日志文件: $large_log ($(du -h "$large_log" | cut -f1))"
        
        # 对大型日志文件进行压缩备份
        log "INFO" "压缩大型日志文件: $large_log"
        cp "$large_log" "$large_log.$(date +%Y%m%d)"
        gzip "$large_log.$(date +%Y%m%d)"
        
        # 清空原始日志文件
        cat /dev/null > "$large_log"
        log "INFO" "已清空并备份日志文件: $large_log"
    done
    
    log "SUCCESS" "日志轮转完成"
    return 0
}

# 主函数
main() {
    # 检查root权限
    check_root
    
    # 记录开始信息
    log "INFO" "开始系统维护..."
    log "INFO" "主机名: $(hostname)"
    log "INFO" "操作系统: $(cat /etc/os-release | grep PRETTY_NAME | cut -d= -f2 | tr -d '"')"
    log "INFO" "内核版本: $(uname -r)"
    log "INFO" "执行用户: $(whoami)"
    
    # 执行选定的任务
    if [ "$DO_UPDATE" = true ]; then
        do_system_update
    fi
    
    if [ "$DO_CLEANUP" = true ]; then
        do_disk_cleanup
    fi
    
    if [ "$DO_CHECK" = true ]; then
        do_system_check
    fi
    
    if [ "$DO_BACKUP" = true ]; then
        do_backup
    fi
    
    if [ "$DO_LOGS" = true ]; then
        do_log_rotation
    fi
    
    # 记录完成信息
    log "SUCCESS" "系统维护完成"
    
    # 显示摘要
    echo "========== 维护摘要 =========="
    echo "维护日志: $LOG_FILE"
    if [ "$DO_BACKUP" = true ]; then
        echo "备份位置: $BACKUP_DIR/$(date +%Y%m%d)"
    fi
    echo "磁盘使用情况:"
    df -h
    echo "==============================="
}

# 执行主函数
main
```

### 5.2 批量文件处理

#### 5.2.1 批量文件重命名

以下是一个PowerShell批量文件重命名脚本：

```powershell
<#
.SYNOPSIS
    批量文件重命名工具
.DESCRIPTION
    根据指定的模式批量重命名文件，支持多种重命名规则
.PARAMETER Path
    要处理的文件路径
.PARAMETER Pattern
    文件匹配模式
.PARAMETER RenameMode
    重命名模式：
    - AddPrefix: 添加前缀
    - AddSuffix: 添加后缀
    - Replace: 替换文本
    - RegexReplace: 使用正则表达式替换
    - NumberSequence: 按数字序列重命名
    - DatePrefix: 添加日期前缀
    - LowerCase: 转为小写
    - UpperCase: 转为大写
.PARAMETER RenameValue
    重命名值，根据RenameMode使用
.PARAMETER Recursive
    是否递归处理子目录
.PARAMETER WhatIf
    预览重命名结果而不实际执行
.EXAMPLE
    .\Rename-Files.ps1 -Path "C:\Photos" -Pattern "*.jpg" -RenameMode "AddPrefix" -RenameValue "Vacation_"
.NOTES
    作者: Your Name
    创建日期: 2023-01-01
    版本: 1.0
#>

[CmdletBinding(SupportsShouldProcess=$true)]
param (
    [Parameter(Mandatory=$true)]
    [string]$Path,
    
    [Parameter(Mandatory=$false)]
    [string]$Pattern = "*",
    
    [Parameter(Mandatory=$true)]
    [ValidateSet("AddPrefix", "AddSuffix", "Replace", "RegexReplace", "NumberSequence", "DatePrefix", "LowerCase", "UpperCase")]
    [string]$RenameMode,
    
    [Parameter(Mandatory=$false)]
    [string]$RenameValue = "",
    
    [Parameter(Mandatory=$false)]
    [switch]$Recursive,
    
    [Parameter(Mandatory=$false)]
    [switch]$WhatIf
)

# 初始化日志
function Write-Log {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet("INFO", "WARNING", "ERROR", "SUCCESS")]
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    # 输出到控制台
    switch ($Level) {
        "INFO" { Write-Host $Message }
        "WARNING" { Write-Host $Message -ForegroundColor Yellow }
        "ERROR" { Write-Host $Message -ForegroundColor Red }
        "SUCCESS" { Write-Host $Message -ForegroundColor Green }
    }
}

# 获取文件列表
function Get-FileList {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$Path,
        
        [Parameter(Mandatory=$true)]
        [string]$Pattern,
        
        [Parameter(Mandatory=$false)]
        [switch]$Recursive
    )
    
    $params = @{
        Path = $Path
        Filter = $Pattern
        File = $true
    }
    
    if ($Recursive) {
        $params.Recurse = $true
    }
    
    return Get-ChildItem @params
}

# 生成新文件名
function Get-NewFileName {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [System.IO.FileInfo]$File,
        
        [Parameter(Mandatory=$true)]
        [string]$RenameMode,
        
        [Parameter(Mandatory=$false)]
        [string]$RenameValue = "",
        
        [Parameter(Mandatory=$false)]
        [int]$SequenceNumber = 0
    )
    
    $directory = $File.DirectoryName
    $fileName = $File.Name
    $baseName = $File.BaseName
    $extension = $File.Extension
    
    switch ($RenameMode) {
        "AddPrefix" {
            $newFileName = "$RenameValue$fileName"
        }
        "AddSuffix" {
            $newFileName = "$baseName$RenameValue$extension"
        }
        "Replace" {
            if ($RenameValue -match "(.+)->(.+)") {
                $oldText = $Matches[1]
                $newText = $Matches[2]
                $newFileName = $fileName.Replace($oldText, $newText)
            }
            else {
                Write-Log "替换格式应为 'oldText->newText'" -Level "ERROR"
                return $null
            }
        }
        "RegexReplace" {
            if ($RenameValue -match "(.+)->(.+)") {
                $pattern = $Matches[1]
                $replacement = $Matches[2]
                $newFileName = [regex]::Replace($fileName, $pattern, $replacement)
            }
            else {
                Write-Log "正则替换格式应为 'pattern->replacement'" -Level "ERROR"
                return $null
            }
        }
        "NumberSequence" {
            $format = "D" + $RenameValue.Length
            $number = $SequenceNumber.ToString($format)
            if ($RenameValue -eq "") {
                $newFileName = "$number$extension"
            }
            else {
                $newFileName = "$RenameValue$number$extension"
            }
        }
        "DatePrefix" {
            $date = Get-Date -Format "yyyyMMdd"
            if ($RenameValue -ne "") {
                $date = Get-Date -Format $RenameValue
            }
            $newFileName = "$date`_$fileName"
        }
        "LowerCase" {
            $newFileName = $fileName.ToLower()
        }
        "UpperCase" {
            $newFileName = $fileName.ToUpper()
        }
        default {
            Write-Log "未知的重命名模式: $RenameMode" -Level "ERROR"
            return $null
        }
    }
    
    return Join-Path -Path $directory -ChildPath $newFileName
}

# 重命名文件
function Rename-FileWithMode {
    [CmdletBinding(SupportsShouldProcess=$true)]
    param (
        [Parameter(Mandatory=$true)]
        [System.IO.FileInfo[]]$Files,
        
        [Parameter(Mandatory=$true)]
        [string]$RenameMode,
        
        [Parameter(Mandatory=$false)]
        [string]$RenameValue = ""
    )
    
    $renamedCount = 0
    $errorCount = 0
    $sequenceNumber = 1
    
    foreach ($file in $Files) {
        $newPath = Get-NewFileName -File $file -RenameMode $RenameMode -RenameValue $RenameValue -SequenceNumber $sequenceNumber
        
        if ($null -eq $newPath) {
            $errorCount++
            continue
        }
        
        # 检查新文件名是否已存在
        if (Test-Path -Path $newPath) {
            Write-Log "无法重命名 '$($file.FullName)' 到 '$newPath'，目标文件已存在" -Level "WARNING"
            $errorCount++
            continue
        }
        
        if ($PSCmdlet.ShouldProcess($file.FullName, "重命名为 $newPath")) {
            try {
                Rename-Item -Path $file.FullName -NewName (Split-Path -Path $newPath -Leaf) -ErrorAction Stop
                Write-Log "已重命名: '$($file.FullName)' -> '$(Split-Path -Path $newPath -Leaf)'" -Level "SUCCESS"
                $renamedCount++
            }
            catch {
                Write-Log "重命名失败: '$($file.FullName)' -> '$(Split-Path -Path $newPath -Leaf)': $_" -Level "ERROR"
                $errorCount++
            }
        }
        else {
            Write-Log "将重命名: '$($file.FullName)' -> '$(Split-Path -Path $newPath -Leaf)'" -Level "INFO"
            $renamedCount++
        }
        
        $sequenceNumber++
    }
    
    return @{
        RenamedCount = $renamedCount
        ErrorCount = $errorCount
    }
}

# 主函数
function Main {
    [CmdletBinding()]
    param()
    
    # 验证路径
    if (-not (Test-Path -Path $Path)) {
        Write-Log "路径不存在: $Path" -Level "ERROR"
        return
    }
    
    # 获取文件列表
    Write-Log "获取文件列表..." -Level "INFO"
    $files = Get-FileList -Path $Path -Pattern $Pattern -Recursive:$Recursive
    
    if ($files.Count -eq 0) {
        Write-Log "没有找到匹配的文件" -Level "WARNING"
        return
    }
    
    Write-Log "找到 $($files.Count) 个文件" -Level "INFO"
    
    # 执行重命名
    Write-Log "开始重命名文件..." -Level "INFO"
    $result = Rename-FileWithMode -Files $files -RenameMode $RenameMode -RenameValue $RenameValue -WhatIf:$WhatIf
    
    # 显示结果
    if ($WhatIf) {
        Write-Log "预览模式: 将重命名 $($result.RenamedCount) 个文件，$($result.ErrorCount) 个错误" -Level "INFO"
    }
    else {
        Write-Log "已重命名 $($result.RenamedCount) 个文件，$($result.ErrorCount) 个错误" -Level "SUCCESS"
    }
}

# 执行主函数
Main
```

#### 5.2.2 批量文件内容替换

以下是一个PowerShell批量文件内容替换脚本：

```powershell
<#
.SYNOPSIS
    批量文件内容替换工具
.DESCRIPTION
    在多个文件中查找并替换文本内容，支持普通文本和正则表达式
.PARAMETER Path
    要处理的文件路径
.PARAMETER Pattern
    文件匹配模式
.PARAMETER FindText
    要查找的文本
.PARAMETER ReplaceText
    替换为的文本
.PARAMETER UseRegex
    是否使用正则表达式
.PARAMETER CaseSensitive
    是否区分大小写
.PARAMETER Recursive
    是否递归处理子目录
.PARAMETER Encoding
    文件编码
.PARAMETER BackupExtension
    备份文件扩展名，如果指定则创建备份
.PARAMETER WhatIf
    预览替换结果而不实际执行
.EXAMPLE
    .\Replace-FileContent.ps1 -Path "C:\Projects" -Pattern "*.cs" -FindText "TODO:" -ReplaceText "FIXED:" -Recursive
.NOTES
    作者: Your Name
    创建日期: 2023-01-01
    版本: 1.0
#>

[CmdletBinding(SupportsShouldProcess=$true)]
param (
    [Parameter(Mandatory=$true)]
    [string]$Path,
    
    [Parameter(Mandatory=$false)]
    [string]$Pattern = "*",
    
    [Parameter(Mandatory=$true)]
    [string]$FindText,
    
    [Parameter(Mandatory=$true)]
    [string]$ReplaceText,
    
    [Parameter(Mandatory=$false)]
    [switch]$UseRegex,
    
    [Parameter(Mandatory=$false)]
    [switch]$CaseSensitive,
    
    [Parameter(Mandatory=$false)]
    [switch]$Recursive,
    
    [Parameter(Mandatory=$false)]
    [ValidateSet("UTF8", "UTF7", "UTF32", "Unicode", "ASCII", "Default")]
    [string]$Encoding = "UTF8",
    
    [Parameter(Mandatory=$false)]
    [string]$BackupExtension = "",
    
    [Parameter(Mandatory=$false)]
    [switch]$WhatIf
)

# 初始化日志
function Write-Log {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet("INFO", "WARNING", "ERROR", "SUCCESS")]
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    # 输出到控制台
    switch ($Level) {
        "INFO" { Write-Host $Message }
        "WARNING" { Write-Host $Message -ForegroundColor Yellow }
        "ERROR" { Write-Host $Message -ForegroundColor Red }
        "SUCCESS" { Write-Host $Message -ForegroundColor Green }
    }
}

# 获取文件列表
function Get-FileList {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$Path,
        
        [Parameter(Mandatory=$true)]
        [string]$Pattern,
        
        [Parameter(Mandatory=$false)]
        [switch]$Recursive
    )
    
    $params = @{
        Path = $Path
        Filter = $Pattern
        File = $true
    }
    
    if ($Recursive) {
        $params.Recurse = $true
    }
    
    return Get-ChildItem @params
}

# 创建文件备份
function Backup-File {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$FilePath,
        
        [Parameter(Mandatory=$true)]
        [string]$BackupExtension
    )
    
    $backupPath = "$FilePath$BackupExtension"
    
    try {
        Copy-Item -Path $FilePath -Destination $backupPath -Force
        return $true
    }
    catch {
        Write-Log "创建备份失败: $FilePath -> $backupPath: $_" -Level "ERROR"
        return $false
    }
}

# 替换文件内容
function Replace-Content {
    [CmdletBinding(SupportsShouldProcess=$true)]
    param (
        [Parameter(Mandatory=$true)]
        [System.IO.FileInfo]$File,
        
        [Parameter(Mandatory=$true)]
        [string]$FindText,
        
        [Parameter(Mandatory=$true)]
        [string]$ReplaceText,
        
        [Parameter(Mandatory=$false)]
        [switch]$UseRegex,
        
        [Parameter(Mandatory=$false)]
        [switch]$CaseSensitive,
        
        [Parameter(Mandatory=$false)]
        [string]$Encoding = "UTF8",
        
        [Parameter(Mandatory=$false)]
        [string]$BackupExtension = ""
    )
    
    try {
        # 读取文件内容
        $content = Get-Content -Path $File.FullName -Raw
        
        # 检查文件是否包含要查找的文本
        $containsText = $false
        $replacementCount = 0
        
        if ($UseRegex) {
            $regexOptions = [System.Text.RegularExpressions.RegexOptions]::None
            if (-not $CaseSensitive) {
                $regexOptions = [System.Text.RegularExpressions.RegexOptions]::IgnoreCase
            }
            
            $regex = [regex]::new($FindText, $regexOptions)
            $matches = $regex.Matches($content)
            $containsText = $matches.Count -gt 0
            $replacementCount = $matches.Count
            
            if ($containsText) {
                $newContent = $regex.Replace($content, $ReplaceText)
            }
        }
        else {
            $compareOptions = [System.StringComparison]::Ordinal
            if (-not $CaseSensitive) {
                $compareOptions = [System.StringComparison]::OrdinalIgnoreCase
            }
            
            $containsText = $content.IndexOf($FindText, $compareOptions) -ge 0
            
            if ($containsText) {
                # 计算替换次数
                $tempContent = $content
                $count = 0
                while ($tempContent.IndexOf($FindText, $compareOptions) -ge 0) {
                    $tempContent = $tempContent.Substring($tempContent.IndexOf($FindText, $compareOptions) + $FindText.Length)
                    $count++
                }
                $replacementCount = $count
                
                # 执行替换
                if ($CaseSensitive) {
                    $newContent = $content.Replace($FindText, $ReplaceText)
                }
                else {
                    $newContent = [regex]::Replace($content, [regex]::Escape($FindText), $ReplaceText, [System.Text.RegularExpressions.RegexOptions]::IgnoreCase)
                }
            }
        }
        
        if ($containsText) {
            if ($PSCmdlet.ShouldProcess($File.FullName, "替换内容")) {
                # 创建备份
                if ($BackupExtension -ne "") {
                    Backup-File -FilePath $File.FullName -BackupExtension $BackupExtension
                }
                
                # 保存新内容
                $encodingObj = switch ($Encoding) {
                    "UTF8" { [System.Text.Encoding]::UTF8 }
                    "UTF7" { [System.Text.Encoding]::UTF7 }
                    "UTF32" { [System.Text.Encoding]::UTF32 }
                    "Unicode" { [System.Text.Encoding]::Unicode }
                    "ASCII" { [System.Text.Encoding]::ASCII }
                    "Default" { [System.Text.Encoding]::Default }
                }
                
                [System.IO.File]::WriteAllText($File.FullName, $newContent, $encodingObj)
                
                return @{
                    Success = $true
                    ReplacementCount = $replacementCount
                }
            }
            else {
                return @{
                    Success = $true
                    ReplacementCount = $replacementCount
                    WhatIf = $true
                }
            }
        }
        
        return @{
            Success = $true
            ReplacementCount = 0
        }
    }
    catch {
        Write-Log "处理文件失败: $($File.FullName): $_" -Level "ERROR"
        return @{
            Success = $false
            Error = $_
        }
    }
}

# 主函数
function Main {
    [CmdletBinding()]
    param()
    
    # 验证路径
    if (-not (Test-Path -Path $Path)) {
        Write-Log "路径不存在: $Path" -Level "ERROR"
        return
    }
    
    # 获取文件列表
    Write-Log "获取文件列表..." -Level "INFO"
    $files = Get-FileList -Path $Path -Pattern $Pattern -Recursive:$Recursive
    
    if ($files.Count -eq 0) {
        Write-Log "没有找到匹配的文件" -Level "WARNING"
        return
    }
    
    Write-Log "找到 $($files.Count) 个文件" -Level "INFO"
    
    # 显示替换信息
    $regexInfo = if ($UseRegex) { "正则表达式" } else { "普通文本" }
    $caseInfo = if ($CaseSensitive) { "区分大小写" } else { "不区分大小写" }
    Write-Log "查找: '$FindText' (使用$regexInfo, $caseInfo)" -Level "INFO"
    Write-Log "替换为: '$ReplaceText'" -Level "INFO"
    
    # 执行替换
    $processedCount = 0
    $replacedCount = 0
    $totalReplacements = 0
    $errorCount = 0
    
    foreach ($file in $files) {
        Write-Log "处理文件: $($file.FullName)" -Level "INFO"
        
        $result = Replace-Content -File $file -FindText $FindText -ReplaceText $ReplaceText `
                  -UseRegex:$UseRegex -CaseSensitive:$CaseSensitive -Encoding $Encoding `
                  -BackupExtension $BackupExtension -WhatIf:$WhatIf
        
        $processedCount++
        
        if ($result.Success) {
            if ($result.ReplacementCount -gt 0) {
                $replacedCount++
                $totalReplacements += $result.ReplacementCount
                
                if ($result.ContainsKey("WhatIf") -and $result.WhatIf) {
                    Write-Log "将替换 $($result.ReplacementCount) 处内容" -Level "INFO"
                }
                else {
                    Write-Log "已替换 $($result.ReplacementCount) 处内容" -Level "SUCCESS"
                }
            }
        }
        else {
            $errorCount++
        }
    }
    
    # 显示结果
    if ($WhatIf) {
        Write-Log "预览模式: 将处理 $processedCount 个文件，替换 $replacedCount 个文件中的 $totalReplacements 处内容，$errorCount 个错误" -Level "INFO"
    }
    else {
        Write-Log "已处理 $processedCount 个文件，替换 $replacedCount 个文件中的 $totalReplacements 处内容，$errorCount 个错误" -Level "SUCCESS"
    }
}

# 执行主函数
Main
```

### 5.3 自动化部署

#### 5.3.1 Web应用部署脚本

以下是一个PowerShell Web应用部署脚本：

```powershell
<#
.SYNOPSIS
    Web应用自动化部署脚本
.DESCRIPTION
    自动化部署Web应用到IIS服务器，包括：
    - 备份现有应用
    - 停止应用池
    - 部署新版本
    - 配置IIS设置
    - 启动应用池
    - 验证部署
.PARAMETER SiteName
    IIS站点名称
.PARAMETER AppPoolName
    IIS应用程序池名称
.PARAMETER SourcePath
    源代码或发布包路径
.PARAMETER DestinationPath
    部署目标路径
.PARAMETER BackupPath
    备份路径
.PARAMETER ConfigPath
    配置文件路径
.PARAMETER SkipBackup
    是否跳过备份
.PARAMETER Force
    强制执行，不提示确认
.EXAMPLE
    .\Deploy-WebApp.ps1 -SiteName "MyWebApp" -AppPoolName "MyWebAppPool" -SourcePath "C:\Builds\MyWebApp" -DestinationPath "C:\inetpub\wwwroot\MyWebApp"
.NOTES
    作者: Your Name
    创建日期: 2023-01-01
    版本: 1.0
#>

[CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
param (
    [Parameter(Mandatory=$true)]
    [string]$SiteName,
    
    [Parameter(Mandatory=$false)]
    [string]$AppPoolName = "",
    
    [Parameter(Mandatory=$true)]
    [string]$SourcePath,
    
    [Parameter(Mandatory=$true)]
    [string]$DestinationPath,
    
    [Parameter(Mandatory=$false)]
    [string]$BackupPath = "",
    
    [Parameter(Mandatory=$false)]
    [string]$ConfigPath = "",
    
    [Parameter(Mandatory=$false)]
    [switch]$SkipBackup,
    
    [Parameter(Mandatory=$false)]
    [switch]$Force
)

# 导入IIS模块
Import-Module WebAdministration -ErrorAction Stop

# 初始化日志
function Write-Log {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet("INFO", "WARNING", "ERROR", "SUCCESS")]
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    # 输出到控制台
    switch ($Level) {
        "INFO" { Write-Host $Message }
        "WARNING" { Write-Host $Message -ForegroundColor Yellow }
        "ERROR" { Write-Host $Message -ForegroundColor Red }
        "SUCCESS" { Write-Host $Message -ForegroundColor Green }
    }
}

# 验证IIS站点是否存在
function Test-IISSite {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$SiteName
    )
    
    return Test-Path "IIS:\Sites\$SiteName"
}

# 验证IIS应用程序池是否存在
function Test-IISAppPool {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$AppPoolName
    )
    
    return Test-Path "IIS:\AppPools\$AppPoolName"
}

# 备份Web应用
function Backup-WebApp {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$SourcePath,
        
        [Parameter(Mandatory=$true)]
        [string]$BackupPath
    )
    
    try {
        # 创建备份目录
        if (-not (Test-Path -Path $BackupPath)) {
            New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        }
        
        # 创建带时间戳的备份目录
        $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
        $backupDir = Join-Path -Path $BackupPath -ChildPath "Backup_$timestamp"
        New-Item -Path $backupDir -ItemType Directory -Force | Out-Null
        
        # 复制文件
        Write-Log "正在备份 $SourcePath 到 $backupDir..." -Level "INFO"
        Copy-Item -Path "$SourcePath\*" -Destination $backupDir -Recurse -Force
        
        # 创建备份摘要
        $summary = @{
            BackupDate = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            SourcePath = $SourcePath
            BackupPath = $backupDir
            SiteName
让我继续完成自动化脚本开发基础的内容：

#### 5.3.1 Web应用部署脚本（续）

```powershell
        # 创建备份摘要
        $summary = @{
            BackupDate = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            SourcePath = $SourcePath
            BackupPath = $backupDir
            SiteName = $SiteName
            AppPoolName = $AppPoolName
            ComputerName = $env:COMPUTERNAME
            UserName = $env:USERNAME
        }
        
        $summaryFile = Join-Path -Path $backupDir -ChildPath "BackupSummary.json"
        $summary | ConvertTo-Json | Out-File -FilePath $summaryFile
        
        Write-Log "备份完成: $backupDir" -Level "SUCCESS"
        return $backupDir
    }
    catch {
        Write-Log "备份失败: $_" -Level "ERROR"
        throw
    }
}

# 停止IIS应用程序池
function Stop-IISAppPool {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$AppPoolName
    )
    
    try {
        $appPool = Get-Item "IIS:\AppPools\$AppPoolName" -ErrorAction Stop
        
        if ($appPool.State -eq "Started") {
            Write-Log "正在停止应用程序池 $AppPoolName..." -Level "INFO"
            Stop-WebAppPool -Name $AppPoolName
            
            # 等待应用程序池停止
            $timeout = 30
            $timer = [Diagnostics.Stopwatch]::StartNew()
            
            while ($timer.Elapsed.TotalSeconds -lt $timeout) {
                $appPool = Get-Item "IIS:\AppPools\$AppPoolName"
                if ($appPool.State -eq "Stopped") {
                    break
                }
                
                Start-Sleep -Seconds 1
            }
            
            if ($appPool.State -ne "Stopped") {
                Write-Log "应用程序池未能在 $timeout 秒内停止" -Level "WARNING"
            }
            else {
                Write-Log "应用程序池已停止" -Level "SUCCESS"
            }
        }
        else {
            Write-Log "应用程序池已经处于停止状态" -Level "INFO"
        }
    }
    catch {
        Write-Log "停止应用程序池失败: $_" -Level "ERROR"
        throw
    }
}

# 部署Web应用
function Deploy-WebApp {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$SourcePath,
        
        [Parameter(Mandatory=$true)]
        [string]$DestinationPath
    )
    
    try {
        # 确保目标目录存在
        if (-not (Test-Path -Path $DestinationPath)) {
            New-Item -Path $DestinationPath -ItemType Directory -Force | Out-Null
        }
        
        # 清空目标目录（保留特定文件夹）
        Write-Log "清空目标目录 $DestinationPath..." -Level "INFO"
        $excludeFolders = @("App_Data", "logs", "uploads")
        
        Get-ChildItem -Path $DestinationPath -Exclude $excludeFolders | Remove-Item -Recurse -Force
        
        # 复制新文件
        Write-Log "正在部署文件从 $SourcePath 到 $DestinationPath..." -Level "INFO"
        Copy-Item -Path "$SourcePath\*" -Destination $DestinationPath -Recurse -Force
        
        Write-Log "文件部署完成" -Level "SUCCESS"
    }
    catch {
        Write-Log "部署文件失败: $_" -Level "ERROR"
        throw
    }
}

# 应用配置文件
function Apply-Configuration {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$ConfigPath,
        
        [Parameter(Mandatory=$true)]
        [string]$DestinationPath
    )
    
    try {
        if (-not (Test-Path -Path $ConfigPath)) {
            Write-Log "配置文件不存在: $ConfigPath" -Level "WARNING"
            return
        }
        
        Write-Log "正在应用配置文件..." -Level "INFO"
        
        # 获取所有配置文件
        $configFiles = Get-ChildItem -Path $ConfigPath -Recurse -File
        
        foreach ($file in $configFiles) {
            # 计算相对路径
            $relativePath = $file.FullName.Substring($ConfigPath.Length).TrimStart('\')
            $targetPath = Join-Path -Path $DestinationPath -ChildPath $relativePath
            
            # 确保目标目录存在
            $targetDir = Split-Path -Path $targetPath -Parent
            if (-not (Test-Path -Path $targetDir)) {
                New-Item -Path $targetDir -ItemType Directory -Force | Out-Null
            }
            
            # 复制配置文件
            Copy-Item -Path $file.FullName -Destination $targetPath -Force
            Write-Log "已应用配置: $relativePath" -Level "INFO"
        }
        
        Write-Log "配置应用完成" -Level "SUCCESS"
    }
    catch {
        Write-Log "应用配置失败: $_" -Level "ERROR"
        throw
    }
}

# 启动IIS应用程序池
function Start-IISAppPool {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$AppPoolName
    )
    
    try {
        $appPool = Get-Item "IIS:\AppPools\$AppPoolName" -ErrorAction Stop
        
        if ($appPool.State -ne "Started") {
            Write-Log "正在启动应用程序池 $AppPoolName..." -Level "INFO"
            Start-WebAppPool -Name $AppPoolName
            
            # 等待应用程序池启动
            $timeout = 30
            $timer = [Diagnostics.Stopwatch]::StartNew()
            
            while ($timer.Elapsed.TotalSeconds -lt $timeout) {
                $appPool = Get-Item "IIS:\AppPools\$AppPoolName"
                if ($appPool.State -eq "Started") {
                    break
                }
                
                Start-Sleep -Seconds 1
            }
            
            if ($appPool.State -ne "Started") {
                Write-Log "应用程序池未能在 $timeout 秒内启动" -Level "WARNING"
            }
            else {
                Write-Log "应用程序池已启动" -Level "SUCCESS"
            }
        }
        else {
            Write-Log "应用程序池已经处于启动状态" -Level "INFO"
        }
    }
    catch {
        Write-Log "启动应用程序池失败: $_" -Level "ERROR"
        throw
    }
}

# 验证部署
function Test-Deployment {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$SiteName
    )
    
    try {
        # 获取站点绑定信息
        $site = Get-Website -Name $SiteName
        $bindings = $site.bindings.Collection
        
        if ($bindings.Count -eq 0) {
            Write-Log "站点没有绑定信息，无法验证" -Level "WARNING"
            return $false
        }
        
        # 尝试访问站点
        $binding = $bindings[0]
        $protocol = $binding.protocol
        $bindingInfo = $binding.bindingInformation.Split(":")
        
        $hostname = $bindingInfo[2]
        if ([string]::IsNullOrEmpty($hostname)) {
            $hostname = "localhost"
        }
        
        $port = $bindingInfo[1]
        $url = "$protocol`://$hostname"
        if ($port -ne "80" -and $port -ne "443") {
            $url += ":$port"
        }
        
        Write-Log "正在验证站点可访问性: $url" -Level "INFO"
        
        # 发送HTTP请求
        $request = [System.Net.WebRequest]::Create($url)
        $request.Timeout = 30000
        $request.Method = "HEAD"
        
        try {
            $response = $request.GetResponse()
            $statusCode = [int]$response.StatusCode
            $response.Close()
            
            if ($statusCode -ge 200 -and $statusCode -lt 400) {
                Write-Log "站点验证成功: $url 返回状态码 $statusCode" -Level "SUCCESS"
                return $true
            }
            else {
                Write-Log "站点验证失败: $url 返回状态码 $statusCode" -Level "WARNING"
                return $false
            }
        }
        catch {
            Write-Log "站点验证失败: $url - $_" -Level "WARNING"
            return $false
        }
    }
    catch {
        Write-Log "验证部署失败: $_" -Level "ERROR"
        return $false
    }
}

# 主函数
function Main {
    [CmdletBinding()]
    param()
    
    try {
        # 验证参数
        if (-not (Test-Path -Path $SourcePath)) {
            Write-Log "源路径不存在: $SourcePath" -Level "ERROR"
            return
        }
        
        # 验证IIS站点
        if (-not (Test-IISSite -SiteName $SiteName)) {
            Write-Log "IIS站点不存在: $SiteName" -Level "ERROR"
            return
        }
        
        # 如果未指定应用程序池，则获取站点的应用程序池
        if ([string]::IsNullOrEmpty($AppPoolName)) {
            $site = Get-Item "IIS:\Sites\$SiteName"
            $AppPoolName = $site.applicationPool
            Write-Log "使用站点的应用程序池: $AppPoolName" -Level "INFO"
        }
        
        # 验证应用程序池
        if (-not (Test-IISAppPool -AppPoolName $AppPoolName)) {
            Write-Log "IIS应用程序池不存在: $AppPoolName" -Level "ERROR"
            return
        }
        
        # 如果未指定备份路径，则使用默认路径
        if ([string]::IsNullOrEmpty($BackupPath)) {
            $BackupPath = "C:\Backups\$SiteName"
            Write-Log "使用默认备份路径: $BackupPath" -Level "INFO"
        }
        
        # 确认部署
        if (-not $Force) {
            $confirmation = Read-Host "确认部署 $SiteName 到 $DestinationPath? (Y/N)"
            if ($confirmation -ne "Y" -and $confirmation -ne "y") {
                Write-Log "部署已取消" -Level "WARNING"
                return
            }
        }
        
        # 开始部署
        Write-Log "开始部署 $SiteName..." -Level "INFO"
        
        # 备份现有应用
        if (-not $SkipBackup -and (Test-Path -Path $DestinationPath)) {
            $backupDir = Backup-WebApp -SourcePath $DestinationPath -BackupPath $BackupPath
        }
        
        # 停止应用程序池
        Stop-IISAppPool -AppPoolName $AppPoolName
        
        # 部署新版本
        Deploy-WebApp -SourcePath $SourcePath -DestinationPath $DestinationPath
        
        # 应用配置文件
        if (-not [string]::IsNullOrEmpty($ConfigPath)) {
            Apply-Configuration -ConfigPath $ConfigPath -DestinationPath $DestinationPath
        }
        
        # 启动应用程序池
        Start-IISAppPool -AppPoolName $AppPoolName
        
        # 验证部署
        $success = Test-Deployment -SiteName $SiteName
        
        if ($success) {
            Write-Log "部署完成: $SiteName" -Level "SUCCESS"
        }
        else {
            Write-Log "部署可能存在问题，请手动验证" -Level "WARNING"
        }
    }
    catch {
        Write-Log "部署过程中发生错误: $_" -Level "ERROR"
        Write-Log $_.ScriptStackTrace -Level "ERROR"
    }
}

# 执行主函数
Main
```

#### 5.3.2 数据库部署脚本

以下是一个PowerShell数据库部署脚本：

```powershell
<#
.SYNOPSIS
    SQL Server数据库部署脚本
.DESCRIPTION
    自动化部署SQL Server数据库，包括：
    - 备份现有数据库
    - 执行SQL脚本
    - 验证部署
.PARAMETER ServerInstance
    SQL Server实例名称
.PARAMETER Database
    数据库名称
.PARAMETER ScriptsPath
    SQL脚本路径
.PARAMETER BackupPath
    备份路径
.PARAMETER Credential
    SQL Server凭据
.PARAMETER SkipBackup
    是否跳过备份
.PARAMETER Force
    强制执行，不提示确认
.EXAMPLE
    .\Deploy-Database.ps1 -ServerInstance "localhost" -Database "MyDatabase" -ScriptsPath "C:\Scripts\Database"
.NOTES
    作者: Your Name
    创建日期: 2023-01-01
    版本: 1.0
#>

[CmdletBinding(SupportsShouldProcess=$true, ConfirmImpact="High")]
param (
    [Parameter(Mandatory=$true)]
    [string]$ServerInstance,
    
    [Parameter(Mandatory=$true)]
    [string]$Database,
    
    [Parameter(Mandatory=$true)]
    [string]$ScriptsPath,
    
    [Parameter(Mandatory=$false)]
    [string]$BackupPath = "",
    
    [Parameter(Mandatory=$false)]
    [System.Management.Automation.PSCredential]
    [System.Management.Automation.Credential()]
    $Credential,
    
    [Parameter(Mandatory=$false)]
    [switch]$SkipBackup,
    
    [Parameter(Mandatory=$false)]
    [switch]$Force
)

# 初始化日志
function Write-Log {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet("INFO", "WARNING", "ERROR", "SUCCESS")]
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    # 输出到控制台
    switch ($Level) {
        "INFO" { Write-Host $Message }
        "WARNING" { Write-Host $Message -ForegroundColor Yellow }
        "ERROR" { Write-Host $Message -ForegroundColor Red }
        "SUCCESS" { Write-Host $Message -ForegroundColor Green }
    }
}

# 创建SQL连接参数
function Get-SqlConnectionParameters {
    [CmdletBinding()]
    param()
    
    $params = @{
        ServerInstance = $ServerInstance
        Database = $Database
        ErrorAction = "Stop"
    }
    
    if ($Credential) {
        $params.Credential = $Credential
    }
    
    return $params
}

# 测试数据库连接
function Test-DatabaseConnection {
    [CmdletBinding()]
    param()
    
    try {
        $params = Get-SqlConnectionParameters
        $query = "SELECT @@VERSION AS Version"
        
        $result = Invoke-Sqlcmd @params -Query $query
        
        Write-Log "成功连接到 $ServerInstance - $Database" -Level "SUCCESS"
        Write-Log "SQL Server版本: $($result.Version)" -Level "INFO"
        
        return $true
    }
    catch {
        Write-Log "连接到数据库失败: $_" -Level "ERROR"
        return $false
    }
}

# 备份数据库
function Backup-Database {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$BackupPath
    )
    
    try {
        # 创建备份目录
        if (-not (Test-Path -Path $BackupPath)) {
            New-Item -Path $BackupPath -ItemType Directory -Force | Out-Null
        }
        
        # 创建带时间戳的备份文件名
        $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
        $backupFile = Join-Path -Path $BackupPath -ChildPath "$Database`_$timestamp.bak"
        
        # 执行备份
        Write-Log "正在备份数据库 $Database 到 $backupFile..." -Level "INFO"
        
        $params = Get-SqlConnectionParameters
        $query = "BACKUP DATABASE [$Database] TO DISK = N'$backupFile' WITH NOFORMAT, INIT, NAME = N'$Database-Full Database Backup', SKIP, NOREWIND, NOUNLOAD, STATS = 10"
        
        Invoke-Sqlcmd @params -Query $query
        
        Write-Log "数据库备份完成: $backupFile" -Level "SUCCESS"
        return $backupFile
    }
    catch {
        Write-Log "数据库备份失败: $_" -Level "ERROR"
        throw
    }
}

# 获取SQL脚本文件
function Get-SqlScriptFiles {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$ScriptsPath
    )
    
    try {
        if (-not (Test-Path -Path $ScriptsPath)) {
            Write-Log "脚本路径不存在: $ScriptsPath" -Level "ERROR"
            return @()
        }
        
        # 获取所有SQL脚本文件
        $scriptFiles = Get-ChildItem -Path $ScriptsPath -Filter "*.sql" -Recurse | Sort-Object Name
        
        if ($scriptFiles.Count -eq 0) {
            Write-Log "没有找到SQL脚本文件" -Level "WARNING"
        }
        else {
            Write-Log "找到 $($scriptFiles.Count) 个SQL脚本文件" -Level "INFO"
        }
        
        return $scriptFiles
    }
    catch {
        Write-Log "获取SQL脚本文件失败: $_" -Level "ERROR"
        return @()
    }
}

# 执行SQL脚本
function Invoke-SqlScripts {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [System.IO.FileInfo[]]$ScriptFiles
    )
    
    try {
        $params = Get-SqlConnectionParameters
        $successCount = 0
        $errorCount = 0
        
        foreach ($script in $ScriptFiles) {
            Write-Log "正在执行脚本: $($script.Name)" -Level "INFO"
            
            try {
                # 读取脚本内容
                $scriptContent = Get-Content -Path $script.FullName -Raw
                
                # 执行脚本
                Invoke-Sqlcmd @params -Query $scriptContent -QueryTimeout 300
                
                Write-Log "脚本执行成功: $($script.Name)" -Level "SUCCESS"
                $successCount++
            }
            catch {
                Write-Log "脚本执行失败: $($script.Name) - $_" -Level "ERROR"
                $errorCount++
                
                # 如果有任何脚本失败，则抛出异常
                throw "脚本执行失败: $($script.Name)"
            }
        }
        
        Write-Log "所有脚本执行完成: $successCount 成功, $errorCount 失败" -Level "INFO"
        
        if ($errorCount -gt 0) {
            return $false
        }
        
        return $true
    }
    catch {
        Write-Log "执行SQL脚本过程中发生错误: $_" -Level "ERROR"
        return $false
    }
}

# 验证数据库部署
function Test-DatabaseDeployment {
    [CmdletBinding()]
    param()
    
    try {
        $params = Get-SqlConnectionParameters
        
        # 检查数据库是否可用
        $query = "SELECT DATABASEPROPERTYEX('$Database', 'Status') AS Status"
        $result = Invoke-Sqlcmd @params -Query $query
        
        if ($result.Status -ne "ONLINE") {
            Write-Log "数据库状态不是ONLINE: $($result.Status)" -Level "WARNING"
            return $false
        }
        
        # 检查数据库版本或其他自定义验证
        # 这里可以添加特定于应用程序的验证逻辑
        
        Write-Log "数据库部署验证成功" -Level "SUCCESS"
        return $true
    }
    catch {
        Write-Log "数据库部署验证失败: $_" -Level "ERROR"
        return $false
    }
}

# 主函数
function Main {
    [CmdletBinding()]
    param()
    
    try {
        # 验证参数
        if (-not (Test-Path -Path $ScriptsPath)) {
            Write-Log "脚本路径不存在: $ScriptsPath" -Level "ERROR"
            return
        }
        
        # 如果未指定备份路径，则使用默认路径
        if ([string]::IsNullOrEmpty($BackupPath)) {
            $BackupPath = "C:\Backups\SQL\$Database"
            Write-Log "使用默认备份路径: $BackupPath" -Level "INFO"
        }
        
        # 测试数据库连接
        if (-not (Test-DatabaseConnection)) {
            return
        }
        
        # 获取SQL脚本文件
        $scriptFiles = Get-SqlScriptFiles -ScriptsPath $ScriptsPath
        
        if ($scriptFiles.Count -eq 0) {
            Write-Log "没有找到SQL脚本文件，部署已取消" -Level "WARNING"
            return
        }
        
        # 确认部署
        if (-not $Force) {
            $confirmation = Read-Host "确认部署 $($scriptFiles.Count) 个脚本到数据库 $Database? (Y/N)"
            if ($confirmation -ne "Y" -and $confirmation -ne "y") {
                Write-Log "部署已取消" -Level "WARNING"
                return
            }
        }
        
        # 开始部署
        Write-Log "开始部署数据库 $Database..." -Level "INFO"
        
        # 备份数据库
        if (-not $SkipBackup) {
            $backupFile = Backup-Database -BackupPath $BackupPath
        }
        
        # 执行SQL脚本
        $success = Invoke-SqlScripts -ScriptFiles $scriptFiles
        
        if (-not $success) {
            Write-Log "部署失败，请检查错误日志" -Level "ERROR"
            return
        }
        
        # 验证部署
        $success = Test-DatabaseDeployment
        
        if ($success) {
            Write-Log "数据库部署完成: $Database" -Level "SUCCESS"
        }
        else {
            Write-Log "数据库部署可能存在问题，请手动验证" -Level "WARNING"
        }
    }
    catch {
        Write-Log "部署过程中发生错误: $_" -Level "ERROR"
        Write-Log $_.ScriptStackTrace -Level "ERROR"
    }
}

# 检查SqlServer模块
if (-not (Get-Module -ListAvailable -Name SqlServer)) {
    Write-Log "SqlServer模块未安装，正在安装..." -Level "INFO"
    Install-Module -Name SqlServer -Force -Scope CurrentUser
}

# 导入SqlServer模块
Import-Module SqlServer -ErrorAction Stop

# 执行主函数
Main
```

### 5.4 监控和报告

#### 5.4.1 系统性能监控脚本

以下是一个PowerShell系统性能监控脚本：

```powershell
<#
.SYNOPSIS
    系统性能监控脚本
.DESCRIPTION
    监控系统性能指标并生成报告，包括：
    - CPU使用率
    - 内存使用率
    - 磁盘使用率和I/O
    - 网络流量
    - 进程资源使用情况
.PARAMETER MonitorDuration
    监控持续时间（分钟）
.PARAMETER SampleInterval
    采样间隔（秒）
.PARAMETER OutputPath
    输出报告路径
.PARAMETER TopProcessCount
    报告中显示的进程数量
.PARAMETER GenerateHtml
    是否生成HTML报告
.EXAMPLE
    .\Monitor-SystemPerformance.ps1 -MonitorDuration 60 -SampleInterval 5 -OutputPath "C:\Reports"
.NOTES
    作者: Your Name
    创建日期: 2023-01-01
    版本: 1.0
#>

[CmdletBinding()]
param (
    [Parameter(Mandatory=$false)]
    [int]$MonitorDuration = 10,
    
    [Parameter(Mandatory=$false)]
    [int]$SampleInterval = 5,
    
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp\PerformanceReports",
    
    [Parameter(Mandatory=$false)]
    [int]$TopProcessCount = 10,
    
    [Parameter(Mandatory=$false)]
    [switch]$GenerateHtml = $true
)

# 初始化日志
function Write-Log {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet("INFO", "WARNING", "ERROR", "SUCCESS")]
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    # 输出到控制台
    switch ($Level) {
        "INFO" { Write-Host $Message }
        "WARNING" { Write-Host $Message -ForegroundColor Yellow }
        "ERROR" { Write-Host $Message -ForegroundColor Red }
        "SUCCESS" { Write-Host $Message -ForegroundColor Green }
    }
}

# 初始化环境
function Initialize-Environment {
    [CmdletBinding()]
    param()
    
    # 创建输出目录
    if (-not (Test-Path -Path $OutputPath)) {
        New-Item -Path $OutputPath -ItemType Directory -Force | Out-Null
    }
    
    # 创建时间戳
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $reportDir = Join-Path -Path $OutputPath -ChildPath "PerformanceReport_$timestamp"
    New-Item -Path $reportDir -ItemType Directory -Force | Out-Null
    
    # 创建CSV文件路径
    $cpuCsv = Join-Path -Path $reportDir -ChildPath "CPU.csv"
    $memoryCsv = Join-Path -Path $reportDir -ChildPath "Memory.csv"
    $diskCsv = Join-Path -Path $reportDir -ChildPath "Disk.csv"
    $networkCsv = Join-Path -Path $reportDir -ChildPath "Network.csv"
    $processCsv = Join-Path -Path $reportDir -ChildPath "Process.csv"
    
    # 创建CSV文件头
    "Timestamp,CPUUsage" | Out-File -FilePath $cpuCsv -Encoding UTF8
    "Timestamp,TotalGB,UsedGB,FreeGB,UsedPercent" | Out-File -FilePath $memoryCsv -Encoding UTF8
    "Timestamp,Drive,TotalGB,FreeGB,UsedPercent,ReadBytesPerSec,WriteBytesPerSec" | Out-File -FilePath $diskCsv -Encoding UTF8
    "Timestamp,Interface,ReceivedBytesPerSec,SentBytesPerSec" | Out-File -FilePath $networkCsv -Encoding UTF8
    "Timestamp,ProcessName,ProcessId,CPUPercent,MemoryMB,ThreadCount,HandleCount" | Out-File -FilePath $processCsv -Encoding UTF8
    
    return @{
        ReportDirectory = $reportDir
        CpuCsv = $cpuCsv
        MemoryCsv = $memoryCsv
        DiskCsv = $diskCsv
        NetworkCsv = $networkCsv
        ProcessCsv = $processCsv
    }
}

# 收集CPU使用率
function Get-CpuUsage {
    [CmdletBinding()]
    param()
    
    $cpuUsage = (Get-Counter '\Processor(_Total)\% Processor Time').CounterSamples.CookedValue
    return [math]::Round($cpuUsage, 2)
}

# 收集内存使用情况
function Get-MemoryUsage {
    [CmdletBinding()]
    param()
    
    $os = Get-CimInstance -ClassName Win32_OperatingSystem
    $totalMemoryGB = [math]::Round($os.TotalVisibleMemorySize / 1MB, 2)
    $freeMemoryGB = [math]::Round($os.FreePhysicalMemory / 1MB, 2)
    $usedMemoryGB = [math]::Round($totalMemoryGB - $freeMemoryGB, 2)
    $usedPercent = [math]::Round(($usedMemoryGB / $totalMemoryGB) * 100, 2)
    
    return @{
        TotalGB = $totalMemoryGB
        UsedGB = $usedMemoryGB
        FreeGB = $freeMemoryGB
        UsedPercent = $usedPercent
    }
}

# 收集磁盘使用情况
function Get-DiskUsage {
    [CmdletBinding()]
    param()
    
    $disks = Get-CimInstance -ClassName
让我继续完成系统性能监控脚本的内容：

```powershell
# 收集磁盘使用情况
function Get-DiskUsage {
    [CmdletBinding()]
    param()
    
    $disks = Get-CimInstance -ClassName Win32_LogicalDisk -Filter "DriveType=3"
    $diskPerformance = Get-Counter '\PhysicalDisk(*)\Disk Read Bytes/sec', '\PhysicalDisk(*)\Disk Write Bytes/sec'
    
    $results = @()
    
    foreach ($disk in $disks) {
        $driveLetter = $disk.DeviceID
        $totalGB = [math]::Round($disk.Size / 1GB, 2)
        $freeGB = [math]::Round($disk.FreeSpace / 1GB, 2)
        $usedPercent = [math]::Round((($totalGB - $freeGB) / $totalGB) * 100, 2)
        
        # 获取磁盘性能计数器
        $readBytes = 0
        $writeBytes = 0
        
        foreach ($counter in $diskPerformance.CounterSamples) {
            if ($counter.Path -like "*$($driveLetter.Replace(':', ''))*" -or $counter.InstanceName -like "*$($driveLetter.Replace(':', ''))*") {
                if ($counter.Path -like "*\Disk Read Bytes/sec*") {
                    $readBytes = [math]::Round($counter.CookedValue, 2)
                }
                elseif ($counter.Path -like "*\Disk Write Bytes/sec*") {
                    $writeBytes = [math]::Round($counter.CookedValue, 2)
                }
            }
        }
        
        $results += [PSCustomObject]@{
            Drive = $driveLetter
            TotalGB = $totalGB
            FreeGB = $freeGB
            UsedPercent = $usedPercent
            ReadBytesPerSec = $readBytes
            WriteBytesPerSec = $writeBytes
        }
    }
    
    return $results
}

# 收集网络使用情况
function Get-NetworkUsage {
    [CmdletBinding()]
    param()
    
    $networkAdapters = Get-CimInstance -ClassName Win32_NetworkAdapter | Where-Object { $_.NetConnectionStatus -eq 2 }
    $networkPerformance = Get-Counter '\Network Interface(*)\Bytes Received/sec', '\Network Interface(*)\Bytes Sent/sec'
    
    $results = @()
    
    foreach ($adapter in $networkAdapters) {
        $adapterName = $adapter.Name
        $receivedBytes = 0
        $sentBytes = 0
        
        foreach ($counter in $networkPerformance.CounterSamples) {
            if ($counter.InstanceName -eq $adapterName) {
                if ($counter.Path -like "*\Bytes Received/sec*") {
                    $receivedBytes = [math]::Round($counter.CookedValue, 2)
                }
                elseif ($counter.Path -like "*\Bytes Sent/sec*") {
                    $sentBytes = [math]::Round($counter.CookedValue, 2)
                }
            }
        }
        
        $results += [PSCustomObject]@{
            Interface = $adapterName
            ReceivedBytesPerSec = $receivedBytes
            SentBytesPerSec = $sentBytes
        }
    }
    
    return $results
}

# 收集进程资源使用情况
function Get-ProcessUsage {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$false)]
        [int]$TopCount = 10
    )
    
    $processes = Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First $TopCount
    $results = @()
    
    foreach ($process in $processes) {
        $cpuPercent = 0
        if ($process.CPU) {
            $cpuPercent = [math]::Round(($process.CPU / $process.TotalProcessorTime.TotalSeconds), 2)
        }
        
        $results += [PSCustomObject]@{
            ProcessName = $process.Name
            ProcessId = $process.Id
            CPUPercent = $cpuPercent
            MemoryMB = [math]::Round($process.WorkingSet / 1MB, 2)
            ThreadCount = $process.Threads.Count
            HandleCount = $process.HandleCount
        }
    }
    
    return $results
}

# 收集性能数据
function Collect-PerformanceData {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [hashtable]$Paths,
        
        [Parameter(Mandatory=$true)]
        [int]$Duration,
        
        [Parameter(Mandatory=$true)]
        [int]$Interval,
        
        [Parameter(Mandatory=$true)]
        [int]$TopProcessCount
    )
    
    $endTime = (Get-Date).AddMinutes($Duration)
    $sampleCount = 0
    
    Write-Log "开始收集性能数据，持续 $Duration 分钟，采样间隔 $Interval 秒..." -Level "INFO"
    
    while ((Get-Date) -lt $endTime) {
        $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        $sampleCount++
        
        # 收集CPU数据
        $cpuUsage = Get-CpuUsage
        "$timestamp,$cpuUsage" | Out-File -FilePath $Paths.CpuCsv -Append -Encoding UTF8
        
        # 收集内存数据
        $memoryUsage = Get-MemoryUsage
        "$timestamp,$($memoryUsage.TotalGB),$($memoryUsage.UsedGB),$($memoryUsage.FreeGB),$($memoryUsage.UsedPercent)" | 
            Out-File -FilePath $Paths.MemoryCsv -Append -Encoding UTF8
        
        # 收集磁盘数据
        $diskUsage = Get-DiskUsage
        foreach ($disk in $diskUsage) {
            "$timestamp,$($disk.Drive),$($disk.TotalGB),$($disk.FreeGB),$($disk.UsedPercent),$($disk.ReadBytesPerSec),$($disk.WriteBytesPerSec)" | 
                Out-File -FilePath $Paths.DiskCsv -Append -Encoding UTF8
        }
        
        # 收集网络数据
        $networkUsage = Get-NetworkUsage
        foreach ($network in $networkUsage) {
            "$timestamp,$($network.Interface),$($network.ReceivedBytesPerSec),$($network.SentBytesPerSec)" | 
                Out-File -FilePath $Paths.NetworkCsv -Append -Encoding UTF8
        }
        
        # 收集进程数据
        $processUsage = Get-ProcessUsage -TopCount $TopProcessCount
        foreach ($process in $processUsage) {
            "$timestamp,$($process.ProcessName),$($process.ProcessId),$($process.CPUPercent),$($process.MemoryMB),$($process.ThreadCount),$($process.HandleCount)" | 
                Out-File -FilePath $Paths.ProcessCsv -Append -Encoding UTF8
        }
        
        # 显示进度
        $progress = [math]::Round(((Get-Date) - $endTime.AddMinutes(-$Duration)).TotalMinutes / $Duration * 100, 0)
        Write-Progress -Activity "收集性能数据" -Status "已完成 $progress%" -PercentComplete $progress
        
        # 显示当前状态
        if ($sampleCount % 5 -eq 0) {
            Write-Log "CPU: $cpuUsage%, 内存: $($memoryUsage.UsedPercent)%, 已采样: $sampleCount" -Level "INFO"
        }
        
        # 等待下一个采样间隔
        Start-Sleep -Seconds $Interval
    }
    
    Write-Progress -Activity "收集性能数据" -Completed
    Write-Log "性能数据收集完成，共 $sampleCount 个样本" -Level "SUCCESS"
}

# 生成HTML报告
function Generate-HtmlReport {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [hashtable]$Paths
    )
    
    Write-Log "正在生成HTML报告..." -Level "INFO"
    
    $reportFile = Join-Path -Path $Paths.ReportDirectory -ChildPath "PerformanceReport.html"
    
    # 读取CSV数据
    $cpuData = Import-Csv -Path $Paths.CpuCsv
    $memoryData = Import-Csv -Path $Paths.MemoryCsv
    $diskData = Import-Csv -Path $Paths.DiskCsv
    $networkData = Import-Csv -Path $Paths.NetworkCsv
    $processData = Import-Csv -Path $Paths.ProcessCsv
    
    # 计算摘要数据
    $cpuAvg = [math]::Round(($cpuData | Measure-Object -Property CPUUsage -Average).Average, 2)
    $cpuMax = [math]::Round(($cpuData | Measure-Object -Property CPUUsage -Maximum).Maximum, 2)
    
    $memoryAvg = [math]::Round(($memoryData | Measure-Object -Property UsedPercent -Average).Average, 2)
    $memoryMax = [math]::Round(($memoryData | Measure-Object -Property UsedPercent -Maximum).Maximum, 2)
    
    $diskSummary = $diskData | Group-Object -Property Drive | ForEach-Object {
        $drive = $_.Name
        $usedAvg = [math]::Round(($_.Group | Measure-Object -Property UsedPercent -Average).Average, 2)
        $readAvg = [math]::Round(($_.Group | Measure-Object -Property ReadBytesPerSec -Average).Average / 1KB, 2)
        $writeAvg = [math]::Round(($_.Group | Measure-Object -Property WriteBytesPerSec -Average).Average / 1KB, 2)
        
        [PSCustomObject]@{
            Drive = $drive
            UsedPercentAvg = $usedAvg
            ReadKBPerSecAvg = $readAvg
            WriteKBPerSecAvg = $writeAvg
        }
    }
    
    $networkSummary = $networkData | Group-Object -Property Interface | ForEach-Object {
        $interface = $_.Name
        $receivedAvg = [math]::Round(($_.Group | Measure-Object -Property ReceivedBytesPerSec -Average).Average / 1KB, 2)
        $sentAvg = [math]::Round(($_.Group | Measure-Object -Property SentBytesPerSec -Average).Average / 1KB, 2)
        
        [PSCustomObject]@{
            Interface = $interface
            ReceivedKBPerSecAvg = $receivedAvg
            SentKBPerSecAvg = $sentAvg
        }
    }
    
    $processSummary = $processData | Group-Object -Property ProcessName | ForEach-Object {
        $processName = $_.Name
        $cpuAvg = [math]::Round(($_.Group | Measure-Object -Property CPUPercent -Average).Average, 2)
        $memoryAvg = [math]::Round(($_.Group | Measure-Object -Property MemoryMB -Average).Average, 2)
        
        [PSCustomObject]@{
            ProcessName = $processName
            CPUPercentAvg = $cpuAvg
            MemoryMBAvg = $memoryAvg
            Count = $_.Count
        }
    } | Sort-Object -Property CPUPercentAvg -Descending | Select-Object -First 10
    
    # 生成HTML报告
    $html = @"
<!DOCTYPE html>
<html>
<head>
    <title>系统性能报告</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1, h2, h3 { color: #2c3e50; }
        table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .summary { display: flex; flex-wrap: wrap; }
        .summary-box { border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin: 10px; flex: 1; min-width: 200px; }
        .chart-container { width: 100%; height: 300px; margin-bottom: 30px; }
        .warning { color: orange; }
        .critical { color: red; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <h1>系统性能报告</h1>
    <p>报告生成时间: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")</p>
    <p>计算机名: $env:COMPUTERNAME</p>
    <p>操作系统: $(Get-CimInstance -ClassName Win32_OperatingSystem | Select-Object -ExpandProperty Caption)</p>
    <p>监控持续时间: $MonitorDuration 分钟，采样间隔: $SampleInterval 秒</p>
    
    <h2>性能摘要</h2>
    <div class="summary">
        <div class="summary-box">
            <h3>CPU</h3>
            <p>平均使用率: $cpuAvg%</p>
            <p>最大使用率: $cpuMax%</p>
        </div>
        <div class="summary-box">
            <h3>内存</h3>
            <p>平均使用率: $memoryAvg%</p>
            <p>最大使用率: $memoryMax%</p>
            <p>总内存: $($memoryData[0].TotalGB) GB</p>
        </div>
    </div>
    
    <h2>CPU使用率</h2>
    <div class="chart-container">
        <canvas id="cpuChart"></canvas>
    </div>
    
    <h2>内存使用率</h2>
    <div class="chart-container">
        <canvas id="memoryChart"></canvas>
    </div>
    
    <h2>磁盘使用情况</h2>
    <table>
        <tr>
            <th>驱动器</th>
            <th>平均使用率</th>
            <th>平均读取 (KB/s)</th>
            <th>平均写入 (KB/s)</th>
        </tr>
"@

    foreach ($disk in $diskSummary) {
        $usedClass = ""
        if ($disk.UsedPercentAvg -gt 90) {
            $usedClass = "critical"
        }
        elseif ($disk.UsedPercentAvg -gt 80) {
            $usedClass = "warning"
        }
        
        $html += @"
        <tr>
            <td>$($disk.Drive)</td>
            <td class="$usedClass">$($disk.UsedPercentAvg)%</td>
            <td>$($disk.ReadKBPerSecAvg)</td>
            <td>$($disk.WriteKBPerSecAvg)</td>
        </tr>
"@
    }

    $html += @"
    </table>
    
    <h2>网络使用情况</h2>
    <table>
        <tr>
            <th>接口</th>
            <th>平均接收 (KB/s)</th>
            <th>平均发送 (KB/s)</th>
        </tr>
"@

    foreach ($network in $networkSummary) {
        $html += @"
        <tr>
            <td>$($network.Interface)</td>
            <td>$($network.ReceivedKBPerSecAvg)</td>
            <td>$($network.SentKBPerSecAvg)</td>
        </tr>
"@
    }

    $html += @"
    </table>
    
    <h2>进程资源使用情况 (Top 10)</h2>
    <table>
        <tr>
            <th>进程名</th>
            <th>平均CPU使用率</th>
            <th>平均内存使用 (MB)</th>
            <th>出现次数</th>
        </tr>
"@

    foreach ($process in $processSummary) {
        $cpuClass = ""
        if ($process.CPUPercentAvg -gt 50) {
            $cpuClass = "critical"
        }
        elseif ($process.CPUPercentAvg -gt 20) {
            $cpuClass = "warning"
        }
        
        $html += @"
        <tr>
            <td>$($process.ProcessName)</td>
            <td class="$cpuClass">$($process.CPUPercentAvg)%</td>
            <td>$($process.MemoryMBAvg)</td>
            <td>$($process.Count)</td>
        </tr>
"@
    }

    $html += @"
    </table>
    
    <script>
        // CPU图表
        var cpuCtx = document.getElementById('cpuChart').getContext('2d');
        var cpuChart = new Chart(cpuCtx, {
            type: 'line',
            data: {
                labels: [$(($cpuData | ForEach-Object { "'" + $_.Timestamp.Substring(11) + "'" }) -join ',')],
                datasets: [{
                    label: 'CPU使用率 (%)',
                    data: [$(($cpuData | ForEach-Object { $_.CPUUsage }) -join ',')],
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100
                    }
                }
            }
        });
        
        // 内存图表
        var memoryCtx = document.getElementById('memoryChart').getContext('2d');
        var memoryChart = new Chart(memoryCtx, {
            type: 'line',
            data: {
                labels: [$(($memoryData | ForEach-Object { "'" + $_.Timestamp.Substring(11) + "'" }) -join ',')],
                datasets: [{
                    label: '内存使用率 (%)',
                    data: [$(($memoryData | ForEach-Object { $_.UsedPercent }) -join ',')],
                    borderColor: 'rgba(153, 102, 255, 1)',
                    backgroundColor: 'rgba(153, 102, 255, 0.2)',
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100
                    }
                }
            }
        });
    </script>
</body>
</html>
"@

    # 保存HTML报告
    $html | Out-File -FilePath $reportFile -Encoding UTF8
    
    Write-Log "HTML报告已生成: $reportFile" -Level "SUCCESS"
    return $reportFile
}

# 主函数
function Main {
    [CmdletBinding()]
    param()
    
    try {
        # 初始化环境
        $paths = Initialize-Environment
        
        # 收集性能数据
        Collect-PerformanceData -Paths $paths -Duration $MonitorDuration -Interval $SampleInterval -TopProcessCount $TopProcessCount
        
        # 生成HTML报告
        if ($GenerateHtml) {
            $reportFile = Generate-HtmlReport -Paths $paths
            
            # 打开报告
            Invoke-Item $reportFile
        }
        
        Write-Log "性能监控完成，报告保存在: $($paths.ReportDirectory)" -Level "SUCCESS"
    }
    catch {
        Write-Log "性能监控过程中发生错误: $_" -Level "ERROR"
        Write-Log $_.ScriptStackTrace -Level "ERROR"
    }
}

# 执行主函数
Main
```

#### 5.4.2 日志分析脚本

以下是一个PowerShell日志分析脚本：

```powershell
<#
.SYNOPSIS
    日志文件分析脚本
.DESCRIPTION
    分析日志文件并生成摘要报告，包括：
    - 错误和警告统计
    - 按时间段分布
    - 常见错误模式
    - 异常趋势分析
.PARAMETER LogPath
    日志文件路径或目录
.PARAMETER Pattern
    日志文件匹配模式
.PARAMETER OutputPath
    输出报告路径
.PARAMETER ErrorPatterns
    错误模式正则表达式
.PARAMETER WarningPatterns
    警告模式正则表达式
.PARAMETER TimeRange
    分析的时间范围（天）
.PARAMETER GenerateHtml
    是否生成HTML报告
.EXAMPLE
    .\Analyze-Logs.ps1 -LogPath "C:\Logs" -Pattern "*.log" -OutputPath "C:\Reports"
.NOTES
    作者: Your Name
    创建日期: 2023-01-01
    版本: 1.0
#>

[CmdletBinding()]
param (
    [Parameter(Mandatory=$true)]
    [string]$LogPath,
    
    [Parameter(Mandatory=$false)]
    [string]$Pattern = "*.log",
    
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp\LogReports",
    
    [Parameter(Mandatory=$false)]
    [string[]]$ErrorPatterns = @("ERROR", "FATAL", "EXCEPTION", "FAIL"),
    
    [Parameter(Mandatory=$false)]
    [string[]]$WarningPatterns = @("WARN", "WARNING"),
    
    [Parameter(Mandatory=$false)]
    [int]$TimeRange = 7,
    
    [Parameter(Mandatory=$false)]
    [switch]$GenerateHtml = $true
)

# 初始化日志
function Write-Log {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet("INFO", "WARNING", "ERROR", "SUCCESS")]
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    # 输出到控制台
    switch ($Level) {
        "INFO" { Write-Host $Message }
        "WARNING" { Write-Host $Message -ForegroundColor Yellow }
        "ERROR" { Write-Host $Message -ForegroundColor Red }
        "SUCCESS" { Write-Host $Message -ForegroundColor Green }
    }
}

# 初始化环境
function Initialize-Environment {
    [CmdletBinding()]
    param()
    
    # 创建输出目录
    if (-not (Test-Path -Path $OutputPath)) {
        New-Item -Path $OutputPath -ItemType Directory -Force | Out-Null
    }
    
    # 创建时间戳
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $reportDir = Join-Path -Path $OutputPath -ChildPath "LogReport_$timestamp"
    New-Item -Path $reportDir -ItemType Directory -Force | Out-Null
    
    return $reportDir
}

# 获取日志文件
function Get-LogFiles {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$LogPath,
        
        [Parameter(Mandatory=$true)]
        [string]$Pattern,
        
        [Parameter(Mandatory=$true)]
        [int]$TimeRange
    )
    
    $cutoffDate = (Get-Date).AddDays(-$TimeRange)
    
    if (Test-Path -Path $LogPath -PathType Container) {
        # 如果是目录，获取所有匹配的日志文件
        $logFiles = Get-ChildItem -Path $LogPath -Filter $Pattern -Recurse | 
                    Where-Object { $_.LastWriteTime -ge $cutoffDate }
    }
    else {
        # 如果是单个文件
        $logFiles = Get-Item -Path $LogPath | 
                    Where-Object { $_.LastWriteTime -ge $cutoffDate }
    }
    
    return $logFiles
}

# 解析日志时间戳
function Parse-LogTimestamp {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$LogLine,
        
        [Parameter(Mandatory=$false)]
        [string[]]$TimestampPatterns = @(
            # ISO 8601
            '\b(\d{4}-\d{2}-\d{2}[T ]\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?)\b',
            # 常见日志格式 yyyy-MM-dd HH:mm:ss
            '\b(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}(?:\.\d+)?)\b',
            # 常见日志格式 MM/dd/yyyy HH:mm:ss
            '\b(\d{2}/\d{2}/\d{4} \d{2}:\d{2}:\d{2}(?:\.\d+)?)\b',
            # 常见日志格式 dd/MM/yyyy HH:mm:ss
            '\b(\d{2}/\d{2}/\d{4} \d{2}:\d{2}:\d{2}(?:\.\d+)?)\b'
        )
    )
    
    foreach ($pattern in $TimestampPatterns) {
        if ($LogLine -match $pattern) {
            $timestamp = $Matches[1]
            
            try {
                $dateTime = [DateTime]::Parse($timestamp)
                return $dateTime
            }
            catch {
                # 尝试下一个模式
                continue
            }
        }
    }
    
    # 如果无法解析时间戳，返回当前时间
    return Get-Date
}

# 分析日志文件
function Analyze-LogFile {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [System.IO.FileInfo]$LogFile,
        
        [Parameter(Mandatory=$true)]
        [string[]]$ErrorPatterns,
        
        [Parameter(Mandatory=$true)]
        [string[]]$WarningPatterns
    )
    
    Write-Log "分析日志文件: $($LogFile.FullName)" -Level "INFO"
    
    # 创建结果对象
    $result = @{
        FileName = $LogFile.Name
        FilePath = $LogFile.FullName
        FileSize = $LogFile.Length
        LastWriteTime = $LogFile.LastWriteTime
        TotalLines = 0
        ErrorCount = 0
        WarningCount = 0
        Errors = @()
        Warnings = @()
        HourlyDistribution = @{}
        DailyDistribution = @{}
        ErrorPatterns = @{}
    }
    
    # 初始化小时分布
    for ($i = 0; $i -lt 24; $i++) {
        $hour = $i.ToString("00")
        $result.HourlyDistribution[$hour] = 0
    }
    
    # 读取日志文件
    $content = Get-Content -Path $LogFile.FullName -ErrorAction SilentlyContinue
    $result.TotalLines = $content.Count
    
    # 分析每一行
    foreach ($line in $content) {
        # 解析时间戳
        $timestamp = Parse-LogTimestamp -LogLine $line
        
        # 更新小时分布
        $hour = $timestamp.ToString("HH")
        $result.HourlyDistribution[$hour]++
        
        # 更新日期分布
        $date = $timestamp.ToString("yyyy-MM-dd")
        if (-not $result.DailyDistribution.ContainsKey($date)) {
            $result.DailyDistribution[$date] = 0
        }
        $result.DailyDistribution[$date]++
        
        # 检查错误模式
        $isError = $false
        foreach ($pattern in $ErrorPatterns) {
            if ($line -match $pattern) {
                $result.ErrorCount++
                $result.Errors += [PSCustomObject]@{
                    Timestamp = $timestamp
                    Message = $line
                    Pattern = $pattern
                }
                
                # 统计错误模式
                $errorKey = $pattern
                if (-not $result.ErrorPatterns.ContainsKey($errorKey)) {
                    $result.ErrorPatterns[$errorKey] = 0
                }
                $result.ErrorPatterns[$errorKey]++
                
                $isError = $true
                break
            }
        }
        
        # 如果不是错误，检查警告模式
        if (-not $isError) {
            foreach ($pattern in $WarningPatterns) {
                if ($line -match $pattern) {
                    $result.WarningCount++
                    $result.Warnings += [PSCustomObject]@{
                        Timestamp = $timestamp
                        Message = $line
                        Pattern = $pattern
                    }
                    break
                }
            }
        }
    }
    
    Write-Log "分析完成: $($result.TotalLines) 行, $($result.ErrorCount) 错误, $($result.WarningCount) 警告" -Level "INFO"
    return $result
}

# 生成摘要报告
function Generate-SummaryReport {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [array]$LogAnalysisResults,
        
        [Parameter(Mandatory=$true)]
        [string]$ReportDirectory
    )
    
让我继续完成日志分析脚本的内容：

```powershell
# 生成摘要报告
function Generate-SummaryReport {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [array]$LogAnalysisResults,
        
        [Parameter(Mandatory=$true)]
        [string]$ReportDirectory
    )
    
    Write-Log "生成摘要报告..." -Level "INFO"
    
    # 创建摘要对象
    $summary = @{
        TotalFiles = $LogAnalysisResults.Count
        TotalLines = ($LogAnalysisResults | Measure-Object -Property TotalLines -Sum).Sum
        TotalErrors = ($LogAnalysisResults | Measure-Object -Property ErrorCount -Sum).Sum
        TotalWarnings = ($LogAnalysisResults | Measure-Object -Property WarningCount -Sum).Sum
        HourlyDistribution = @{}
        DailyDistribution = @{}
        ErrorPatterns = @{}
        TopErrors = @()
        TopWarnings = @()
        FileSummary = @()
    }
    
    # 初始化小时分布
    for ($i = 0; $i -lt 24; $i++) {
        $hour = $i.ToString("00")
        $summary.HourlyDistribution[$hour] = 0
    }
    
    # 合并所有日志文件的结果
    foreach ($result in $LogAnalysisResults) {
        # 合并小时分布
        foreach ($hour in $result.HourlyDistribution.Keys) {
            $summary.HourlyDistribution[$hour] += $result.HourlyDistribution[$hour]
        }
        
        # 合并日期分布
        foreach ($date in $result.DailyDistribution.Keys) {
            if (-not $summary.DailyDistribution.ContainsKey($date)) {
                $summary.DailyDistribution[$date] = 0
            }
            $summary.DailyDistribution[$date] += $result.DailyDistribution[$date]
        }
        
        # 合并错误模式
        foreach ($pattern in $result.ErrorPatterns.Keys) {
            if (-not $summary.ErrorPatterns.ContainsKey($pattern)) {
                $summary.ErrorPatterns[$pattern] = 0
            }
            $summary.ErrorPatterns[$pattern] += $result.ErrorPatterns[$pattern]
        }
        
        # 添加文件摘要
        $summary.FileSummary += [PSCustomObject]@{
            FileName = $result.FileName
            FileSize = $result.FileSize
            LastWriteTime = $result.LastWriteTime
            TotalLines = $result.TotalLines
            ErrorCount = $result.ErrorCount
            WarningCount = $result.WarningCount
        }
    }
    
    # 获取前10个错误
    $allErrors = $LogAnalysisResults | ForEach-Object { $_.Errors } | Sort-Object -Property Timestamp -Descending
    $summary.TopErrors = $allErrors | Select-Object -First 10
    
    # 获取前10个警告
    $allWarnings = $LogAnalysisResults | ForEach-Object { $_.Warnings } | Sort-Object -Property Timestamp -Descending
    $summary.TopWarnings = $allWarnings | Select-Object -First 10
    
    # 保存摘要为JSON
    $summaryFile = Join-Path -Path $ReportDirectory -ChildPath "Summary.json"
    $summary | ConvertTo-Json -Depth 5 | Out-File -FilePath $summaryFile -Encoding UTF8
    
    Write-Log "摘要报告已保存: $summaryFile" -Level "SUCCESS"
    return $summary
}

# 生成HTML报告
function Generate-HtmlReport {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [hashtable]$Summary,
        
        [Parameter(Mandatory=$true)]
        [string]$ReportDirectory
    )
    
    Write-Log "生成HTML报告..." -Level "INFO"
    
    $reportFile = Join-Path -Path $ReportDirectory -ChildPath "LogAnalysisReport.html"
    
    # 排序日期分布
    $sortedDailyDistribution = $Summary.DailyDistribution.GetEnumerator() | 
                              Sort-Object -Property Name | 
                              Select-Object -Property @{Name='Date';Expression={$_.Name}}, 
                                                      @{Name='Count';Expression={$_.Value}}
    
    # 排序错误模式
    $sortedErrorPatterns = $Summary.ErrorPatterns.GetEnumerator() | 
                          Sort-Object -Property Value -Descending | 
                          Select-Object -Property @{Name='Pattern';Expression={$_.Name}}, 
                                                  @{Name='Count';Expression={$_.Value}}
    
    # 生成HTML报告
    $html = @"
<!DOCTYPE html>
<html>
<head>
    <title>日志分析报告</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1, h2, h3 { color: #2c3e50; }
        table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .summary { display: flex; flex-wrap: wrap; }
        .summary-box { border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin: 10px; flex: 1; min-width: 200px; }
        .chart-container { width: 100%; height: 300px; margin-bottom: 30px; }
        .error { color: red; }
        .warning { color: orange; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <h1>日志分析报告</h1>
    <p>报告生成时间: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")</p>
    <p>分析时间范围: 最近 $TimeRange 天</p>
    
    <h2>摘要</h2>
    <div class="summary">
        <div class="summary-box">
            <h3>文件统计</h3>
            <p>分析文件数: $($Summary.TotalFiles)</p>
            <p>总行数: $($Summary.TotalLines)</p>
        </div>
        <div class="summary-box">
            <h3>错误和警告</h3>
            <p class="error">错误数: $($Summary.TotalErrors)</p>
            <p class="warning">警告数: $($Summary.TotalWarnings)</p>
        </div>
    </div>
    
    <h2>时间分布</h2>
    <div class="chart-container">
        <canvas id="hourlyChart"></canvas>
    </div>
    
    <div class="chart-container">
        <canvas id="dailyChart"></canvas>
    </div>
    
    <h2>错误模式分析</h2>
    <div class="chart-container">
        <canvas id="errorPatternChart"></canvas>
    </div>
    
    <table>
        <tr>
            <th>错误模式</th>
            <th>出现次数</th>
        </tr>
"@

    foreach ($pattern in $sortedErrorPatterns) {
        $html += @"
        <tr>
            <td>$($pattern.Pattern)</td>
            <td>$($pattern.Count)</td>
        </tr>
"@
    }

    $html += @"
    </table>
    
    <h2>最近错误 (Top 10)</h2>
    <table>
        <tr>
            <th>时间</th>
            <th>模式</th>
            <th>消息</th>
        </tr>
"@

    foreach ($error in $Summary.TopErrors) {
        $html += @"
        <tr>
            <td>$($error.Timestamp)</td>
            <td>$($error.Pattern)</td>
            <td>$($error.Message)</td>
        </tr>
"@
    }

    $html += @"
    </table>
    
    <h2>最近警告 (Top 10)</h2>
    <table>
        <tr>
            <th>时间</th>
            <th>模式</th>
            <th>消息</th>
        </tr>
"@

    foreach ($warning in $Summary.TopWarnings) {
        $html += @"
        <tr>
            <td>$($warning.Timestamp)</td>
            <td>$($warning.Pattern)</td>
            <td>$($warning.Message)</td>
        </tr>
"@
    }

    $html += @"
    </table>
    
    <h2>文件摘要</h2>
    <table>
        <tr>
            <th>文件名</th>
            <th>大小</th>
            <th>最后修改时间</th>
            <th>总行数</th>
            <th>错误数</th>
            <th>警告数</th>
        </tr>
"@

    foreach ($file in $Summary.FileSummary) {
        $html += @"
        <tr>
            <td>$($file.FileName)</td>
            <td>$('{0:N2}' -f ($file.FileSize / 1KB)) KB</td>
            <td>$($file.LastWriteTime)</td>
            <td>$($file.TotalLines)</td>
            <td class="error">$($file.ErrorCount)</td>
            <td class="warning">$($file.WarningCount)</td>
        </tr>
"@
    }

    $html += @"
    </table>
    
    <script>
        // 小时分布图表
        var hourlyCtx = document.getElementById('hourlyChart').getContext('2d');
        var hourlyChart = new Chart(hourlyCtx, {
            type: 'bar',
            data: {
                labels: [$(($Summary.HourlyDistribution.GetEnumerator() | Sort-Object -Property Name | ForEach-Object { "'" + $_.Name + "'" }) -join ',')],
                datasets: [{
                    label: '按小时分布',
                    data: [$(($Summary.HourlyDistribution.GetEnumerator() | Sort-Object -Property Name | ForEach-Object { $_.Value }) -join ',')],
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: '日志条目按小时分布'
                    }
                }
            }
        });
        
        // 日期分布图表
        var dailyCtx = document.getElementById('dailyChart').getContext('2d');
        var dailyChart = new Chart(dailyCtx, {
            type: 'line',
            data: {
                labels: [$(($sortedDailyDistribution | ForEach-Object { "'" + $_.Date + "'" }) -join ',')],
                datasets: [{
                    label: '按日期分布',
                    data: [$(($sortedDailyDistribution | ForEach-Object { $_.Count }) -join ',')],
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                scales: {
                    y: {
                        beginAtZero: true
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: '日志条目按日期分布'
                    }
                }
            }
        });
        
        // 错误模式图表
        var errorPatternCtx = document.getElementById('errorPatternChart').getContext('2d');
        var errorPatternChart = new Chart(errorPatternCtx, {
            type: 'pie',
            data: {
                labels: [$(($sortedErrorPatterns | Select-Object -First 5 | ForEach-Object { "'" + $_.Pattern + "'" }) -join ',')],
                datasets: [{
                    label: '错误模式分布',
                    data: [$(($sortedErrorPatterns | Select-Object -First 5 | ForEach-Object { $_.Count }) -join ',')],
                    backgroundColor: [
                        'rgba(255, 99, 132, 0.2)',
                        'rgba(54, 162, 235, 0.2)',
                        'rgba(255, 206, 86, 0.2)',
                        'rgba(75, 192, 192, 0.2)',
                        'rgba(153, 102, 255, 0.2)'
                    ],
                    borderColor: [
                        'rgba(255, 99, 132, 1)',
                        'rgba(54, 162, 235, 1)',
                        'rgba(255, 206, 86, 1)',
                        'rgba(75, 192, 192, 1)',
                        'rgba(153, 102, 255, 1)'
                    ],
                    borderWidth: 1
                }]
            },
            options: {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: '前5个错误模式分布'
                    }
                }
            }
        });
    </script>
</body>
</html>
"@

    # 保存HTML报告
    $html | Out-File -FilePath $reportFile -Encoding UTF8
    
    Write-Log "HTML报告已生成: $reportFile" -Level "SUCCESS"
    return $reportFile
}

# 主函数
function Main {
    [CmdletBinding()]
    param()
    
    try {
        # 初始化环境
        $reportDir = Initialize-Environment
        
        # 获取日志文件
        Write-Log "获取日志文件..." -Level "INFO"
        $logFiles = Get-LogFiles -LogPath $LogPath -Pattern $Pattern -TimeRange $TimeRange
        
        if ($logFiles.Count -eq 0) {
            Write-Log "没有找到匹配的日志文件" -Level "WARNING"
            return
        }
        
        Write-Log "找到 $($logFiles.Count) 个日志文件" -Level "INFO"
        
        # 分析日志文件
        $results = @()
        foreach ($logFile in $logFiles) {
            $result = Analyze-LogFile -LogFile $logFile -ErrorPatterns $ErrorPatterns -WarningPatterns $WarningPatterns
            $results += $result
        }
        
        # 生成摘要报告
        $summary = Generate-SummaryReport -LogAnalysisResults $results -ReportDirectory $reportDir
        
        # 生成HTML报告
        if ($GenerateHtml) {
            $reportFile = Generate-HtmlReport -Summary $summary -ReportDirectory $reportDir
            
            # 打开报告
            Invoke-Item $reportFile
        }
        
        Write-Log "日志分析完成，报告保存在: $reportDir" -Level "SUCCESS"
    }
    catch {
        Write-Log "日志分析过程中发生错误: $_" -Level "ERROR"
        Write-Log $_.ScriptStackTrace -Level "ERROR"
    }
}

# 执行主函数
Main
```

### 5.5 自动化测试

#### 5.5.1 Web应用自动化测试脚本

以下是一个使用Selenium进行Web应用自动化测试的PowerShell脚本：

```powershell
<#
.SYNOPSIS
    Web应用自动化测试脚本
.DESCRIPTION
    使用Selenium WebDriver自动化测试Web应用，包括：
    - 页面加载测试
    - 登录功能测试
    - 表单提交测试
    - 导航测试
    - 响应时间测试
.PARAMETER Url
    要测试的Web应用URL
.PARAMETER Username
    登录用户名
.PARAMETER Password
    登录密码
.PARAMETER BrowserType
    浏览器类型（Chrome, Firefox, Edge）
.PARAMETER OutputPath
    测试报告输出路径
.PARAMETER Headless
    是否使用无头模式运行浏览器
.EXAMPLE
    .\Test-WebApp.ps1 -Url "https://example.com" -Username "testuser" -Password "testpass" -BrowserType "Chrome"
.NOTES
    作者: Your Name
    创建日期: 2023-01-01
    版本: 1.0
    依赖: Selenium.WebDriver, Selenium.WebDriver.ChromeDriver
#>

[CmdletBinding()]
param (
    [Parameter(Mandatory=$true)]
    [string]$Url,
    
    [Parameter(Mandatory=$false)]
    [string]$Username = "",
    
    [Parameter(Mandatory=$false)]
    [string]$Password = "",
    
    [Parameter(Mandatory=$false)]
    [ValidateSet("Chrome", "Firefox", "Edge")]
    [string]$BrowserType = "Chrome",
    
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp\WebTestReports",
    
    [Parameter(Mandatory=$false)]
    [switch]$Headless = $false
)

# 初始化日志
function Write-Log {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet("INFO", "WARNING", "ERROR", "SUCCESS", "TEST")]
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    # 输出到控制台
    switch ($Level) {
        "INFO" { Write-Host $Message }
        "WARNING" { Write-Host $Message -ForegroundColor Yellow }
        "ERROR" { Write-Host $Message -ForegroundColor Red }
        "SUCCESS" { Write-Host $Message -ForegroundColor Green }
        "TEST" { Write-Host $Message -ForegroundColor Cyan }
    }
    
    # 添加到日志数组
    $script:testLogs += $logEntry
}

# 初始化环境
function Initialize-Environment {
    [CmdletBinding()]
    param()
    
    # 创建输出目录
    if (-not (Test-Path -Path $OutputPath)) {
        New-Item -Path $OutputPath -ItemType Directory -Force | Out-Null
    }
    
    # 创建时间戳
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $reportDir = Join-Path -Path $OutputPath -ChildPath "WebTest_$timestamp"
    New-Item -Path $reportDir -ItemType Directory -Force | Out-Null
    
    # 创建截图目录
    $screenshotDir = Join-Path -Path $reportDir -ChildPath "Screenshots"
    New-Item -Path $screenshotDir -ItemType Directory -Force | Out-Null
    
    return @{
        ReportDirectory = $reportDir
        ScreenshotDirectory = $screenshotDir
        Timestamp = $timestamp
    }
}

# 安装Selenium依赖
function Install-SeleniumDependencies {
    [CmdletBinding()]
    param()
    
    try {
        # 检查Selenium.WebDriver模块
        if (-not (Get-Package -Name "Selenium.WebDriver" -ErrorAction SilentlyContinue)) {
            Write-Log "安装Selenium.WebDriver..." -Level "INFO"
            Install-Package -Name "Selenium.WebDriver" -Source "https://www.nuget.org/api/v2" -Force | Out-Null
        }
        
        # 根据浏览器类型安装对应的驱动
        switch ($BrowserType) {
            "Chrome" {
                if (-not (Get-Package -Name "Selenium.WebDriver.ChromeDriver" -ErrorAction SilentlyContinue)) {
                    Write-Log "安装Chrome驱动..." -Level "INFO"
                    Install-Package -Name "Selenium.WebDriver.ChromeDriver" -Source "https://www.nuget.org/api/v2" -Force | Out-Null
                }
            }
            "Firefox" {
                if (-not (Get-Package -Name "Selenium.WebDriver.GeckoDriver" -ErrorAction SilentlyContinue)) {
                    Write-Log "安装Firefox驱动..." -Level "INFO"
                    Install-Package -Name "Selenium.WebDriver.GeckoDriver" -Source "https://www.nuget.org/api/v2" -Force | Out-Null
                }
            }
            "Edge" {
                if (-not (Get-Package -Name "Selenium.WebDriver.MSEdgeDriver" -ErrorAction SilentlyContinue)) {
                    Write-Log "安装Edge驱动..." -Level "INFO"
                    Install-Package -Name "Selenium.WebDriver.MSEdgeDriver" -Source "https://www.nuget.org/api/v2" -Force | Out-Null
                }
            }
        }
        
        # 加载Selenium程序集
        Add-Type -Path (Get-Package -Name "Selenium.WebDriver").Source
        
        Write-Log "Selenium依赖安装完成" -Level "SUCCESS"
        return $true
    }
    catch {
        Write-Log "安装Selenium依赖失败: $_" -Level "ERROR"
        return $false
    }
}

# 初始化WebDriver
function Initialize-WebDriver {
    [CmdletBinding()]
    param()
    
    try {
        switch ($BrowserType) {
            "Chrome" {
                $options = New-Object OpenQA.Selenium.Chrome.ChromeOptions
                if ($Headless) {
                    $options.AddArgument("--headless")
                }
                $options.AddArgument("--start-maximized")
                $options.AddArgument("--disable-extensions")
                $options.AddArgument("--disable-popup-blocking")
                $options.AddArgument("--disable-infobars")
                
                $driver = New-Object OpenQA.Selenium.Chrome.ChromeDriver($options)
            }
            "Firefox" {
                $options = New-Object OpenQA.Selenium.Firefox.FirefoxOptions
                if ($Headless) {
                    $options.AddArgument("--headless")
                }
                
                $driver = New-Object OpenQA.Selenium.Firefox.FirefoxDriver($options)
                $driver.Manage().Window.Maximize()
            }
            "Edge" {
                $options = New-Object OpenQA.Selenium.Edge.EdgeOptions
                if ($Headless) {
                    $options.AddArgument("--headless")
                }
                $options.AddArgument("--start-maximized")
                
                $driver = New-Object OpenQA.Selenium.Edge.EdgeDriver($options)
            }
        }
        
        # 设置隐式等待时间
        $driver.Manage().Timeouts().ImplicitWait = [TimeSpan]::FromSeconds(10)
        
        Write-Log "WebDriver初始化完成: $BrowserType" -Level "SUCCESS"
        return $driver
    }
    catch {
        Write-Log "初始化WebDriver失败: $_" -Level "ERROR"
        return $null
    }
}

# 截图
function Take-Screenshot {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [OpenQA.Selenium.IWebDriver]$Driver,
        
        [Parameter(Mandatory=$true)]
        [string]$ScreenshotDirectory,
        
        [Parameter(Mandatory=$true)]
        [string]$TestName
    )
    
    try {
        $screenshot = [OpenQA.Selenium.Support.Extensions.WebDriverExtensions]::TakeScreenshot($Driver)
        $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
        $filename = "$TestName`_$timestamp.png"
        $path = Join-Path -Path $ScreenshotDirectory -ChildPath $filename
        $screenshot.SaveAsFile($path, [OpenQA.Selenium.ScreenshotImageFormat]::Png)
        
        return $path
    }
    catch {
        Write-Log "截图失败: $_" -Level "ERROR"
        return $null
    }
}

# 测试页面加载
function Test-PageLoad {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [OpenQA.Selenium.IWebDriver]$Driver,
        
        [Parameter(Mandatory=$true)]
        [string]$Url,
        
        [Parameter(Mandatory=$true)]
        [string]$ScreenshotDirectory
    )
    
    $testName = "PageLoad"
    Write-Log "开始测试: $testName" -Level "TEST"
    
    $result = @{
        TestName = $testName
        Status = "Failed"
        Message = ""
        LoadTime = 0
        Screenshot = ""
    }
    
    try {
        # 记录开始时间
        $startTime = Get-Date
        
        # 导航到URL
        $Driver.Navigate().GoToUrl($Url)
        
        # 等待页面加载完成
        $wait = New-Object OpenQA.Selenium.Support.UI.WebDriverWait($Driver, [TimeSpan]::FromSeconds(30))
        $wait.Until([OpenQA.Selenium.Support.UI.ExpectedConditions]::ElementExists([OpenQA.Selenium.By]::TagName("body")))
        
        # 计算加载时间
        $endTime = Get-Date
        $loadTime = ($endTime - $startTime).TotalSeconds
        
        # 截图
        $screenshotPath = Take-Screenshot -Driver $Driver -ScreenshotDirectory $ScreenshotDirectory -TestName $testName
        
        # 更新结果
        $result.Status = "Passed"
        $result.Message = "页面成功加载，耗时: $loadTime 秒"
        $result.LoadTime = $loadTime
        $result.Screenshot = $screenshotPath
        
        Write-Log $result.Message -Level "SUCCESS"
    }
    catch {
        $result.Message = "页面加载失败: $_"
        Write-Log $result.Message -Level "ERROR"
        
        # 尝试截图
        $result.Screenshot = Take-Screenshot -Driver $Driver -ScreenshotDirectory $ScreenshotDirectory -TestName "$testName`_Error"
    }
    
    return $result
}

# 测试登录功能
function Test-Login {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [OpenQA.Selenium.IWebDriver]$Driver,
        
        [Parameter(Mandatory=$true)]
        [string]$Username,
        
        [Parameter(Mandatory=$true)]
        [string]$Password,
        
        [Parameter(Mandatory=$true)]
        [string]$ScreenshotDirectory
    )
    
    $testName = "Login"
    Write-Log "开始测试: $testName" -Level "TEST"
    
    $result = @{
        TestName = $testName
        Status = "Failed"
        Message = ""
        Screenshot = ""
    }
    
    try {
        # 查找登录表单元素
        $usernameField = $null
        $passwordField = $null
        $loginButton = $null
        
        # 尝试不同的常见登录表单元素选择器
        $usernameSelectors = @(
            [OpenQA.Selenium.By]::Id("username"),
            [OpenQA.Selenium.By]::Id("user"),
            [OpenQA.Selenium.By]::Id("email"),
            [OpenQA.Selenium.By]::Name("username"),
            [OpenQA.Selenium.By]::Name("user"),
            [OpenQA.Selenium.By]::Name("email"),
            [OpenQA.Selenium.By]::CssSelector("input[type='text']"),
            [OpenQA.Selenium.By]::CssSelector("input[type='email']")
        )
        
        $passwordSelectors = @(
            [OpenQA.Selenium.By]::Id("password"),
            [OpenQA.Selenium.By]::Id("pass"),
            [OpenQA.Selenium.By]::Name("password"),
            [OpenQA.Selenium.By]::Name("pass"),
            [OpenQA.Selenium.By]::CssSelector("input[type='password']")
        )
        
        $loginButtonSelectors = @(
            [OpenQA.Selenium.By]::Id("login"),
            [OpenQA.Selenium.By]::Name("login"),
            [OpenQA.Selenium.By]::CssSelector("button[type='submit']"),
            [OpenQA.Selenium.By]::CssSelector("input[type='submit']"),
            [OpenQA.Selenium.By]::XPath("//button[contains(text(), 'Login')]"),
            [OpenQA.Selenium.By]::XPath("//button[contains(text(), '登录')]"),
            [OpenQA.Selenium.By]::XPath("//input[@value='Login']"),
            [OpenQA.Selenium.By]::XPath("//input[@value='登录']")
        )
        
        # 查找用户名字段
        foreach ($selector in $usernameSelectors) {
            try {
                $elements = $Driver.FindElements($selector)
                if ($elements.Count -gt 0) {
                    $usernameField = $elements[0]
                    break
                }
            }
            catch {
                # 继续尝试下一个选择器
            }
        }
        
        # 查找密码字段
        foreach ($selector in $passwordSelectors) {
            try {
                $elements = $Driver.FindElements($selector)
                if ($elements.Count -gt 0) {
                    $passwordField = $elements[0]
                    break
                }
            }
            catch {
                # 继续尝试下一个选择器
            }
        }
        
        # 查找登录按
让我继续完成Web应用自动化测试脚本的内容：

```powershell
        # 查找登录按钮
        foreach ($selector in $loginButtonSelectors) {
            try {
                $elements = $Driver.FindElements($selector)
                if ($elements.Count -gt 0) {
                    $loginButton = $elements[0]
                    break
                }
            }
            catch {
                # 继续尝试下一个选择器
            }
        }
        
        # 检查是否找到所有必要元素
        if ($null -eq $usernameField) {
            throw "无法找到用户名输入字段"
        }
        
        if ($null -eq $passwordField) {
            throw "无法找到密码输入字段"
        }
        
        if ($null -eq $loginButton) {
            throw "无法找到登录按钮"
        }
        
        # 输入凭据
        $usernameField.Clear()
        $usernameField.SendKeys($Username)
        
        $passwordField.Clear()
        $passwordField.SendKeys($Password)
        
        # 截图（登录前）
        $screenshotPath = Take-Screenshot -Driver $Driver -ScreenshotDirectory $ScreenshotDirectory -TestName "$testName`_Before"
        
        # 点击登录按钮
        $loginButton.Click()
        
        # 等待登录完成
        Start-Sleep -Seconds 3
        
        # 截图（登录后）
        $screenshotPath = Take-Screenshot -Driver $Driver -ScreenshotDirectory $ScreenshotDirectory -TestName $testName
        
        # 检查登录是否成功
        # 这里需要根据实际应用进行调整
        $pageSource = $Driver.PageSource
        
        if ($pageSource -match "登出|注销|退出|Logout|Sign Out" -or 
            $Driver.Url -notmatch "login|signin") {
            $result.Status = "Passed"
            $result.Message = "登录成功"
            $result.Screenshot = $screenshotPath
            
            Write-Log $result.Message -Level "SUCCESS"
        }
        else {
            $result.Message = "登录可能失败，未检测到登录成功标志"
            $result.Screenshot = $screenshotPath
            
            Write-Log $result.Message -Level "WARNING"
        }
    }
    catch {
        $result.Message = "登录测试失败: $_"
        Write-Log $result.Message -Level "ERROR"
        
        # 尝试截图
        $result.Screenshot = Take-Screenshot -Driver $Driver -ScreenshotDirectory $ScreenshotDirectory -TestName "$testName`_Error"
    }
    
    return $result
}

# 测试导航功能
function Test-Navigation {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [OpenQA.Selenium.IWebDriver]$Driver,
        
        [Parameter(Mandatory=$true)]
        [string]$ScreenshotDirectory
    )
    
    $testName = "Navigation"
    Write-Log "开始测试: $testName" -Level "TEST"
    
    $result = @{
        TestName = $testName
        Status = "Failed"
        Message = ""
        NavigationLinks = @()
        Screenshot = ""
    }
    
    try {
        # 查找所有导航链接
        $links = $Driver.FindElements([OpenQA.Selenium.By]::TagName("a"))
        
        # 过滤掉外部链接和空链接
        $internalLinks = $links | Where-Object { 
            $href = $_.GetAttribute("href")
            $href -and $href -notmatch "^javascript:" -and $href -notmatch "^#" -and 
            $href -match "^$([regex]::Escape($Driver.Url))" 
        } | Select-Object -First 5  # 限制测试链接数量
        
        if ($internalLinks.Count -eq 0) {
            $result.Message = "未找到可测试的内部导航链接"
            Write-Log $result.Message -Level "WARNING"
            return $result
        }
        
        $navigationResults = @()
        $successCount = 0
        
        # 测试每个导航链接
        foreach ($link in $internalLinks) {
            $linkText = $link.Text.Trim()
            if ([string]::IsNullOrEmpty($linkText)) {
                $linkText = $link.GetAttribute("href")
            }
            
            $linkResult = @{
                LinkText = $linkText
                Url = $link.GetAttribute("href")
                Status = "Failed"
                LoadTime = 0
            }
            
            try {
                Write-Log "测试导航链接: $linkText" -Level "INFO"
                
                # 保存当前URL
                $currentUrl = $Driver.Url
                
                # 记录开始时间
                $startTime = Get-Date
                
                # 点击链接
                $link.Click()
                
                # 等待页面加载
                $wait = New-Object OpenQA.Selenium.Support.UI.WebDriverWait($Driver, [TimeSpan]::FromSeconds(10))
                $wait.Until([OpenQA.Selenium.Support.UI.ExpectedConditions]::ElementExists([OpenQA.Selenium.By]::TagName("body")))
                
                # 计算加载时间
                $endTime = Get-Date
                $loadTime = ($endTime - $startTime).TotalSeconds
                
                # 截图
                $linkScreenshot = Take-Screenshot -Driver $Driver -ScreenshotDirectory $ScreenshotDirectory -TestName "$testName`_$linkText"
                
                # 更新链接结果
                $linkResult.Status = "Passed"
                $linkResult.LoadTime = $loadTime
                $linkResult.Screenshot = $linkScreenshot
                
                $successCount++
                
                Write-Log "导航到 '$linkText' 成功，耗时: $loadTime 秒" -Level "SUCCESS"
                
                # 返回上一页
                $Driver.Navigate().Back()
                
                # 等待返回页面加载
                $wait.Until([OpenQA.Selenium.Support.UI.ExpectedConditions]::ElementExists([OpenQA.Selenium.By]::TagName("body")))
                
                # 重新获取链接元素（因为页面已刷新）
                $links = $Driver.FindElements([OpenQA.Selenium.By]::TagName("a"))
                $link = $links | Where-Object { $_.GetAttribute("href") -eq $linkResult.Url } | Select-Object -First 1
            }
            catch {
                $linkResult.Message = "导航失败: $_"
                Write-Log $linkResult.Message -Level "ERROR"
                
                # 尝试截图
                $linkResult.Screenshot = Take-Screenshot -Driver $Driver -ScreenshotDirectory $ScreenshotDirectory -TestName "$testName`_${linkText}_Error"
                
                # 尝试返回起始URL
                try {
                    $Driver.Navigate().GoToUrl($currentUrl)
                }
                catch {
                    Write-Log "无法返回起始URL: $_" -Level "ERROR"
                }
            }
            
            $navigationResults += $linkResult
        }
        
        # 更新总体结果
        if ($successCount -gt 0) {
            $result.Status = "Passed"
            $result.Message = "成功测试了 $successCount/$($internalLinks.Count) 个导航链接"
        }
        else {
            $result.Message = "所有导航链接测试均失败"
        }
        
        $result.NavigationLinks = $navigationResults
        $result.Screenshot = Take-Screenshot -Driver $Driver -ScreenshotDirectory $ScreenshotDirectory -TestName $testName
        
        Write-Log $result.Message -Level (if ($result.Status -eq "Passed") { "SUCCESS" } else { "WARNING" })
    }
    catch {
        $result.Message = "导航测试失败: $_"
        Write-Log $result.Message -Level "ERROR"
        
        # 尝试截图
        $result.Screenshot = Take-Screenshot -Driver $Driver -ScreenshotDirectory $ScreenshotDirectory -TestName "$testName`_Error"
    }
    
    return $result
}

# 测试表单提交
function Test-FormSubmission {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [OpenQA.Selenium.IWebDriver]$Driver,
        
        [Parameter(Mandatory=$true)]
        [string]$ScreenshotDirectory
    )
    
    $testName = "FormSubmission"
    Write-Log "开始测试: $testName" -Level "TEST"
    
    $result = @{
        TestName = $testName
        Status = "Failed"
        Message = ""
        Screenshot = ""
    }
    
    try {
        # 查找表单
        $forms = $Driver.FindElements([OpenQA.Selenium.By]::TagName("form"))
        
        if ($forms.Count -eq 0) {
            $result.Message = "页面上未找到表单"
            Write-Log $result.Message -Level "WARNING"
            return $result
        }
        
        # 选择第一个表单
        $form = $forms[0]
        
        # 查找表单中的输入字段
        $inputs = $form.FindElements([OpenQA.Selenium.By]::TagName("input")) | 
                  Where-Object { $_.GetAttribute("type") -ne "hidden" -and $_.GetAttribute("type") -ne "submit" -and $_.GetAttribute("type") -ne "button" }
        
        $textareas = $form.FindElements([OpenQA.Selenium.By]::TagName("textarea"))
        $selects = $form.FindElements([OpenQA.Selenium.By]::TagName("select"))
        
        # 查找提交按钮
        $submitButton = $form.FindElements([OpenQA.Selenium.By]::CssSelector("button[type='submit'], input[type='submit']")) | Select-Object -First 1
        
        if ($null -eq $submitButton) {
            # 尝试查找可能的提交按钮
            $buttons = $form.FindElements([OpenQA.Selenium.By]::TagName("button"))
            if ($buttons.Count -gt 0) {
                $submitButton = $buttons | Select-Object -First 1
            }
        }
        
        if ($null -eq $submitButton) {
            $result.Message = "表单中未找到提交按钮"
            Write-Log $result.Message -Level "WARNING"
            return $result
        }
        
        # 填充表单字段
        foreach ($input in $inputs) {
            $type = $input.GetAttribute("type")
            $name = $input.GetAttribute("name")
            
            if ([string]::IsNullOrEmpty($name)) {
                continue
            }
            
            try {
                switch ($type) {
                    "text" {
                        $input.Clear()
                        $input.SendKeys("测试文本")
                    }
                    "email" {
                        $input.Clear()
                        $input.SendKeys("test@example.com")
                    }
                    "password" {
                        $input.Clear()
                        $input.SendKeys("TestPassword123")
                    }
                    "checkbox" {
                        if (-not $input.Selected) {
                            $input.Click()
                        }
                    }
                    "radio" {
                        $input.Click()
                    }
                    "number" {
                        $input.Clear()
                        $input.SendKeys("123")
                    }
                    "date" {
                        $input.Clear()
                        $input.SendKeys((Get-Date -Format "yyyy-MM-dd"))
                    }
                    default {
                        $input.Clear()
                        $input.SendKeys("测试数据")
                    }
                }
                
                Write-Log "已填充字段: $name ($type)" -Level "INFO"
            }
            catch {
                Write-Log "填充字段 $name 失败: $_" -Level "WARNING"
            }
        }
        
        foreach ($textarea in $textareas) {
            $name = $textarea.GetAttribute("name")
            
            if ([string]::IsNullOrEmpty($name)) {
                continue
            }
            
            try {
                $textarea.Clear()
                $textarea.SendKeys("这是一段测试文本内容，用于自动化测试表单提交功能。")
                
                Write-Log "已填充文本区域: $name" -Level "INFO"
            }
            catch {
                Write-Log "填充文本区域 $name 失败: $_" -Level "WARNING"
            }
        }
        
        foreach ($select in $selects) {
            $name = $select.GetAttribute("name")
            
            if ([string]::IsNullOrEmpty($name)) {
                continue
            }
            
            try {
                $options = $select.FindElements([OpenQA.Selenium.By]::TagName("option"))
                
                if ($options.Count -gt 1) {
                    # 选择第二个选项（避免选择第一个默认选项）
                    $options[1].Click()
                }
                elseif ($options.Count -eq 1) {
                    $options[0].Click()
                }
                
                Write-Log "已选择下拉框: $name" -Level "INFO"
            }
            catch {
                Write-Log "选择下拉框 $name 失败: $_" -Level "WARNING"
            }
        }
        
        # 截图（提交前）
        $screenshotPath = Take-Screenshot -Driver $Driver -ScreenshotDirectory $ScreenshotDirectory -TestName "$testName`_Before"
        
        # 提交表单
        Write-Log "提交表单..." -Level "INFO"
        $submitButton.Click()
        
        # 等待页面加载
        Start-Sleep -Seconds 3
        
        # 截图（提交后）
        $screenshotPath = Take-Screenshot -Driver $Driver -ScreenshotDirectory $ScreenshotDirectory -TestName $testName
        
        # 检查表单提交是否成功
        # 这里需要根据实际应用进行调整
        $pageSource = $Driver.PageSource
        
        if ($pageSource -match "成功|提交成功|Success|Thank you" -or 
            $Driver.Url -ne $form.GetAttribute("action")) {
            $result.Status = "Passed"
            $result.Message = "表单提交成功"
            $result.Screenshot = $screenshotPath
            
            Write-Log $result.Message -Level "SUCCESS"
        }
        else {
            $result.Message = "表单提交可能失败，未检测到成功标志"
            $result.Screenshot = $screenshotPath
            
            Write-Log $result.Message -Level "WARNING"
        }
    }
    catch {
        $result.Message = "表单提交测试失败: $_"
        Write-Log $result.Message -Level "ERROR"
        
        # 尝试截图
        $result.Screenshot = Take-Screenshot -Driver $Driver -ScreenshotDirectory $ScreenshotDirectory -TestName "$testName`_Error"
    }
    
    return $result
}

# 生成HTML报告
function Generate-HtmlReport {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [array]$TestResults,
        
        [Parameter(Mandatory=$true)]
        [string]$ReportDirectory,
        
        [Parameter(Mandatory=$true)]
        [string]$Url
    )
    
    Write-Log "生成HTML报告..." -Level "INFO"
    
    $reportFile = Join-Path -Path $ReportDirectory -ChildPath "WebTestReport.html"
    
    # 计算测试统计
    $totalTests = $TestResults.Count
    $passedTests = ($TestResults | Where-Object { $_.Status -eq "Passed" }).Count
    $failedTests = $totalTests - $passedTests
    $passRate = [math]::Round(($passedTests / $totalTests) * 100, 2)
    
    # 生成HTML报告
    $html = @"
<!DOCTYPE html>
<html>
<head>
    <title>Web应用自动化测试报告</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1, h2, h3 { color: #2c3e50; }
        table { border-collapse: collapse; width: 100%; margin-bottom: 20px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        tr:nth-child(even) { background-color: #f9f9f9; }
        .summary { display: flex; flex-wrap: wrap; }
        .summary-box { border: 1px solid #ddd; border-radius: 5px; padding: 15px; margin: 10px; flex: 1; min-width: 200px; }
        .passed { color: green; }
        .failed { color: red; }
        .warning { color: orange; }
        .screenshot { max-width: 800px; border: 1px solid #ddd; margin-top: 10px; }
    </style>
</head>
<body>
    <h1>Web应用自动化测试报告</h1>
    <p>报告生成时间: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")</p>
    <p>测试URL: $Url</p>
    <p>浏览器: $BrowserType</p>
    
    <h2>测试摘要</h2>
    <div class="summary">
        <div class="summary-box">
            <h3>测试结果</h3>
            <p>总测试数: $totalTests</p>
            <p class="passed">通过: $passedTests</p>
            <p class="failed">失败: $failedTests</p>
            <p>通过率: $passRate%</p>
        </div>
    </div>
    
    <h2>测试详情</h2>
"@

    foreach ($result in $TestResults) {
        $statusClass = if ($result.Status -eq "Passed") { "passed" } else { "failed" }
        
        $html += @"
    <h3>$($result.TestName) <span class="$statusClass">[$($result.Status)]</span></h3>
    <p>$($result.Message)</p>
"@

        # 添加特定测试类型的详细信息
        switch ($result.TestName) {
            "PageLoad" {
                $html += @"
    <p>页面加载时间: $($result.LoadTime) 秒</p>
"@
            }
            "Navigation" {
                if ($result.NavigationLinks.Count -gt 0) {
                    $html += @"
    <table>
        <tr>
            <th>链接文本</th>
            <th>URL</th>
            <th>状态</th>
            <th>加载时间</th>
        </tr>
"@
                    
                    foreach ($link in $result.NavigationLinks) {
                        $linkStatusClass = if ($link.Status -eq "Passed") { "passed" } else { "failed" }
                        
                        $html += @"
        <tr>
            <td>$($link.LinkText)</td>
            <td>$($link.Url)</td>
            <td class="$linkStatusClass">$($link.Status)</td>
            <td>$($link.LoadTime) 秒</td>
        </tr>
"@
                    }
                    
                    $html += @"
    </table>
"@
                }
            }
        }
        
        # 添加截图
        if ($result.Screenshot) {
            $relativeScreenshot = [System.IO.Path]::GetFileName($result.Screenshot)
            $screenshotDir = [System.IO.Path]::GetFileName([System.IO.Path]::GetDirectoryName($result.Screenshot))
            $html += @"
    <p>截图:</p>
    <img src="$screenshotDir/$relativeScreenshot" class="screenshot" />
"@
        }
    }

    $html += @"
    
    <h2>测试日志</h2>
    <pre>$($script:testLogs -join "`n")</pre>
</body>
</html>
"@

    # 保存HTML报告
    $html | Out-File -FilePath $reportFile -Encoding UTF8
    
    Write-Log "HTML报告已生成: $reportFile" -Level "SUCCESS"
    return $reportFile
}

# 主函数
function Main {
    [CmdletBinding()]
    param()
    
    # 初始化日志数组
    $script:testLogs = @()
    
    try {
        # 初始化环境
        $env = Initialize-Environment
        
        # 安装Selenium依赖
        if (-not (Install-SeleniumDependencies)) {
            return
        }
        
        # 初始化WebDriver
        $driver = Initialize-WebDriver
        
        if ($null -eq $driver) {
            return
        }
        
        try {
            # 执行测试
            $testResults = @()
            
            # 测试页面加载
            $pageLoadResult = Test-PageLoad -Driver $driver -Url $Url -ScreenshotDirectory $env.ScreenshotDirectory
            $testResults += $pageLoadResult
            
            # 如果提供了登录凭据，测试登录功能
            if (-not [string]::IsNullOrEmpty($Username) -and -not [string]::IsNullOrEmpty($Password)) {
                $loginResult = Test-Login -Driver $driver -Username $Username -Password $Password -ScreenshotDirectory $env.ScreenshotDirectory
                $testResults += $loginResult
            }
            
            # 测试导航功能
            $navigationResult = Test-Navigation -Driver $driver -ScreenshotDirectory $env.ScreenshotDirectory
            $testResults += $navigationResult
            
            # 测试表单提交
            $formResult = Test-FormSubmission -Driver $driver -ScreenshotDirectory $env.ScreenshotDirectory
            $testResults += $formResult
            
            # 生成HTML报告
            $reportFile = Generate-HtmlReport -TestResults $testResults -ReportDirectory $env.ReportDirectory -Url $Url
            
            # 打开报告
            Invoke-Item $reportFile
            
            Write-Log "Web应用测试完成，报告保存在: $reportFile" -Level "SUCCESS"
        }
        finally {
            # 关闭WebDriver
            if ($null -ne $driver) {
                $driver.Quit()
            }
        }
    }
    catch {
        Write-Log "测试过程中发生错误: $_" -Level "ERROR"
        Write-Log $_.ScriptStackTrace -Level "ERROR"
    }
}

# 执行主函数
Main
```

#### 5.5.2 API自动化测试脚本

以下是一个PowerShell API自动化测试脚本：

```powershell
<#
.SYNOPSIS
    API自动化测试脚本
.DESCRIPTION
    自动化测试REST API，包括：
    - 基本连通性测试
    - 认证测试
    - 各种HTTP方法测试
    - 性能测试
    - 错误处理测试
.PARAMETER BaseUrl
    API基础URL
.PARAMETER AuthToken
    认证令牌（如果需要）
.PARAMETER Username
    用户名（如果使用基本认证）
.PARAMETER Password
    密码（如果使用基本认证）
.PARAMETER TestEndpoints
    要测试的端点列表
.PARAMETER OutputPath
    测试报告输出路径
.PARAMETER PerformanceTest
    是否执行性能测试
.EXAMPLE
    .\Test-API.ps1 -BaseUrl "https://api.example.com" -AuthToken "token123" -TestEndpoints @("users", "products")
.NOTES
    作者: Your Name
    创建日期: 2023-01-01
    版本: 1.0
#>

[CmdletBinding()]
param (
    [Parameter(Mandatory=$true)]
    [string]$BaseUrl,
    
    [Parameter(Mandatory=$false)]
    [string]$AuthToken = "",
    
    [Parameter(Mandatory=$false)]
    [string]$Username = "",
    
    [Parameter(Mandatory=$false)]
    [string]$Password = "",
    
    [Parameter(Mandatory=$false)]
    [string[]]$TestEndpoints = @(),
    
    [Parameter(Mandatory=$false)]
    [string]$OutputPath = "C:\Temp\ApiTestReports",
    
    [Parameter(Mandatory=$false)]
    [switch]$PerformanceTest = $false
)

# 初始化日志
function Write-Log {
    [CmdletBinding()]
    param (
        [Parameter(Mandatory=$true)]
        [string]$Message,
        
        [Parameter(Mandatory=$false)]
        [ValidateSet("INFO", "WARNING", "ERROR", "SUCCESS", "TEST")]
        [string]$Level = "INFO"
    )
    
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $logEntry = "[$timestamp] [$Level] $Message"
    
    # 输出到控制台
    switch ($Level) {
        "INFO" { Write-Host $Message }
        "WARNING" { Write-Host $Message -ForegroundColor Yellow }
        "ERROR" { Write-Host $Message -ForegroundColor Red }
        "SUCCESS" { Write-Host $Message -ForegroundColor Green }
        "TEST" { Write-Host $Message -ForegroundColor Cyan }
    }
    
    # 添加到日志数组
    $script:testLogs += $logEntry
}

# 初始化环境
function Initialize-Environment {
    [CmdletBinding()]
    param()
    
    # 创建输出目录
    if (-not (Test-Path -Path $OutputPath)) {
        New-Item -Path $OutputPath -ItemType Directory -Force | Out-Null
    }
    
    # 创建时间戳
    $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
    $reportDir = Join-Path -Path $OutputPath -ChildPath "ApiTest_$timestamp"
    New-Item -Path $reportDir -ItemType Directory -Force | Out-Null
    
    return $reportDir
}

# 创建HTTP请求头
function Get-RequestHeaders {
    [CmdletBinding()]
    param()
    
    $headers = @{
        "Accept" = "application/json"
        "Content-Type" = "application/json"
        "User-Agent" = "PowerShell API Test Script/1.0"
    }
    
    # 添加认证信息
    if (-not [string]::IsNullOrEmpty($AuthToken)) {
        $headers["Authorization"] = "Bearer $AuthToken"
    }
    elseif (-not [string]::IsNullOrEmpty($Username) -and -not [string]::IsNullOrEmpty($Password)) {
        $base64AuthInfo = [Convert]::ToBase64String([Text.Encoding]::ASCII.GetBytes("$($Username):$($Password)"))
        $headers["Authorization"] = "Basic $base64AuthInfo"
    }
    
    return $headers
}

# 测试API连通性
function Test-ApiConnectivity {
    [CmdletBinding()]
    param()
    
    $testName = "ApiConnectivity"
    Write-Log "开始测试: $testName" -Level "TEST"
    
    $result = @{
        TestName = $testName
        Status = "Failed"
        Message = ""
        ResponseTime = 0
        StatusCode = 0
    }
    
    try {
        $headers = Get-RequestHeaders
        
        # 记录开始时间
        $startTime = Get-Date
        
        # 发送请求
        $response = Invoke-WebRequest -Uri $BaseUrl -Method Get -Headers $headers -UseBasicParsing -ErrorAction Stop
        
        # 计算响应时间
        $endTime = Get-Date
        $responseTime = ($endTime - $startTime).TotalMilliseconds
        
        # 更新结果
        $result.Status = "Passed"
        $result.Message = "API连通性测试成功"
        $result.ResponseTime = $responseTime
        $result.StatusCode = $response.StatusCode
        
        Write-Log "$($result.Message)，响应时间: $($responseTime) 毫秒，状态码: $($response.StatusCode)" -Level "SUCCESS"
    }
    catch {
        $errorResponse = $_.Exception.Response
        
        if ($null -ne $errorResponse) {
            $result.StatusCode = [int]$errorResponse.StatusCode
            $result.Message = "API连通性测试失败，状态码: $($result.StatusCode)"
        }
        else {
            $result.Message = "API连通性测试失败: $_"
        }
        
        Write-Log $result.Message -Level "ERROR"
    }
    
    return $result
}

# 测试API认证
function Test-ApiAuthentication {
    [CmdletBinding()]
    param()
    
    $testName = "ApiAuthentication"
    Write-Log "开始测试: $testName" -Level "TEST"
    
    $result = @{
        TestName = $testName
        Status = "Failed"
        Message = ""
        ResponseTime = 0
        StatusCode = 0
    }
    
    try {
        # 如果没有提供认证信息，跳过此测试
        if ([string]::IsNullOrEmpty($AuthToken) -and 
            ([string]::IsNullOrEmpty($Username) -or [string]::IsNullOrEmpty($Password))) {
            $result.Message = "未提供认证信息，跳过认证测试"
            Write-Log $result.Message -Level "WARNING"
            return $result
        }
        
        $headers = Get-RequestHeaders
        
        # 记录开始时间
        $startTime = Get-Date
        
        # 发送请求
        $response = Invoke-WebRequest -Uri $BaseUrl -Method Get -Headers $headers -UseBasicParsing -ErrorAction Stop
        
        # 计算响应时间
        $endTime = Get-Date
        $responseTime = ($endTime - $startTime).TotalMilliseconds
        
        # 更新结果
        $
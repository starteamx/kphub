---
title: 常见问题与解决方案
icon: troubleshooting
order: 10
---

# 常见问题与解决方案

在Web服务器和应用程序的日常运维过程中，我们经常会遇到各种各样的问题。本文将系统地介绍Apache HTTP Server及相关环境中常见的问题及其解决方案，帮助您快速定位和解决这些问题。

## 1. 服务启动失败

服务启动失败是最常见的问题之一，通常由以下几种原因导致。

### 1.1 端口冲突问题

当Apache尝试绑定的端口已被其他程序占用时，服务将无法启动。这在默认的80端口上尤为常见，因为许多Web服务器和应用程序默认使用此端口。

**检查端口占用情况：**

```powershell:c:\project\kphub\scripts\check_port.ps1
# 检查特定端口(如80)的占用情况
Write-Host "正在检查80端口占用情况..." -ForegroundColor Cyan
$portCheck = netstat -ano | findstr :80

if ($portCheck) {
    Write-Host "发现80端口被占用:" -ForegroundColor Yellow
    $portCheck
    
    # 提取PID
    $pids = @()
    $portCheck | ForEach-Object {
        if ($_ -match ":80\s+\S+\s+\S+\s+(\d+)") {
            $pids += $matches[1]
        }
    }
    
    # 获取进程信息
    $uniquePids = $pids | Select-Object -Unique
    Write-Host "`n占用端口的进程信息:" -ForegroundColor Cyan
    foreach ($pid in $uniquePids) {
        $process = Get-Process -Id $pid -ErrorAction SilentlyContinue
        if ($process) {
            Write-Host "PID: $pid, 进程名: $($process.ProcessName), 路径: $($process.Path)"
        }
    }
    
    # 询问是否终止进程
    $terminate = Read-Host "`n是否终止占用进程? (Y/N)"
    if ($terminate -eq "Y" -or $terminate -eq "y") {
        foreach ($pid in $uniquePids) {
            Write-Host "正在终止PID为 $pid 的进程..." -ForegroundColor Yellow
            taskkill /PID $pid /F
        }
        Write-Host "进程已终止" -ForegroundColor Green
    }
} else {
    Write-Host "80端口未被占用，可以安全启动Apache" -ForegroundColor Green
}

# 检查Apache是否正在运行
$apacheProcess = Get-Process -Name httpd -ErrorAction SilentlyContinue
if ($apacheProcess) {
    Write-Host "`nApache已在运行，PID: $($apacheProcess.Id)" -ForegroundColor Green
} else {
    Write-Host "`nApache未运行" -ForegroundColor Yellow
}
```

**解决方案：**

1. **修改Apache监听端口**：如果不需要使用标准的80端口，可以将Apache配置为使用其他端口。

```apache:c:\project\kphub\conf\httpd.conf
# 将默认的80端口修改为其他端口(如8080)
Listen 8080

# 如果有多个虚拟主机，也需要相应修改
<VirtualHost *:8080>
    # 虚拟主机配置
</VirtualHost>
```

2. **终止占用端口的进程**：如果需要使用80端口，可以终止占用该端口的其他进程。

```powershell:c:\project\kphub\scripts\free_port.ps1
# 获取占用80端口的进程PID
$pid = (netstat -ano | findstr :80 | findstr LISTENING)[0].Split(' ')[-1]

# 终止该进程
if ($pid) {
    $process = Get-Process -Id $pid -ErrorAction SilentlyContinue
    if ($process) {
        Write-Host "正在终止进程: $($process.ProcessName) (PID: $pid)"
        taskkill /PID $pid /F
    }
}
```

3. **配置Windows服务自动延迟启动**：如果是其他服务暂时占用端口，可以设置Apache服务延迟启动。

```powershell:c:\project\kphub\scripts\set_delayed_start.ps1
# 设置Apache服务为自动延迟启动
sc.exe config Apache2.4 start= delayed-auto
```

### 1.2 模块加载失败

Apache的模块化架构允许按需加载功能，但如果模块文件丢失或损坏，将导致服务启动失败。

**错误日志示例：**

```log:c:\project\kphub\logs\error.log
[Thu Oct 12 10:15:23.123456 2023] [core:error] [pid 1234] (OS 126)找不到指定的模块。 : AH00082: Cannot load modules/mod_ssl.so into server
[Thu Oct 12 10:15:23.234567 2023] [core:error] [pid 1234] AH00526: Syntax error on line 145 of c:/project/kphub/conf/httpd.conf: Cannot load modules/mod_ssl.so into server: 找不到指定的模块。
```

**解决方法：**

1. **检查模块文件是否存在**：

```powershell:c:\project\kphub\scripts\check_modules.ps1
# 检查模块文件是否存在
$modulesDir = "c:\project\kphub\modules"
$modulesList = @(
    "mod_ssl.so",
    "mod_rewrite.so",
    "mod_php.so"
    # 添加其他需要检查的模块
)

Write-Host "正在检查模块文件..." -ForegroundColor Cyan
foreach ($module in $modulesList) {
    $modulePath = Join-Path -Path $modulesDir -ChildPath $module
    if (Test-Path $modulePath) {
        Write-Host "✓ 模块文件存在: $module" -ForegroundColor Green
    } else {
        Write-Host "✗ 模块文件不存在: $module" -ForegroundColor Red
    }
}
```

2. **注释掉有问题的模块**：如果模块不是必需的，可以暂时在配置文件中注释掉。

```apache:c:\project\kphub\conf\httpd.conf
# 注释掉有问题的模块
# LoadModule ssl_module modules/mod_ssl.so
```

3. **重新安装或修复模块**：

```powershell:c:\project\kphub\scripts\repair_apache.ps1
# 运行Apache修复程序
Start-Process -FilePath "c:\project\kphub\bin\httpd.exe" -ArgumentList "-k install" -Wait
```

4. **在Windows上，确保VC++运行时库已安装**：许多模块依赖于Visual C++运行时库。

```powershell:c:\project\kphub\scripts\install_vcredist.ps1
# 下载并安装Visual C++ Redistributable
$vcRedistUrl = "https://aka.ms/vs/17/release/vc_redist.x64.exe"
$vcRedistPath = "c:\temp\vc_redist.x64.exe"

# 创建临时目录
if (-not (Test-Path "c:\temp")) {
    New-Item -Path "c:\temp" -ItemType Directory
}

# 下载VC++运行时
Invoke-WebRequest -Uri $vcRedistUrl -OutFile $vcRedistPath

# 安装VC++运行时
Start-Process -FilePath $vcRedistPath -ArgumentList "/install /quiet /norestart" -Wait
```

### 1.3 配置文件错误

配置文件中的语法错误是另一个常见的启动失败原因。

**检查配置文件语法：**

```powershell:c:\project\kphub\scripts\syntax_check.ps1
# 检查Apache配置文件语法
$apacheBin = "c:\project\kphub\bin\httpd.exe"
$configFile = "c:\project\kphub\conf\httpd.conf"

Write-Host "正在检查Apache配置文件语法..." -ForegroundColor Cyan
$result = & $apacheBin -t -f $configFile 2>&1

if ($LASTEXITCODE -eq 0) {
    Write-Host "✓ 配置文件语法正确" -ForegroundColor Green
} else {
    Write-Host "✗ 配置文件存在语法错误:" -ForegroundColor Red
    Write-Host $result
    
    # 提取错误行号和文件
    if ($result -match "line (\d+) of (.+?):|in (.+?) line (\d+)") {
        $lineNum = $matches[1] -or $matches[4]
        $fileName = $matches[2] -or $matches[3]
        
        if (Test-Path $fileName) {
            Write-Host "`n问题文件内容:" -ForegroundColor Yellow
            $fileContent = Get-Content $fileName
            $startLine = [Math]::Max(1, [int]$lineNum - 5)
            $endLine = [Math]::Min($fileContent.Count, [int]$lineNum + 5)
            
            for ($i = $startLine; $i -le $endLine; $i++) {
                if ($i -eq [int]$lineNum) {
                    Write-Host "$i: $($fileContent[$i-1])" -ForegroundColor Red
                } else {
                    Write-Host "$i: $($fileContent[$i-1])"
                }
            }
        }
    }
}
```

**常见配置错误及修复：**

1. **缺少必要的模块**：

```apache:c:\project\kphub\conf\httpd.conf
# 错误：Invalid command 'Require'
# 修复：确保已加载mod_authz_core
LoadModule authz_core_module modules/mod_authz_core.so
```

2. **路径错误**：

```apache:c:\project\kphub\conf\httpd.conf
# 错误：DocumentRoot指向不存在的目录
# 修复：确保目录存在或修正路径
DocumentRoot "c:/project/kphub/www"
```

3. **语法错误**：

```apache:c:\project\kphub\conf\httpd.conf
# 错误：缺少闭合标签
<Directory "c:/project/kphub/www">
    Options Indexes FollowSymLinks
    AllowOverride All
    Require all granted
</Directory>  # 确保有闭合标签
```

## 2. 配置错误排查

即使Apache能够启动，配置错误仍可能导致功能异常。

### 2.1 配置语法检查

在修改配置文件后，应始终进行语法检查以避免重启服务后出现问题。

```powershell:c:\project\kphub\scripts\check_config.ps1
# 全面检查Apache配置
$apacheBin = "c:\project\kphub\bin\httpd.exe"
$configFile = "c:\project\kphub\conf\httpd.conf"

function Check-ApacheConfig {
    Write-Host "正在检查Apache配置..." -ForegroundColor Cyan
    $result = & $apacheBin -t -f $configFile 2>&1
    
    if ($LASTEXITCODE -eq 0) {
        Write-Host "✓ 配置语法正确" -ForegroundColor Green
        return $true
    } else {
        Write-Host "✗ 配置存在错误:" -ForegroundColor Red
        Write-Host $result
        return $false
    }
}

function Check-IncludedConfigs {
    Write-Host "`n正在检查包含的配置文件..." -ForegroundColor Cyan
    $includes = Select-String -Path $configFile -Pattern "^\s*Include\s+(.+)" | 
                ForEach-Object { $_.Matches.Groups[1].Value }
    
    foreach ($include in $includes) {
        # 处理通配符
        if ($include -match "\*") {
            $includePath = $include -replace "/", "\"
            $files = Get-ChildItem -Path $includePath -ErrorAction SilentlyContinue
            foreach ($file in $files) {
                Write-Host "检查包含文件: $($file.FullName)"
                $includeResult = & $apacheBin -t -f $file.FullName 2>&1
                if ($LASTEXITCODE -ne 0) {
                    Write-Host "✗ 文件 $($file.FullName) 存在错误:" -ForegroundColor Red
                    Write-Host $includeResult
                }
            }
        } else {
            $includePath = $include -replace "/", "\"
            if (Test-Path $includePath) {
                Write-Host "检查包含文件: $includePath"
                $includeResult = & $apacheBin -t -f $includePath 2>&1
                if ($LASTEXITCODE -ne 0) {
                    Write-Host "✗ 文件 $includePath 存在错误:" -ForegroundColor Red
                    Write-Host $includeResult
                }
            } else {
                Write-Host "✗ 包含的文件不存在: $includePath" -ForegroundColor Yellow
            }
        }
    }
}

function Check-VirtualHosts {
    Write-Host "`n正在检查虚拟主机配置..." -ForegroundColor Cyan
    $vhostResult = & $apacheBin -t -D DUMP_VHOSTS 2>&1
    
    if ($LASTEXITCODE -eq 0) {
        Write-Host "虚拟主机配置:" -ForegroundColor Green
        Write-Host $vhostResult
    } else {
        Write-Host "✗ 虚拟主机配置存在问题:" -ForegroundColor Red
        Write-Host $vhostResult
    }
}

function Check-Modules {
    Write-Host "`n正在检查已加载模块..." -ForegroundColor Cyan
    $moduleResult = & $apacheBin -t -D DUMP_MODULES 2>&1
    
    if ($LASTEXITCODE -eq 0) {
        Write-Host "已加载模块:" -ForegroundColor Green
        Write-Host $moduleResult
    } else {
        Write-Host "✗ 模块加载存在问题:" -ForegroundColor Red
        Write-Host $moduleResult
    }
}

# 执行检查
$configOk = Check-ApacheConfig
if ($configOk) {
    Check-IncludedConfigs
    Check-VirtualHosts
    Check-Modules
}
```

**常见错误修复：**

```apache:c:\project\kphub\conf\httpd.conf
# 错误：Invalid command 'Require'
# 修复：确保已加载mod_authz_core
LoadModule authz_core_module modules/mod_authz_core.so

# 错误：Invalid command 'RewriteEngine'
# 修复：确保已加载mod_rewrite
LoadModule rewrite_module modules/mod_rewrite.so

# 错误：Invalid command 'ProxyPass'
# 修复：确保已加载mod_proxy
LoadModule proxy_module modules/mod_proxy.so
LoadModule proxy_http_module modules/mod_proxy_http.so
```

### 2.2 .htaccess不生效

`.htaccess`文件是Apache的分布式配置文件，允许在不修改主配置文件的情况下更改配置。但如果配置不当，这些文件可能不会生效。

**检查步骤：**

1. **确认AllowOverride设置**：

```apache:c:\project\kphub\conf\httpd.conf
<Directory "c:/project/kphub/www">
    # 允许.htaccess覆盖所有配置
    AllowOverride All
    
    # 或者只允许特定指令
    # AllowOverride AuthConfig Indexes
    
    Require all granted
</Directory>
```

2. **检查模块是否加载**：许多`.htaccess`指令依赖于特定模块。

```apache:c:\project\kphub\conf\httpd.conf
# 重写规则需要此模块
LoadModule rewrite_module modules/mod_rewrite.so

# 访问控制需要这些模块
LoadModule authz_core_module modules/mod_authz_core.so
LoadModule authz_host_module modules/mod_authz_host.so
```

3. **检查.htaccess文件权限和语法**：

```powershell:c:\project\kphub\scripts\check_htaccess.ps1
# 检查.htaccess文件
$htaccessPath = "c:\project\kphub\www\.htaccess"

if (Test-Path $htaccessPath) {
    Write-Host ".htaccess文件存在" -ForegroundColor Green
    
    # 检查文件内容
    $content = Get-Content $htaccessPath
    Write-Host "`n文件内容:" -ForegroundColor Cyan
    $content | ForEach-Object { Write-Host $_ }
    
    # 检查常见问题
    if ($content -match "RewriteEngine On" -and -not ($content -match "RewriteRule")) {
        Write-Host "`n⚠️ 警告: 启用了RewriteEngine但没有RewriteRule" -ForegroundColor Yellow
    }
    
    if ($content -match "RewriteRule" -and -not ($content -match "RewriteEngine On")) {
        Write-Host "`n⚠️ 警告: 有RewriteRule但未启用RewriteEngine" -ForegroundColor Yellow
    }
    
    # 检查语法 (需要Apache工具)
    $apacheBin = "c:\project\kphub\bin\httpd.exe"
    if (Test-Path $apacheBin) {
        Write-Host "`n正在检查.htaccess语法..." -ForegroundColor Cyan
        $tempConfig = "c:\temp\htaccess_test.conf"
        
        # 创建临时配置文件
        @"
<Directory "c:/project/kphub/www">
    AllowOverride All
</Directory>
Include "$htaccessPath"
"@ | Out-File -FilePath $tempConfig -Encoding ASCII
        
        $result = & $apacheBin -t -f $tempConfig 2>&1
        if ($LASTEXITCODE -eq 0) {
            Write-Host "✓ .htaccess语法正确" -ForegroundColor Green
        } else {
            Write-Host "✗ .htaccess语法错误:" -ForegroundColor Red
            Write-Host $result
        }
        
        # 清理临时文件
        Remove-Item $tempConfig -ErrorAction SilentlyContinue
    }
} else {
    Write-Host "✗ .htaccess文件不存在" -ForegroundColor Red
}
```

**常见.htaccess问题及解决方案：**

1. **重写规则不生效**：

```apache:c:\project\kphub\www\.htaccess
# 确保启用重写引擎
RewriteEngine On

# 添加重写规则
RewriteRule ^article/([0-9]+)/?$ article.php?id=$1 [L]
```

2. **权限设置不生效**：

```apache:c:\project\kphub\www\.htaccess
# 确保使用正确的语法
<Files "config.php">
    Require all denied
</Files>
```

3. **MIME类型设置不生效**：

```apache:c:\project\kphub\www\.htaccess
# 添加自定义MIME类型
AddType application/json .json
```

## 3. 性能问题诊断

性能问题可能由多种因素引起，包括配置不当、资源不足或代码效率低下。

### 3.1 高CPU占用分析

高CPU占用通常表明服务器正在处理大量请求或某些请求处理效率低下。

```powershell:c:\project\kphub\scripts\analyze_cpu.ps1
# 监控Apache进程CPU使用情况
function Monitor-ApacheCPU {
    param (
        [int]$duration = 60,  # 监控持续时间(秒)
        [int]$interval = 5    # 采样间隔(秒)
    )
    
    Write-Host "开始监控Apache CPU使用情况，持续$duration秒，每$interval秒采样一次..." -ForegroundColor Cyan
    
    $samples = [int]($duration / $interval)
    $cpuData = @()
    
    for ($i = 0; $i -lt $samples; $i++) {
        $processes = Get-Process -Name httpd, apache* -ErrorAction SilentlyContinue
        
        if ($processes) {
            # 汇总所有Apache进程
            $totalCPU = ($processes | Measure-Object -Property CPU -Sum).Sum
            $totalWorkingSet = ($processes | Measure-Object -Property WorkingSet -Sum).Sum / 1MB
            $processCount = $processes.Count
            
            $timestamp = Get-Date -Format "HH:mm:ss"
            $cpuData += [PSCustomObject]@{
                Time = $timestamp
                TotalCPU = [math]::Round($totalCPU, 2)
                AvgCPU = [math]::Round($totalCPU / $processCount, 2)
                ProcessCount = $processCount
                TotalMemoryMB = [math]::Round($totalWorkingSet, 2)
                AvgMemoryMB = [math]::Round($totalWorkingSet / $processCount, 2)
            }
            
            Write-Host "[$timestamp] 进程数: $processCount, 总CPU: $([math]::Round($totalCPU, 2))s, 总内存: $([math]::Round($totalWorkingSet, 2))MB"
            
            # 检查高CPU进程
            $highCPUProcesses = $processes | Where-Object { $_.CPU -gt 10 } | Sort-Object CPU -Descending
            if ($highCPUProcesses) {
                Write-Host "  高CPU使用进程:" -ForegroundColor Yellow
                $highCPUProcesses | Select-Object Id, CPU, WorkingSet | ForEach-Object {
                    Write-Host "  PID: $($_.Id), CPU: $([math]::Round($_.CPU, 2))s, 内存: $([math]::Round($_.WorkingSet / 1MB, 2))MB"
                }
            }
        } else {
            Write-Host "[$timestamp] 未发现Apache进程" -ForegroundColor Red
        }
        
        if ($i -lt $samples - 1) {
            Start-Sleep -Seconds $interval
        }
    }
    
    # 输出统计信息
    if ($cpuData.Count -gt 0) {
        $avgCPU = ($cpuData | Measure-Object -Property TotalCPU -Average).Average
        $maxCPU = ($cpuData | Measure-Object -Property TotalCPU -Maximum).Maximum
        $avgMem = ($cpuData | Measure-Object -Property TotalMemoryMB -Average).Average
        $maxMem = ($cpuData | Measure-Object -Property TotalMemoryMB -Maximum).Maximum
        
        Write-Host "`n监控统计:" -ForegroundColor Cyan
        Write-Host "平均CPU使用: $([math]::Round($avgCPU, 2))s" -ForegroundColor $(if ($avgCPU -gt 50) { "Yellow" } else { "Green" })
        Write-Host "最大CPU使用: $([math]::Round($maxCPU, 2))s" -ForegroundColor $(if ($maxCPU -gt 100) { "Red" } else { "Yellow" })
        Write-Host "平均内存使用: $([math]::Round($avgMem, 2))MB" -ForegroundColor $(if ($avgMem -gt 1000) { "Yellow" } else { "Green" })
        Write-Host "最大内存使用: $([math]::Round($maxMem, 2))MB" -ForegroundColor $(if ($maxMem -gt 2000) { "Red" } else { "Yellow" })
    }
}

# 执行监控
Monitor-ApacheCPU -duration 30 -interval 2
```

**优化方案：**

1. **调整MPM参数**：

```apache:c:\project\kphub\conf\extra\httpd-mpm.conf
# 对于prefork MPM (处理进程模型)
<IfModule mpm_prefork_module>
    # 减少最大工作进程数
    StartServers             5
    MinSpareServers          5
    MaxSpareServers         10
    MaxRequestWorkers      100  # 从150减少到100
    MaxConnectionsPerChild   0
</IfModule>

# 对于worker MPM (混合进程-线程模型)
<IfModule mpm_worker_module>
    StartServers             2
    MinSpareThreads         25
    MaxSpareThreads         75
    ThreadsPerChild         25
    MaxRequestWorkers      150
    MaxConnectionsPerChild   0
</IfModule>

# 对于event MPM (事件驱动模型，推荐)
<IfModule mpm_event_module>
    StartServers             2
    MinSpareThreads         25
    MaxSpareThreads         75
    ThreadsPerChild         25
    MaxRequestWorkers      150
    MaxConnectionsPerChild   0
</IfModule>
```

2. **启用缓存模块**：

```apache:c:\project\kphub\conf\httpd.conf
# 加载缓存模块
LoadModule cache_module modules/mod_cache.so
LoadModule cache_disk_module modules/mod_cache_disk.so

# 配置磁盘缓存
<IfModule mod_cache_disk.c>
    CacheRoot "c:/project/kphub/cache"
    CacheEnable disk /
    CacheDirLevels 2
    CacheDirLength 1
    CacheMaxFileSize 1048576  # 最大缓存文件大小(1MB)
</IfModule>
```

3. **优化静态文件处理**：

```apache:c:\project\kphub\conf\httpd.conf
# 启用expires模块
LoadModule expires_module modules/mod_expires.so

# 配置静态文件缓存
<IfModule mod_expires.c>
    ExpiresActive On
    ExpiresByType image/jpg "access plus 1 month"
    ExpiresByType image/jpeg "access plus 1 month"
    ExpiresByType image/gif "access plus 1 month"
    ExpiresByType image/png "access plus 1 month"
    ExpiresByType text/css "access plus 1 week"
    ExpiresByType application/javascript "access plus 1 week"
    ExpiresDefault "access plus 1 day"
</IfModule>
```

### 3.2 内存泄漏排查

内存泄漏会导致服务器性能随时间逐渐下降，最终可能导致服务崩溃。

**检测方法：**

```powershell:c:\project\kphub\scripts\check_memory.ps1
# 监控Apache内存使用情况
function Monitor-ApacheMemory {
    param (
        [int]$duration = 3600,  # 监控持续时间(秒)
        [int]$interval = 60,    # 采样间隔(秒)
        [string]$logFile = "c:\project\kphub\logs\memory_monitor.csv"
    )
    
    Write-Host "开始监控Apache内存使用情况，持续$duration秒，每$interval秒采样一次..." -ForegroundColor Cyan
    Write-Host "日志将保存到: $logFile" -ForegroundColor Cyan
    
    # 创建CSV头
    "Timestamp,ProcessCount,TotalMemoryMB,AvgMemoryMB,MaxMemoryMB,MinMemoryMB" | Out-File -FilePath $logFile
    
    $samples = [int]($duration / $interval)
    $startTime = Get-Date
    
    for ($i = 0; $i -lt $samples; $i++) {
        $currentTime = Get-Date
        $elapsedMinutes = [math]::Round(($currentTime - $startTime).TotalMinutes, 1)
        
        $processes = Get-Process -Name httpd, apache* -ErrorAction SilentlyContinue
        
        if ($processes) {
            # 计算内存统计
            $memoryValues = $processes | ForEach-Object { $_.WorkingSet / 1MB }
            $totalMemory = ($memoryValues | Measure-Object -Sum).Sum
            $avgMemory = ($memoryValues | Measure-Object -Average).Average
            $maxMemory = ($memoryValues | Measure-Object -Maximum).Maximum
            $minMemory = ($memoryValues | Measure-Object -Minimum).Minimum
            $processCount = $processes.Count
            
            $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
            
            # 写入CSV
            "$timestamp,$processCount,$([math]::Round($totalMemory, 2)),$([math]::Round($avgMemory, 2)),$([math]::Round($maxMemory, 2)),$([math]::Round($minMemory, 2))" | Out-File -FilePath $logFile -Append
            
            # 显示当前状态
            Write-Host "[$elapsedMinutes 分钟] 进程数: $processCount, 总内存: $([math]::Round($totalMemory, 2))MB, 平均: $([math]::Round($avgMemory, 2))MB
让我继续完成Apache与PHP集成配置的常见问题与解决方案文档：

### 3.2 内存泄漏排查（续）

```powershell:c:\project\kphub\scripts\check_memory.ps1
            # 显示当前状态
            Write-Host "[$elapsedMinutes 分钟] 进程数: $processCount, 总内存: $([math]::Round($totalMemory, 2))MB, 平均: $([math]::Round($avgMemory, 2))MB"
            
            # 检测可能的内存泄漏
            if ($i -gt 0 -and $totalMemory -gt $previousTotal * 1.1 -and $elapsedMinutes -gt 10) {
                Write-Host "⚠️ 可能存在内存泄漏! 内存增长了 $([math]::Round(($totalMemory - $previousTotal), 2))MB" -ForegroundColor Red
            }
            
            $previousTotal = $totalMemory
        } else {
            Write-Host "[$elapsedMinutes 分钟] 未发现Apache进程" -ForegroundColor Red
        }
        
        if ($i -lt $samples - 1) {
            Start-Sleep -Seconds $interval
        }
    }
    
    Write-Host "`n监控完成，详细日志已保存到: $logFile" -ForegroundColor Green
    Write-Host "可以使用Excel或其他工具分析CSV文件，查看内存使用趋势" -ForegroundColor Cyan
}

# 执行短期监控
Monitor-ApacheMemory -duration 300 -interval 10
```

**解决方案：**

1. **限制每个子进程处理的请求数**：

```apache:c:\project\kphub\conf\httpd.conf
# 设置每个子进程处理10000个请求后自动重启
# 这有助于释放可能泄漏的内存
MaxConnectionsPerChild 10000
```

2. **检查并修复PHP脚本中的内存泄漏**：

```php:c:\project\kphub\www\tools\memory_check.php
<?php
/**
 * PHP内存使用检测工具
 */

// 启用内存使用跟踪
ini_set('memory_limit', '256M');

// 记录初始内存使用
$initialMemory = memory_get_usage(true);
echo "初始内存使用: " . formatBytes($initialMemory) . "<br>";

// 模拟请求处理
for ($i = 0; $i < 10; $i++) {
    echo "迭代 $i - 当前内存: " . formatBytes(memory_get_usage(true)) . "<br>";
    
    // 执行可能导致内存泄漏的操作
    // 例如：加载大量数据但不释放
    $data = [];
    for ($j = 0; $j < 10000; $j++) {
        $data[] = str_repeat("test", 10);
    }
    
    echo "迭代 $i (加载数据后) - 内存: " . formatBytes(memory_get_usage(true)) . "<br>";
    
    // 正确释放内存
    unset($data);
    
    echo "迭代 $i (释放后) - 内存: " . formatBytes(memory_get_usage(true)) . "<br>";
    echo "<hr>";
}

// 最终内存使用
$finalMemory = memory_get_usage(true);
echo "最终内存使用: " . formatBytes($finalMemory) . "<br>";
echo "差异: " . formatBytes($finalMemory - $initialMemory) . "<br>";

// 格式化字节数为可读格式
function formatBytes($bytes, $precision = 2) {
    $units = ['B', 'KB', 'MB', 'GB', 'TB'];
    $bytes = max($bytes, 0);
    $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
    $pow = min($pow, count($units) - 1);
    $bytes /= (1 << (10 * $pow));
    return round($bytes, $precision) . ' ' . $units[$pow];
}
?>
```

3. **优化PHP内存配置**：

```ini:c:\php\php.ini
; 设置合理的内存限制
memory_limit = 128M

; 启用垃圾回收
zend.enable_gc = On

; 优化OPcache设置
opcache.memory_consumption = 128
opcache.interned_strings_buffer = 8
opcache.max_accelerated_files = 10000
```

4. **监控并重启异常进程**：

```powershell:c:\project\kphub\scripts\monitor_and_restart.ps1
# 监控并在必要时重启Apache
$memoryThreshold = 500  # MB
$logFile = "c:\project\kphub\logs\memory_monitor.log"

while ($true) {
    $date = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $processes = Get-Process -Name httpd, apache* -ErrorAction SilentlyContinue
    
    if ($processes) {
        $totalMemory = ($processes | Measure-Object -Property WorkingSet -Sum).Sum / 1MB
        $processCount = $processes.Count
        
        "$date - 进程数: $processCount, 总内存: $([math]::Round($totalMemory, 2))MB" | Out-File -FilePath $logFile -Append
        
        # 检查是否超过阈值
        if ($totalMemory -gt $memoryThreshold) {
            "$date - ⚠️ 内存使用超过阈值($memoryThreshold MB)，正在重启Apache..." | Out-File -FilePath $logFile -Append
            
            # 重启Apache服务
            Restart-Service -Name Apache2.4 -Force
            
            "$date - Apache服务已重启" | Out-File -FilePath $logFile -Append
        }
    } else {
        "$date - 未发现Apache进程，尝试启动服务..." | Out-File -FilePath $logFile -Append
        Start-Service -Name Apache2.4 -ErrorAction SilentlyContinue
    }
    
    # 每5分钟检查一次
    Start-Sleep -Seconds 300
}
```

### 3.3 慢请求分析

慢请求会占用服务器资源并降低整体性能。识别和优化这些请求对于提高性能至关重要。

```powershell:c:\project\kphub\scripts\analyze_slow_requests.ps1
# 分析Apache访问日志中的慢请求
param(
    [string]$logFile = "c:\project\kphub\logs\access.log",
    [int]$threshold = 1000,  # 毫秒
    [int]$topCount = 10
)

# 检查日志文件是否存在
if (-not (Test-Path $logFile)) {
    Write-Host "错误: 日志文件不存在: $logFile" -ForegroundColor Red
    exit 1
}

Write-Host "正在分析慢请求 (响应时间 > $threshold ms)..." -ForegroundColor Cyan

# 假设日志格式为: LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\" %D" combined
# %D 是请求处理时间（微秒）
$slowRequests = @()

Get-Content $logFile | ForEach-Object {
    if ($_ -match '.*"([^"]*)".*\s(\d+)$') {
        $request = $matches[1]
        $timeInMicros = [int]$matches[2]
        $timeInMillis = $timeInMicros / 1000
        
        if ($timeInMillis -gt $threshold) {
            $slowRequests += [PSCustomObject]@{
                Request = $request
                Time = $timeInMillis
                Line = $_
            }
        }
    }
}

# 按响应时间排序并显示最慢的请求
if ($slowRequests.Count -gt 0) {
    Write-Host "找到 $($slowRequests.Count) 个慢请求" -ForegroundColor Yellow
    
    Write-Host "`n最慢的 $topCount 个请求:" -ForegroundColor Cyan
    $slowRequests | Sort-Object -Property Time -Descending | Select-Object -First $topCount | ForEach-Object {
        Write-Host "$($_.Request) - $($_.Time) ms" -ForegroundColor $(if ($_.Time -gt $threshold * 2) { "Red" } else { "Yellow" })
    }
    
    # 按URL分组分析
    Write-Host "`n按URL分组的慢请求:" -ForegroundColor Cyan
    $slowRequests | ForEach-Object {
        if ($_.Request -match '^(\w+)\s+([^\s?]+)') {
            $method = $matches[1]
            $url = $matches[2]
            [PSCustomObject]@{
                Method = $method
                URL = $url
                Time = $_.Time
            }
        }
    } | Group-Object -Property URL | Sort-Object -Property { ($_.Group | Measure-Object -Property Time -Average).Average } -Descending | Select-Object -First $topCount | ForEach-Object {
        $avgTime = ($_.Group | Measure-Object -Property Time -Average).Average
        $maxTime = ($_.Group | Measure-Object -Property Time -Maximum).Maximum
        $count = $_.Count
        Write-Host "$($_.Name) - $count 请求, 平均: $([math]::Round($avgTime, 2)) ms, 最大: $([math]::Round($maxTime, 2)) ms" -ForegroundColor $(if ($avgTime -gt $threshold * 2) { "Red" } else { "Yellow" })
    }
} else {
    Write-Host "未找到响应时间超过 $threshold ms 的请求" -ForegroundColor Green
}
```

**优化慢请求的方法：**

1. **启用PHP慢日志**：

```ini:c:\php\php.ini
; 启用慢日志
slowlog = "c:/php/logs/php-slow.log"
request_slowlog_timeout = 2s
```

2. **优化数据库查询**：

```php:c:\project\kphub\www\includes\db_optimize.php
<?php
/**
 * 数据库查询优化示例
 */

// 优化前: 未使用索引的查询
function inefficientQuery($db, $keyword) {
    $sql = "SELECT * FROM articles WHERE content LIKE '%$keyword%'";
    return $db->query($sql);
}

// 优化后: 使用索引和预处理语句
function optimizedQuery($db, $keyword) {
    // 使用FULLTEXT索引
    $sql = "SELECT id, title, SUBSTRING(content, 1, 200) AS content_preview 
            FROM articles 
            WHERE MATCH(title, content) AGAINST(? IN BOOLEAN MODE)
            LIMIT 50";
    
    $stmt = $db->prepare($sql);
    $stmt->bind_param('s', $keyword);
    $stmt->execute();
    
    return $stmt->get_result();
}

// 优化前: N+1查询问题
function inefficientRelationQuery($db, $categoryId) {
    // 获取分类下的所有文章
    $articles = [];
    $sql = "SELECT id, title FROM articles WHERE category_id = ?";
    $stmt = $db->prepare($sql);
    $stmt->bind_param('i', $categoryId);
    $stmt->execute();
    $result = $stmt->get_result();
    
    while ($article = $result->fetch_assoc()) {
        // 对每篇文章单独查询标签 (N+1问题)
        $article['tags'] = [];
        $tagSql = "SELECT tag_name FROM article_tags WHERE article_id = ?";
        $tagStmt = $db->prepare($tagSql);
        $tagStmt->bind_param('i', $article['id']);
        $tagStmt->execute();
        $tagResult = $tagStmt->get_result();
        
        while ($tag = $tagResult->fetch_assoc()) {
            $article['tags'][] = $tag['tag_name'];
        }
        
        $articles[] = $article;
    }
    
    return $articles;
}

// 优化后: 使用JOIN避免N+1查询
function optimizedRelationQuery($db, $categoryId) {
    $sql = "SELECT a.id, a.title, GROUP_CONCAT(t.tag_name) AS tags
            FROM articles a
            LEFT JOIN article_tags t ON a.id = t.article_id
            WHERE a.category_id = ?
            GROUP BY a.id";
    
    $stmt = $db->prepare($sql);
    $stmt->bind_param('i', $categoryId);
    $stmt->execute();
    $result = $stmt->get_result();
    
    $articles = [];
    while ($row = $result->fetch_assoc()) {
        $row['tags'] = $row['tags'] ? explode(',', $row['tags']) : [];
        $articles[] = $row;
    }
    
    return $articles;
}
?>
```

3. **启用页面缓存**：

```php:c:\project\kphub\www\includes\page_cache.php
<?php
/**
 * 简单的页面缓存系统
 */
class PageCache {
    private $cacheDir;
    private $cacheTime;
    private $cacheFile;
    private $isCached = false;
    
    /**
     * 初始化缓存系统
     * 
     * @param string $cacheDir 缓存目录
     * @param int $cacheTime 缓存有效期（秒）
     */
    public function __construct($cacheDir = 'cache', $cacheTime = 3600) {
        $this->cacheDir = rtrim($cacheDir, '/\\') . DIRECTORY_SEPARATOR;
        $this->cacheTime = $cacheTime;
        
        // 创建缓存目录
        if (!is_dir($this->cacheDir)) {
            mkdir($this->cacheDir, 0755, true);
        }
        
        // 生成缓存文件名
        $this->generateCacheFilename();
    }
    
    /**
     * 生成缓存文件名
     */
    private function generateCacheFilename() {
        // 基于当前URL和查询参数生成唯一缓存键
        $cacheKey = $_SERVER['REQUEST_URI'];
        
        // 对于某些页面，可能还需要考虑其他因素（如用户类型）
        if (isset($_COOKIE['user_type'])) {
            $cacheKey .= '_' . $_COOKIE['user_type'];
        }
        
        // 生成文件名
        $this->cacheFile = $this->cacheDir . md5($cacheKey) . '.html';
    }
    
    /**
     * 开始缓存过程
     * 
     * @return bool 如果有有效缓存返回true，否则返回false
     */
    public function start() {
        // 某些请求不应该被缓存
        if ($_SERVER['REQUEST_METHOD'] !== 'GET' || isset($_GET['nocache'])) {
            return false;
        }
        
        // 检查缓存文件是否存在且有效
        if (file_exists($this->cacheFile) && (time() - filemtime($this->cacheFile) < $this->cacheTime)) {
            echo file_get_contents($this->cacheFile);
            $this->isCached = true;
            return true;
        }
        
        // 开始输出缓冲
        ob_start();
        return false;
    }
    
    /**
     * 结束缓存过程并保存缓存
     */
    public function end() {
        // 如果已经从缓存输出，则不需要做任何事
        if ($this->isCached) {
            return;
        }
        
        // 获取缓冲内容并保存到缓存文件
        $content = ob_get_contents();
        file_put_contents($this->cacheFile, $content);
        ob_end_flush();
    }
    
    /**
     * 清除特定缓存或所有缓存
     * 
     * @param string $pattern 文件名模式
     */
    public function clear($pattern = '*') {
        $files = glob($this->cacheDir . $pattern);
        foreach ($files as $file) {
            if (is_file($file)) {
                unlink($file);
            }
        }
    }
}

// 使用示例
/*
$cache = new PageCache();
if (!$cache->start()) {
    // 正常页面处理逻辑
    // ...
    
    // 结束并保存缓存
    $cache->end();
}
*/
?>
```

## 4. 权限问题处理

权限问题是Web服务器配置中最常见的问题之一，尤其是在处理文件上传、日志写入等操作时。

### 4.1 403 Forbidden错误

403错误表示服务器理解请求但拒绝授权。这通常是由于文件系统权限设置不正确导致的。

**检查清单：**

1. **目录权限**：

```powershell:c:\project\kphub\scripts\check_permissions.ps1
# 检查并修复目录权限
param(
    [string]$webRoot = "c:\project\kphub\www",
    [string]$user = "IIS_IUSRS"
)

function Check-Permission {
    param(
        [string]$path,
        [string]$user
    )
    
    if (-not (Test-Path $path)) {
        Write-Host "路径不存在: $path" -ForegroundColor Red
        return $false
    }
    
    $acl = Get-Acl $path
    $access = $acl.Access | Where-Object { $_.IdentityReference.Value -like "*\$user" -or $_.IdentityReference.Value -eq $user }
    
    if ($access) {
        Write-Host "用户 $user 对 $path 的权限:" -ForegroundColor Cyan
        $access | ForEach-Object {
            $rights = $_.FileSystemRights
            Write-Host "  - $rights" -ForegroundColor $(if ($rights -match "Read|ReadAndExecute") { "Green" } else { "Yellow" })
        }
        return $true
    } else {
        Write-Host "用户 $user 没有对 $path 的显式权限" -ForegroundColor Red
        return $false
    }
}

function Set-WebPermission {
    param(
        [string]$path,
        [string]$user,
        [bool]$recursive = $true
    )
    
    if (-not (Test-Path $path)) {
        Write-Host "路径不存在: $path" -ForegroundColor Red
        return
    }
    
    $acl = Get-Acl $path
    $rule = New-Object System.Security.AccessControl.FileSystemAccessRule($user, "ReadAndExecute", "ContainerInherit,ObjectInherit", "None", "Allow")
    $acl.SetAccessRule($rule)
    Set-Acl $path $acl
    
    Write-Host "已设置 $user 对 $path 的读取和执行权限" -ForegroundColor Green
    
    # 为特殊目录设置写入权限
    if ($path -match "\\(uploads|logs|temp|cache)$" -and (Test-Path $path)) {
        $acl = Get-Acl $path
        $rule = New-Object System.Security.AccessControl.FileSystemAccessRule($user, "Modify", "ContainerInherit,ObjectInherit", "None", "Allow")
        $acl.SetAccessRule($rule)
        Set-Acl $path $acl
        
        Write-Host "已设置 $user 对 $path 的修改权限" -ForegroundColor Green
    }
}

# 检查Web根目录权限
Write-Host "检查Web根目录权限..." -ForegroundColor Cyan
$hasPermission = Check-Permission -path $webRoot -user $user

if (-not $hasPermission) {
    $setPermission = Read-Host "是否设置正确的权限? (Y/N)"
    if ($setPermission -eq "Y" -or $setPermission -eq "y") {
        Set-WebPermission -path $webRoot -user $user
    }
}

# 检查特殊目录权限
$specialDirs = @(
    "$webRoot\uploads",
    "$webRoot\logs",
    "$webRoot\temp",
    "$webRoot\cache"
)

foreach ($dir in $specialDirs) {
    if (Test-Path $dir) {
        Write-Host "`n检查特殊目录权限: $dir" -ForegroundColor Cyan
        $hasSpecialPermission = Check-Permission -path $dir -user $user
        
        if (-not $hasSpecialPermission) {
            $setSpecialPermission = Read-Host "是否设置正确的权限? (Y/N)"
            if ($setSpecialPermission -eq "Y" -or $setSpecialPermission -eq "y") {
                Set-WebPermission -path $dir -user $user
            }
        }
    } else {
        Write-Host "`n特殊目录不存在: $dir" -ForegroundColor Yellow
        $createDir = Read-Host "是否创建此目录并设置权限? (Y/N)"
        if ($createDir -eq "Y" -or $createDir -eq "y") {
            New-Item -Path $dir -ItemType Directory
            Set-WebPermission -path $dir -user $user
        }
    }
}
```

2. **Apache配置中的权限设置**：

```apache:c:\project\kphub\conf\httpd.conf
# 确保目录访问权限正确
<Directory "c:/project/kphub/www">
    Options Indexes FollowSymLinks
    AllowOverride All
    Require all granted
</Directory>

# 限制特定目录访问
<Directory "c:/project/kphub/www/admin">
    Options None
    AllowOverride All
    Require all denied
    Require ip 127.0.0.1
    Require host localhost
</Directory>
```

3. **SELinux上下文（Linux系统）**：

```bash:c:\project\kphub\scripts\selinux_context.sh
#!/bin/bash
# 设置正确的SELinux上下文
# 注意：此脚本仅适用于Linux系统

# 检查SELinux状态
if [ -x "$(command -v getenforce)" ]; then
    selinux_status=$(getenforce)
    echo "SELinux状态: $selinux_status"
    
    if [ "$selinux_status" != "Disabled" ]; then
        # 设置Web内容上下文
        echo "设置Web内容SELinux上下文..."
        chcon -R -t httpd_sys_content_t /var/www/html
        
        # 设置可写目录上下文
        echo "设置可写目录SELinux上下文..."
        chcon -R -t httpd_sys_rw_content_t /var/www/html/uploads
        chcon -R -t httpd_sys_rw_content_t /var/www/html/cache
        chcon -R -t httpd_sys_rw_content_t /var/www/html/temp
        
        # 设置CGI脚本上下文
        echo "设置CGI脚本SELinux上下文..."
        chcon -R -t httpd_sys_script_exec_t /var/www/html/cgi-bin
        
        echo "SELinux上下文设置完成"
    else
        echo "SELinux已禁用，无需设置上下文"
    fi
else
    echo "未检测到SELinux，可能不是基于RHEL/CentOS的系统"
fi
```

### 4.2 文件上传失败

文件上传是Web应用程序中常见的功能，但也经常遇到权限和配置问题。

**解决方案：**

1. **配置上传目录权限**：

```apache:c:\project\kphub\conf\extra\httpd-php.conf
# 为上传目录配置特殊权限
<Directory "c:/project/kphub/www/uploads">
    Options None
    AllowOverride None
    Require all granted
    
    # 禁止执行上传的脚本
    <FilesMatch "\.ph(p[3-5]?|tml)$">
        Require all denied
    </FilesMatch>
    
    # PHP设置
    <IfModule mod_php.c>
        php_admin_value upload_max_filesize 100M
        php_admin_value post_max_size 100M
        php_admin_value max_execution_time 300
        php_admin_value max_input_time 300
    </IfModule>
</Directory>
```

2. **创建并设置上传目录权限**：

```powershell:c:\project\kphub\scripts\setup_upload_dir.ps1
# 设置上传目录
$uploadDir = "c:\project\kphub\www\uploads"
$tempDir = "c:\project\kphub\www\uploads\temp"
$user = "IIS_IUSRS"

# 创建目录（如果不存在）
if (-not (Test-Path $uploadDir)) {
    New-Item -Path $uploadDir -ItemType Directory
    Write-Host "创建上传目录: $uploadDir" -ForegroundColor Green
}

if (-not (Test-Path $tempDir)) {
    New-Item -Path $tempDir -ItemType Directory
    Write-Host "创建临时上传目录: $tempDir" -ForegroundColor Green
}

# 设置权限
$acl = Get-Acl $uploadDir
$rule = New-Object System.Security.AccessControl.FileSystemAccessRule($user, "Modify", "ContainerInherit,ObjectInherit", "None", "Allow")
$acl.SetAccessRule($rule)
Set-Acl $uploadDir $acl

$acl = Get-Acl $tempDir
$rule = New-Object System.Security.AccessControl.FileSystemAccessRule($user, "Modify", "ContainerInherit,ObjectInherit", "None", "Allow")
$acl.SetAccessRule($rule)
Set-Acl $tempDir $acl

Write-Host "已设置上传目录权限" -ForegroundColor Green

# 创建.htaccess文件禁止执行PHP
$htaccessContent = @"
# 禁止执行PHP文件
<FilesMatch "\.ph(p[3-5]?|tml)$">
    Require all denied
</FilesMatch>

# 允许常见的图片和文档类型
<FilesMatch "\.(?i:jpe?g|png|gif|pdf|docx?|xlsx?|pptx?|zip|rar|txt)$">
    Require all granted
</FilesMatch>
"@

$htaccessContent | Out-File -FilePath "$uploadDir\.htaccess" -Encoding ASCII
Write-Host "已创建保护性.htaccess文件" -ForegroundColor Green

# 检查PHP配置
$phpIni = "c:\php\php.ini"
if (Test-Path $phpIni) {
    $phpConfig = Get-Content $phpIni
    
    $uploadMaxFilesize = $phpConfig | Select-String "upload_max_filesize\s*=\s*(\d+)M"
    $postMaxSize = $phpConfig | Select-String "post_max_size\s*=\s*(\d+)M"
    
    Write-Host "`nPHP上传设置:" -ForegroundColor Cyan
    if ($uploadMaxFilesize) {
        Write-Host "upload_max_filesize = $($uploadMaxFilesize.Matches.Groups[1].Value)M"
    } else {
        Write-Host "未找到upload_max_filesize设置" -ForegroundColor Yellow
    }
    
    if ($postMaxSize) {
        Write-Host "post_max_size = $($postMaxSize.Matches.Groups[1].Value)M"
    } else {
        Write-Host "未找到post_max_size设置" -ForegroundColor Yellow
    }
}
```

3. **PHP上传处理示例**：

```php:c:\project\kphub\www\includes\upload_handler.php
<?php
/**
 * 安全的文件上传处理类
 */
class UploadHandler {
    private $uploadDir;
    private $tempDir;
    private $allowedTypes;
    private $maxSize;
    private $errors = [];
    
    /**
     * 初始化上传处理器
     * 
     * @param string $uploadDir 上传目录
     * @param array $allowedTypes 允许的MIME类型
     * @param int $maxSize 最大文件大小(字节)
     */
    public function __construct($uploadDir = 'uploads', $allowedTypes = [], $maxSize = 104857600) {
        $this->uploadDir = rtrim($uploadDir, '/\\') . DIRECTORY_SEPARATOR;
        $this->tempDir = $this->uploadDir . 'temp' . DIRECTORY_SEPARATOR;
        $this->allowedTypes = $allowedTypes ?: [
            'image/jpeg', 'image/png', 'image/gif',
            'application/pdf', 'application/msword',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
        ];
        $this->maxSize = $maxSize;
        
        // 确保目录存在
        $this->ensureDirectoryExists($this->uploadDir);
        $this->ensureDirectoryExists($this->tempDir);
    }
    
    /**
     * 确保目录存在
     * 
     * @param string $dir 目录路径
     * @return bool 成功标志
     */
    private function ensureDirectoryExists($dir) {
        if (!is_dir($dir)) {
            if (!mkdir($dir, 0
让我继续完成文件上传处理类的代码：

```php:c:\project\kphub\www\includes\upload_handler.php
    private function ensureDirectoryExists($dir) {
        if (!is_dir($dir)) {
            if (!mkdir($dir, 0755, true)) {
                $this->errors[] = "无法创建目录: $dir";
                return false;
            }
        }
        
        if (!is_writable($dir)) {
            $this->errors[] = "目录不可写: $dir";
            return false;
        }
        
        return true;
    }
    
    /**
     * 处理文件上传
     * 
     * @param string $fieldName 表单字段名
     * @param bool $useOriginalName 是否使用原始文件名
     * @return array 上传结果
     */
    public function handleUpload($fieldName, $useOriginalName = false) {
        // 检查是否有文件上传
        if (!isset($_FILES[$fieldName])) {
            $this->errors[] = "没有文件被上传";
            return ['success' => false, 'errors' => $this->errors];
        }
        
        $file = $_FILES[$fieldName];
        
        // 处理多文件上传
        if (is_array($file['name'])) {
            return $this->handleMultipleUploads($file, $useOriginalName);
        }
        
        // 检查上传错误
        if ($file['error'] !== UPLOAD_ERR_OK) {
            $this->errors[] = $this->getUploadErrorMessage($file['error']);
            return ['success' => false, 'errors' => $this->errors];
        }
        
        // 检查文件大小
        if ($file['size'] > $this->maxSize) {
            $this->errors[] = "文件大小超过限制 (" . $this->formatSize($this->maxSize) . ")";
            return ['success' => false, 'errors' => $this->errors];
        }
        
        // 检查MIME类型
        $finfo = new finfo(FILEINFO_MIME_TYPE);
        $mimeType = $finfo->file($file['tmp_name']);
        
        if (!in_array($mimeType, $this->allowedTypes)) {
            $this->errors[] = "不允许的文件类型: $mimeType";
            return ['success' => false, 'errors' => $this->errors];
        }
        
        // 生成安全的文件名
        $originalName = $file['name'];
        $extension = pathinfo($originalName, PATHINFO_EXTENSION);
        
        if ($useOriginalName) {
            // 清理原始文件名
            $filename = $this->sanitizeFilename($originalName);
        } else {
            // 生成随机文件名
            $filename = bin2hex(random_bytes(16)) . '.' . $extension;
        }
        
        // 确保文件名唯一
        $filename = $this->ensureUniqueFilename($filename);
        
        // 移动到临时目录进行处理
        $tempPath = $this->tempDir . $filename;
        if (!move_uploaded_file($file['tmp_name'], $tempPath)) {
            $this->errors[] = "无法移动上传的文件";
            return ['success' => false, 'errors' => $this->errors];
        }
        
        // 处理图片（如果适用）
        if (strpos($mimeType, 'image/') === 0) {
            $this->processImage($tempPath, $mimeType);
        }
        
        // 移动到最终目录
        $finalPath = $this->uploadDir . $filename;
        if (!rename($tempPath, $finalPath)) {
            $this->errors[] = "无法移动处理后的文件";
            return ['success' => false, 'errors' => $this->errors];
        }
        
        // 返回成功结果
        return [
            'success' => true,
            'filename' => $filename,
            'original_name' => $originalName,
            'path' => $finalPath,
            'url' => $this->getFileUrl($filename),
            'size' => $file['size'],
            'mime_type' => $mimeType
        ];
    }
    
    /**
     * 处理多文件上传
     * 
     * @param array $files 文件数组
     * @param bool $useOriginalName 是否使用原始文件名
     * @return array 上传结果
     */
    private function handleMultipleUploads($files, $useOriginalName) {
        $results = [
            'success' => true,
            'files' => [],
            'errors' => []
        ];
        
        for ($i = 0; $i < count($files['name']); $i++) {
            $file = [
                'name' => $files['name'][$i],
                'type' => $files['type'][$i],
                'tmp_name' => $files['tmp_name'][$i],
                'error' => $files['error'][$i],
                'size' => $files['size'][$i]
            ];
            
            // 重置错误数组
            $this->errors = [];
            
            // 处理单个文件
            $_FILES['temp_file'] = $file;
            $result = $this->handleUpload('temp_file', $useOriginalName);
            
            if ($result['success']) {
                $results['files'][] = $result;
            } else {
                $results['success'] = false;
                $results['errors'][] = [
                    'file' => $file['name'],
                    'errors' => $result['errors']
                ];
            }
        }
        
        return $results;
    }
    
    /**
     * 获取上传错误消息
     * 
     * @param int $errorCode 错误代码
     * @return string 错误消息
     */
    private function getUploadErrorMessage($errorCode) {
        $errors = [
            UPLOAD_ERR_INI_SIZE => '上传的文件超过了php.ini中upload_max_filesize指令的限制',
            UPLOAD_ERR_FORM_SIZE => '上传的文件超过了HTML表单中MAX_FILE_SIZE指令的限制',
            UPLOAD_ERR_PARTIAL => '文件只有部分被上传',
            UPLOAD_ERR_NO_FILE => '没有文件被上传',
            UPLOAD_ERR_NO_TMP_DIR => '找不到临时文件夹',
            UPLOAD_ERR_CANT_WRITE => '无法写入磁盘',
            UPLOAD_ERR_EXTENSION => '文件上传被PHP扩展停止'
        ];
        
        return isset($errors[$errorCode]) ? $errors[$errorCode] : '未知上传错误';
    }
    
    /**
     * 清理文件名
     * 
     * @param string $filename 原始文件名
     * @return string 清理后的文件名
     */
    private function sanitizeFilename($filename) {
        // 移除非法字符
        $filename = preg_replace('/[^\w\-\.]/u', '_', $filename);
        // 移除多余的下划线
        $filename = preg_replace('/_+/', '_', $filename);
        // 限制长度
        $maxLength = 100;
        if (strlen($filename) > $maxLength) {
            $extension = pathinfo($filename, PATHINFO_EXTENSION);
            $filenameWithoutExt = pathinfo($filename, PATHINFO_FILENAME);
            $filename = substr($filenameWithoutExt, 0, $maxLength - strlen($extension) - 1) . '.' . $extension;
        }
        
        return $filename;
    }
    
    /**
     * 确保文件名唯一
     * 
     * @param string $filename 文件名
     * @return string 唯一文件名
     */
    private function ensureUniqueFilename($filename) {
        $pathInfo = pathinfo($filename);
        $basename = $pathInfo['filename'];
        $extension = isset($pathInfo['extension']) ? '.' . $pathInfo['extension'] : '';
        
        $counter = 1;
        $newFilename = $filename;
        
        while (file_exists($this->uploadDir . $newFilename)) {
            $newFilename = $basename . '_' . $counter . $extension;
            $counter++;
        }
        
        return $newFilename;
    }
    
    /**
     * 处理图片
     * 
     * @param string $imagePath 图片路径
     * @param string $mimeType MIME类型
     */
    private function processImage($imagePath, $mimeType) {
        // 检查GD库是否可用
        if (!extension_loaded('gd')) {
            return;
        }
        
        // 根据MIME类型创建图像
        switch ($mimeType) {
            case 'image/jpeg':
                $image = imagecreatefromjpeg($imagePath);
                break;
            case 'image/png':
                $image = imagecreatefrompng($imagePath);
                break;
            case 'image/gif':
                $image = imagecreatefromgif($imagePath);
                break;
            default:
                return;
        }
        
        if (!$image) {
            return;
        }
        
        // 移除EXIF数据（仅适用于JPEG）
        if ($mimeType === 'image/jpeg') {
            // 保存没有EXIF数据的图像
            imagejpeg($image, $imagePath, 90);
        }
        
        // 创建缩略图（可选）
        $this->createThumbnail($image, $imagePath, $mimeType);
        
        // 释放内存
        imagedestroy($image);
    }
    
    /**
     * 创建缩略图
     * 
     * @param resource $image 图像资源
     * @param string $originalPath 原始图片路径
     * @param string $mimeType MIME类型
     */
    private function createThumbnail($image, $originalPath, $mimeType) {
        // 缩略图尺寸
        $thumbWidth = 200;
        $thumbHeight = 200;
        
        // 获取原始尺寸
        $width = imagesx($image);
        $height = imagesy($image);
        
        // 计算缩放比例
        $ratio = min($thumbWidth / $width, $thumbHeight / $height);
        $newWidth = $width * $ratio;
        $newHeight = $height * $ratio;
        
        // 创建缩略图
        $thumb = imagecreatetruecolor($newWidth, $newHeight);
        
        // 保持PNG透明度
        if ($mimeType === 'image/png') {
            imagealphablending($thumb, false);
            imagesavealpha($thumb, true);
        }
        
        // 调整图像大小
        imagecopyresampled($thumb, $image, 0, 0, 0, 0, $newWidth, $newHeight, $width, $height);
        
        // 生成缩略图文件名
        $pathInfo = pathinfo($originalPath);
        $thumbPath = $pathInfo['dirname'] . DIRECTORY_SEPARATOR . 'thumb_' . $pathInfo['basename'];
        
        // 保存缩略图
        switch ($mimeType) {
            case 'image/jpeg':
                imagejpeg($thumb, $thumbPath, 80);
                break;
            case 'image/png':
                imagepng($thumb, $thumbPath, 8);
                break;
            case 'image/gif':
                imagegif($thumb, $thumbPath);
                break;
        }
        
        // 释放内存
        imagedestroy($thumb);
    }
    
    /**
     * 获取文件URL
     * 
     * @param string $filename 文件名
     * @return string 文件URL
     */
    private function getFileUrl($filename) {
        // 基于当前请求构建URL
        $protocol = (!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off') ? 'https://' : 'http://';
        $host = $_SERVER['HTTP_HOST'];
        
        // 从上传目录提取相对路径
        $docRoot = rtrim($_SERVER['DOCUMENT_ROOT'], '/\\');
        $uploadDirRelative = str_replace($docRoot, '', $this->uploadDir);
        $uploadDirRelative = str_replace('\\', '/', $uploadDirRelative);
        
        return $protocol . $host . $uploadDirRelative . $filename;
    }
    
    /**
     * 格式化文件大小
     * 
     * @param int $bytes 字节数
     * @param int $precision 精度
     * @return string 格式化后的大小
     */
    private function formatSize($bytes, $precision = 2) {
        $units = ['B', 'KB', 'MB', 'GB', 'TB'];
        $bytes = max($bytes, 0);
        $pow = floor(($bytes ? log($bytes) : 0) / log(1024));
        $pow = min($pow, count($units) - 1);
        $bytes /= (1 << (10 * $pow));
        
        return round($bytes, $precision) . ' ' . $units[$pow];
    }
    
    /**
     * 获取错误信息
     * 
     * @return array 错误信息数组
     */
    public function getErrors() {
        return $this->errors;
    }
}

// 使用示例
/*
$uploader = new UploadHandler('uploads', ['image/jpeg', 'image/png', 'application/pdf'], 10 * 1024 * 1024);
$result = $uploader->handleUpload('file');

if ($result['success']) {
    echo "文件上传成功: " . $result['filename'];
} else {
    echo "上传失败: " . implode(', ', $result['errors']);
}
*/
?>
```

## 5. 日志分析技巧

日志分析是排查问题和监控系统健康状况的重要工具。Apache和PHP都提供了详细的日志记录功能。

### 5.1 错误日志筛选

错误日志包含了服务器运行时遇到的各种问题，是排查故障的首要资源。

```powershell:c:\project\kphub\scripts\filter_log.ps1
# 高级错误日志分析工具
param(
    [string]$logFile = "c:\project\kphub\logs\error.log",
    [string]$pattern = "error|fail|fatal|exception",
    [int]$lines = 100,
    [switch]$exportCsv,
    [string]$outputCsv = "c:\project\kphub\logs\error_analysis.csv"
)

# 检查日志文件是否存在
if (-not (Test-Path $logFile)) {
    Write-Host "错误: 日志文件不存在: $logFile" -ForegroundColor Red
    exit 1
}

# 获取日志文件大小
$fileSize = (Get-Item $logFile).Length
$fileSizeMB = [math]::Round($fileSize / 1MB, 2)
Write-Host "分析日志文件: $logFile ($fileSizeMB MB)" -ForegroundColor Cyan

# 定义错误级别颜色
$errorLevelColors = @{
    "emerg" = "Red"
    "alert" = "Red"
    "crit" = "Red"
    "error" = "Red"
    "warn" = "Yellow"
    "notice" = "Yellow"
    "info" = "Green"
    "debug" = "Gray"
}

# 解析Apache错误日志行
function Parse-ApacheErrorLog {
    param([string]$line)
    
    # 尝试匹配Apache错误日志格式
    if ($line -match '\[(.*?)\] \[(\w+):(\w+)\] \[pid (\d+)\] (.+)') {
        return @{
            Timestamp = $matches[1]
            Module = $matches[2]
            Level = $matches[3]
            PID = $matches[4]
            Message = $matches[5]
            Raw = $line
        }
    }
    # 尝试匹配PHP错误格式
    elseif ($line -match '\[(.*?)\] PHP (\w+):\s+(.+) in (.+) on line (\d+)') {
        return @{
            Timestamp = $matches[1]
            Module = "php"
            Level = $matches[2].ToLower()
            Message = $matches[3]
            File = $matches[4]
            Line = $matches[5]
            Raw = $line
        }
    }
    # 其他格式
    else {
        return @{
            Raw = $line
            Message = $line
            Level = "unknown"
        }
    }
}

# 筛选日志
Write-Host "正在筛选包含 '$pattern' 的日志条目..." -ForegroundColor Cyan
$matchedLines = Select-String -Path $logFile -Pattern $pattern -AllMatches

if ($matchedLines.Count -eq 0) {
    Write-Host "未找到匹配的日志条目" -ForegroundColor Yellow
    exit 0
}

Write-Host "找到 $($matchedLines.Count) 条匹配的日志条目" -ForegroundColor Green

# 解析并显示结果
$parsedEntries = @()
$matchedLines | Select-Object -Last $lines | ForEach-Object {
    $entry = Parse-ApacheErrorLog -line $_.Line
    $parsedEntries += $entry
    
    # 显示带颜色的日志条目
    $color = $errorLevelColors[$entry.Level]
    if (-not $color) { $color = "White" }
    
    if ($entry.ContainsKey("Timestamp")) {
        Write-Host "[$($entry.Timestamp)]" -NoNewline
        Write-Host " [$($entry.Module):$($entry.Level)]" -ForegroundColor $color -NoNewline
        
        if ($entry.ContainsKey("PID")) {
            Write-Host " [pid $($entry.PID)]" -NoNewline
        }
        
        Write-Host " $($entry.Message)" -ForegroundColor $color
        
        if ($entry.ContainsKey("File")) {
            Write-Host "  在文件 $($entry.File) 第 $($entry.Line) 行" -ForegroundColor DarkGray
        }
    } else {
        Write-Host $entry.Raw -ForegroundColor $color
    }
}

# 分析错误模式
$errorsByModule = $parsedEntries | Group-Object -Property Module | Sort-Object -Property Count -Descending
$errorsByLevel = $parsedEntries | Group-Object -Property Level | Sort-Object -Property Count -Descending

Write-Host "`n错误分布 (按模块):" -ForegroundColor Cyan
$errorsByModule | ForEach-Object {
    Write-Host "$($_.Name): $($_.Count) 条" -ForegroundColor $(if ($_.Count -gt 10) { "Yellow" } else { "White" })
}

Write-Host "`n错误分布 (按级别):" -ForegroundColor Cyan
$errorsByLevel | ForEach-Object {
    $color = $errorLevelColors[$_.Name]
    if (-not $color) { $color = "White" }
    Write-Host "$($_.Name): $($_.Count) 条" -ForegroundColor $color
}

# 导出CSV
if ($exportCsv) {
    $parsedEntries | Select-Object Timestamp, Module, Level, Message, File, Line, PID | 
    Export-Csv -Path $outputCsv -NoTypeInformation -Encoding UTF8
    
    Write-Host "`n已导出分析结果到: $outputCsv" -ForegroundColor Green
}
```

### 5.2 访问日志分析

访问日志记录了所有对服务器的请求，可用于分析流量模式、性能问题和安全威胁。

```powershell:c:\project\kphub\scripts\analyze_access_log.ps1
# 访问日志分析工具
param(
    [string]$logFile = "c:\project\kphub\logs\access.log",
    [int]$topCount = 10,
    [switch]$exportReport,
    [string]$reportFile = "c:\project\kphub\logs\access_report.html"
)

# 检查日志文件是否存在
if (-not (Test-Path $logFile)) {
    Write-Host "错误: 日志文件不存在: $logFile" -ForegroundColor Red
    exit 1
}

# 获取日志文件大小和行数
$fileSize = (Get-Item $logFile).Length
$fileSizeMB = [math]::Round($fileSize / 1MB, 2)
$lineCount = (Get-Content $logFile).Count
Write-Host "分析日志文件: $logFile ($fileSizeMB MB, $lineCount 行)" -ForegroundColor Cyan

# 解析Apache访问日志
function Parse-ApacheAccessLog {
    param([string]$line)
    
    # 尝试匹配常见的Apache访问日志格式
    # 格式: LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-Agent}i\"" combined
    if ($line -match '(\S+) (\S+) (\S+) \[(.*?)\] "(.*?)" (\d+) (\S+) "(.*?)" "(.*?)"') {
        $request = $matches[5]
        $method = ""
        $url = ""
        $protocol = ""
        
        if ($request -match '^(\S+) (\S+)( HTTP/[\d\.]+)?$') {
            $method = $matches[1]
            $url = $matches[2]
            $protocol = $matches[3]
        }
        
        return @{
            IPAddress = $matches[1]
            Identity = $matches[2]
            User = $matches[3]
            Timestamp = $matches[4]
            Request = $request
            Method = $method
            URL = $url
            Protocol = $protocol
            StatusCode = [int]$matches[6]
            Bytes = if ($matches[7] -eq "-") { 0 } else { [int]$matches[7] }
            Referer = $matches[8]
            UserAgent = $matches[9]
            Raw = $line
        }
    }
    else {
        return @{
            Raw = $line
        }
    }
}

# 读取并解析日志
Write-Host "正在解析日志文件..." -ForegroundColor Cyan
$logEntries = @()
$statusCodes = @{}
$ipAddresses = @{}
$urls = @{}
$userAgents = @{}
$methods = @{}
$hourlyTraffic = @{}
$errors = @()

Get-Content $logFile | ForEach-Object {
    $entry = Parse-ApacheAccessLog -line $_
    
    if ($entry.ContainsKey("StatusCode")) {
        $logEntries += $entry
        
        # 统计状态码
        $statusCode = $entry.StatusCode
        if ($statusCodes.ContainsKey($statusCode)) {
            $statusCodes[$statusCode]++
        } else {
            $statusCodes[$statusCode] = 1
        }
        
        # 统计IP地址
        $ip = $entry.IPAddress
        if ($ipAddresses.ContainsKey($ip)) {
            $ipAddresses[$ip]++
        } else {
            $ipAddresses[$ip] = 1
        }
        
        # 统计URL
        $url = $entry.URL
        if ($url -and $urls.ContainsKey($url)) {
            $urls[$url]++
        } elseif ($url) {
            $urls[$url] = 1
        }
        
        # 统计User Agent
        $ua = $entry.UserAgent
        if ($userAgents.ContainsKey($ua)) {
            $userAgents[$ua]++
        } else {
            $userAgents[$ua] = 1
        }
        
        # 统计请求方法
        $method = $entry.Method
        if ($method -and $methods.ContainsKey($method)) {
            $methods[$method]++
        } elseif ($method) {
            $methods[$method] = 1
        }
        
        # 按小时统计流量
        if ($entry.Timestamp -match '(\d+)/(\w+)/(\d+):(\d+)') {
            $hour = $matches[4]
            if ($hourlyTraffic.ContainsKey($hour)) {
                $hourlyTraffic[$hour]++
            } else {
                $hourlyTraffic[$hour] = 1
            }
        }
        
        # 收集错误
        if ($statusCode -ge 400) {
            $errors += $entry
        }
    }
}

# 显示基本统计信息
Write-Host "`n基本统计信息:" -ForegroundColor Cyan
Write-Host "总请求数: $($logEntries.Count)"
Write-Host "唯一IP地址数: $($ipAddresses.Keys.Count)"
Write-Host "唯一URL数: $($urls.Keys.Count)"
Write-Host "错误请求数: $($errors.Count) ($(if ($logEntries.Count -gt 0) { [math]::Round(($errors.Count / $logEntries.Count) * 100, 2) } else { 0 })%)"

# 显示HTTP状态码分布
Write-Host "`nHTTP状态码分布:" -ForegroundColor Cyan
$statusCodes.GetEnumerator() | Sort-Object Name | ForEach-Object {
    $code = $_.Key
    $count = $_.Value
    $percent = if ($logEntries.Count -gt 0) { [math]::Round(($count / $logEntries.Count) * 100, 2) } else { 0 }
    
    $color = "White"
    if ($code -ge 500) { $color = "Red" }
    elseif ($code -ge 400) { $color = "Yellow" }
    elseif ($code -ge 300) { $color = "Cyan" }
    elseif ($code -ge 200) { $color = "Green" }
    
    Write-Host "$code : $count ($percent%)" -ForegroundColor $color
}

# 显示最常见的IP地址
Write-Host "`n最常见的IP地址 (前$topCount):" -ForegroundColor Cyan
$ipAddresses.GetEnumerator() | Sort-Object Value -Descending | Select-Object -First $topCount | ForEach-Object {
    Write-Host "$($_.Key) : $($_.Value) 请求"
}

# 显示最常访问的URL
Write-Host "`n最常访问的URL (前$topCount):" -ForegroundColor Cyan
$urls.GetEnumerator() | Sort-Object Value -Descending | Select-Object -First $topCount | ForEach-Object {
    Write-Host "$($_.Key) : $($_.Value) 请求"
}

# 显示请求方法分布
Write-Host "`n请求方法分布:" -ForegroundColor Cyan
$methods.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {
    Write-Host "$($_.Key) : $($_.Value) 请求"
}

# 显示最常见的错误
if ($errors.Count -gt 0) {
    Write-Host "`n最常见的错误 (前$topCount):" -ForegroundColor Yellow
    $errorUrls = @{}
    $errors | ForEach-Object {
        $key = "$($_.StatusCode) $($_.URL)"
        if ($errorUrls.ContainsKey($key)) {
            $errorUrls[$key]++
        } else {
            $errorUrls[$key] = 1
        }
    }
    
    $errorUrls.GetEnumerator() | Sort-Object Value -Descending | Select-Object -First $topCount | ForEach-Object {
        Write-Host "$($_.Key) : $($_.Value) 次" -ForegroundColor $(if ($_.Key -match "^5") { "Red" } else { "Yellow" })
    }
}

# 导出HTML报告
if ($exportReport) {
    $htmlReport = @"
<!DOCTYPE html>
<html>
<head>
    <title>Apache访问日志分析报告</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1, h2 { color: #333; }
        .container { max-width: 1200px; margin: 0 auto; }
        .stat-box { background: #f5f5f5; padding: 15px; margin-bottom: 20px; border-radius: 5px; }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f2f2f2; }
        .code-200 { color: green; }
        .code-300 { color: blue; }
        .code-400 { color: orange; }
        .code-500 { color: red; }
        .chart { height: 300px; margin-bottom: 30px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <h1>Apache访问日志分析报告</h1>
        <p>日志文件: $logFile</p>
        <p>分析时间: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")</p>
        
        <div class="stat-box">
            <h2>基本统计信息</h2>
            <table>
                <tr><th>指标</th><th>值</th></tr>
                <tr><td>总请求数</td><td>$($logEntries.Count)</td></tr>
                <tr><td>唯一IP地址数</td><td>$($ipAddresses.Keys.Count)</td></tr>
                <tr><td>唯一URL数</td><td>$($urls.Keys.Count)</td></tr>
                <tr><td>错误请求数</td><td>$($errors.Count) ($(if ($logEntries.Count -
让我继续完成访问日志分析工具的HTML报告部分：

```powershell:c:\project\kphub\scripts\analyze_access_log.ps1
                <tr><td>错误请求数</td><td>$($errors.Count) ($(if ($logEntries.Count -gt 0) { [math]::Round(($errors.Count / $logEntries.Count) * 100, 2) } else { 0 })%)</td></tr>
            </table>
        </div>
        
        <div class="stat-box">
            <h2>HTTP状态码分布</h2>
            <div class="chart">
                <canvas id="statusChart"></canvas>
            </div>
            <table>
                <tr><th>状态码</th><th>请求数</th><th>百分比</th></tr>
"@

    # 添加状态码表格行
    $statusCodes.GetEnumerator() | Sort-Object Name | ForEach-Object {
        $code = $_.Key
        $count = $_.Value
        $percent = if ($logEntries.Count -gt 0) { [math]::Round(($count / $logEntries.Count) * 100, 2) } else { 0 }
        $cssClass = "code-" + [math]::Floor($code / 100) + "00"
        
        $htmlReport += @"
                <tr><td class="$cssClass">$code</td><td>$count</td><td>$percent%</td></tr>
"@
    }

    $htmlReport += @"
            </table>
        </div>
        
        <div class="stat-box">
            <h2>最常见的IP地址 (前$topCount)</h2>
            <div class="chart">
                <canvas id="ipChart"></canvas>
            </div>
            <table>
                <tr><th>IP地址</th><th>请求数</th></tr>
"@

    # 添加IP地址表格行
    $ipAddresses.GetEnumerator() | Sort-Object Value -Descending | Select-Object -First $topCount | ForEach-Object {
        $htmlReport += @"
                <tr><td>$($_.Key)</td><td>$($_.Value)</td></tr>
"@
    }

    $htmlReport += @"
            </table>
        </div>
        
        <div class="stat-box">
            <h2>最常访问的URL (前$topCount)</h2>
            <div class="chart">
                <canvas id="urlChart"></canvas>
            </div>
            <table>
                <tr><th>URL</th><th>请求数</th></tr>
"@

    # 添加URL表格行
    $urls.GetEnumerator() | Sort-Object Value -Descending | Select-Object -First $topCount | ForEach-Object {
        $htmlReport += @"
                <tr><td>$($_.Key)</td><td>$($_.Value)</td></tr>
"@
    }

    $htmlReport += @"
            </table>
        </div>
        
        <div class="stat-box">
            <h2>请求方法分布</h2>
            <div class="chart">
                <canvas id="methodChart"></canvas>
            </div>
            <table>
                <tr><th>方法</th><th>请求数</th></tr>
"@

    # 添加请求方法表格行
    $methods.GetEnumerator() | Sort-Object Value -Descending | ForEach-Object {
        $htmlReport += @"
                <tr><td>$($_.Key)</td><td>$($_.Value)</td></tr>
"@
    }

    $htmlReport += @"
            </table>
        </div>
        
        <div class="stat-box">
            <h2>按小时流量分布</h2>
            <div class="chart">
                <canvas id="hourlyChart"></canvas>
            </div>
        </div>
"@

    # 如果有错误，添加错误部分
    if ($errors.Count -gt 0) {
        $htmlReport += @"
        <div class="stat-box">
            <h2>最常见的错误 (前$topCount)</h2>
            <table>
                <tr><th>状态码</th><th>URL</th><th>次数</th></tr>
"@

        $errorUrls = @{}
        $errors | ForEach-Object {
            $key = "$($_.StatusCode) $($_.URL)"
            if ($errorUrls.ContainsKey($key)) {
                $errorUrls[$key]++
            } else {
                $errorUrls[$key] = 1
            }
        }
        
        $errorUrls.GetEnumerator() | Sort-Object Value -Descending | Select-Object -First $topCount | ForEach-Object {
            $parts = $_.Key -split " ", 2
            $code = $parts[0]
            $url = $parts[1]
            $cssClass = "code-" + [math]::Floor([int]$code / 100) + "00"
            
            $htmlReport += @"
                <tr><td class="$cssClass">$code</td><td>$url</td><td>$($_.Value)</td></tr>
"@
        }

        $htmlReport += @"
            </table>
        </div>
"@
    }

    # 添加JavaScript图表
    $htmlReport += @"
        <script>
            // 状态码图表
            const statusCtx = document.getElementById('statusChart').getContext('2d');
            new Chart(statusCtx, {
                type: 'pie',
                data: {
                    labels: [$(($statusCodes.Keys | ForEach-Object { "'$_'" }) -join ', ')],
                    datasets: [{
                        data: [$(($statusCodes.Values) -join ', ')],
                        backgroundColor: [
                            $(($statusCodes.Keys | ForEach-Object {
                                $color = switch ([math]::Floor([int]$_ / 100)) {
                                    2 { "'rgba(75, 192, 192, 0.8)'" }
                                    3 { "'rgba(54, 162, 235, 0.8)'" }
                                    4 { "'rgba(255, 206, 86, 0.8)'" }
                                    5 { "'rgba(255, 99, 132, 0.8)'" }
                                    default { "'rgba(201, 203, 207, 0.8)'" }
                                }
                                return $color
                            }) -join ', ')
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { position: 'right' },
                        title: { display: true, text: 'HTTP状态码分布' }
                    }
                }
            });
            
            // IP地址图表
            const ipCtx = document.getElementById('ipChart').getContext('2d');
            new Chart(ipCtx, {
                type: 'bar',
                data: {
                    labels: [$(($ipAddresses.GetEnumerator() | Sort-Object Value -Descending | Select-Object -First $topCount | ForEach-Object { "'$($_.Key)'" }) -join ', ')],
                    datasets: [{
                        label: '请求数',
                        data: [$(($ipAddresses.GetEnumerator() | Sort-Object Value -Descending | Select-Object -First $topCount | ForEach-Object { $_.Value }) -join ', ')],
                        backgroundColor: 'rgba(54, 162, 235, 0.8)'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: false },
                        title: { display: true, text: '最常见的IP地址' }
                    },
                    scales: {
                        y: { beginAtZero: true }
                    }
                }
            });
            
            // URL图表
            const urlCtx = document.getElementById('urlChart').getContext('2d');
            new Chart(urlCtx, {
                type: 'bar',
                data: {
                    labels: [$(($urls.GetEnumerator() | Sort-Object Value -Descending | Select-Object -First $topCount | ForEach-Object { 
                        $url = $_.Key
                        if ($url.Length -gt 30) {
                            $url = $url.Substring(0, 27) + "..."
                        }
                        "'$url'"
                    }) -join ', ')],
                    datasets: [{
                        label: '请求数',
                        data: [$(($urls.GetEnumerator() | Sort-Object Value -Descending | Select-Object -First $topCount | ForEach-Object { $_.Value }) -join ', ')],
                        backgroundColor: 'rgba(75, 192, 192, 0.8)'
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: false },
                        title: { display: true, text: '最常访问的URL' }
                    },
                    scales: {
                        y: { beginAtZero: true }
                    }
                }
            });
            
            // 请求方法图表
            const methodCtx = document.getElementById('methodChart').getContext('2d');
            new Chart(methodCtx, {
                type: 'doughnut',
                data: {
                    labels: [$(($methods.Keys | ForEach-Object { "'$_'" }) -join ', ')],
                    datasets: [{
                        data: [$(($methods.Values) -join ', ')],
                        backgroundColor: [
                            'rgba(255, 99, 132, 0.8)',
                            'rgba(54, 162, 235, 0.8)',
                            'rgba(255, 206, 86, 0.8)',
                            'rgba(75, 192, 192, 0.8)',
                            'rgba(153, 102, 255, 0.8)'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { position: 'right' },
                        title: { display: true, text: '请求方法分布' }
                    }
                }
            });
            
            // 按小时流量图表
            const hourlyCtx = document.getElementById('hourlyChart').getContext('2d');
            new Chart(hourlyCtx, {
                type: 'line',
                data: {
                    labels: [$(0..23 | ForEach-Object { "'$_:00'" } | Join-String -Separator ', ')],
                    datasets: [{
                        label: '请求数',
                        data: [$(0..23 | ForEach-Object { 
                            $hour = $_.ToString()
                            if ($hourlyTraffic.ContainsKey($hour)) { $hourlyTraffic[$hour] } else { 0 }
                        } | Join-String -Separator ', ')],
                        borderColor: 'rgba(54, 162, 235, 1)',
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        fill: true,
                        tension: 0.3
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: { display: true, text: '按小时流量分布' }
                    },
                    scales: {
                        y: { beginAtZero: true }
                    }
                }
            });
        </script>
    </div>
</body>
</html>
"@

    # 保存HTML报告
    $htmlReport | Out-File -FilePath $reportFile -Encoding UTF8
    Write-Host "`n已生成HTML报告: $reportFile" -ForegroundColor Green
}
```

## 6. 常见错误代码速查

以下是Apache和PHP中常见错误代码的速查表，帮助您快速识别和解决问题。

### 6.1 Apache错误代码

| 错误代码 | 可能原因 | 解决方案 |
|---------|---------|---------|
| AH00558 | 未设置ServerName | 在httpd.conf添加`ServerName localhost` |
| AH00015 | 无法打开日志文件 | 检查日志目录权限和路径 |
| AH00072 | 内存不足 | 减少MaxRequestWorkers或增加服务器内存 |
| AH01630 | 目录权限不足 | 调整Directory权限设置或文件系统权限 |
| AH00526 | 语法错误 | 检查配置文件语法 |
| AH01909 | 无法加载SSL证书 | 检查证书路径和权限 |
| AH00128 | 端口已被占用 | 更改监听端口或停止占用端口的程序 |
| AH01071 | PHP脚本超时 | 增加php_value max_execution_time |
| AH00023 | 无法打开配置文件 | 检查文件路径和权限 |
| AH00094 | 命令行选项解析错误 | 检查启动参数 |

### 6.2 PHP错误代码

| 错误代码 | 描述 | 解决方案 |
|---------|------|---------|
| E_ERROR | 致命运行时错误 | 修复代码逻辑或增加内存限制 |
| E_WARNING | 运行时警告 | 检查函数参数和文件操作 |
| E_PARSE | 编译时解析错误 | 修复语法错误 |
| E_NOTICE | 运行时通知 | 检查未定义变量或索引 |
| E_CORE_ERROR | PHP启动时致命错误 | 检查PHP配置和扩展 |
| E_CORE_WARNING | PHP启动时警告 | 检查PHP配置和扩展 |
| E_COMPILE_ERROR | 编译时致命错误 | 修复代码或更新PHP版本 |
| E_COMPILE_WARNING | 编译时警告 | 检查代码兼容性 |
| E_USER_ERROR | 用户生成的错误 | 检查trigger_error()调用 |
| E_DEPRECATED | 不推荐使用的功能 | 更新代码使用推荐的替代方法 |

### 6.3 HTTP状态码

| 状态码 | 描述 | 可能原因和解决方案 |
|-------|------|------------------|
| 400 | 错误请求 | 客户端请求语法错误，检查请求参数 |
| 401 | 未授权 | 需要身份验证，检查认证配置 |
| 403 | 禁止访问 | 权限不足，检查文件/目录权限和.htaccess |
| 404 | 未找到 | 资源不存在，检查URL和文件路径 |
| 500 | 服务器内部错误 | PHP脚本错误，检查错误日志 |
| 502 | 网关错误 | 代理或FastCGI问题，检查PHP-FPM配置 |
| 503 | 服务不可用 | 服务器过载或维护，调整资源限制 |
| 504 | 网关超时 | PHP脚本执行时间过长，增加超时设置 |

## 7. 故障排除流程

以下是一个系统化的故障排除流程，帮助您有条理地解决Apache和PHP环境中的问题。

### 7.1 基本故障排除步骤

```powershell:c:\project\kphub\scripts\troubleshoot.ps1
# Apache和PHP故障排除工具
param(
    [switch]$checkConfig,
    [switch]$checkLogs,
    [switch]$checkPermissions,
    [switch]$checkServices,
    [switch]$checkPorts,
    [switch]$all
)

$apacheRoot = "c:\project\kphub"
$apacheBin = "$apacheRoot\bin\httpd.exe"
$apacheConf = "$apacheRoot\conf\httpd.conf"
$phpExe = "c:\php\php.exe"
$phpIni = "c:\php\php.ini"

# 如果没有指定选项，默认执行所有检查
if (-not ($checkConfig -or $checkLogs -or $checkPermissions -or $checkServices -or $checkPorts)) {
    $all = $true
}

function Write-Header {
    param([string]$text)
    
    Write-Host "`n========== $text ==========" -ForegroundColor Cyan
}

function Write-Success {
    param([string]$text)
    
    Write-Host "✓ $text" -ForegroundColor Green
}

function Write-Warning {
    param([string]$text)
    
    Write-Host "⚠️ $text" -ForegroundColor Yellow
}

function Write-Error {
    param([string]$text)
    
    Write-Host "✗ $text" -ForegroundColor Red
}

function Check-Command {
    param([string]$cmd)
    
    try {
        $null = Get-Command $cmd -ErrorAction Stop
        return $true
    } catch {
        return $false
    }
}

# 检查Apache和PHP版本
Write-Header "环境信息"

if (Test-Path $apacheBin) {
    $apacheVersion = & $apacheBin -v | Select-String "Apache/" | ForEach-Object { $_.ToString().Trim() }
    Write-Host "Apache版本: $apacheVersion"
} else {
    Write-Error "找不到Apache可执行文件: $apacheBin"
}

if (Test-Path $phpExe) {
    $phpVersion = & $phpExe -v | Select-String "PHP " | ForEach-Object { $_.ToString().Trim() }
    Write-Host "PHP版本: $phpVersion"
} else {
    Write-Error "找不到PHP可执行文件: $phpExe"
}

# 检查配置
if ($checkConfig -or $all) {
    Write-Header "配置检查"
    
    # 检查Apache配置
    if (Test-Path $apacheBin) {
        Write-Host "检查Apache配置语法..." -NoNewline
        $configResult = & $apacheBin -t 2>&1
        
        if ($LASTEXITCODE -eq 0) {
            Write-Host " 正确" -ForegroundColor Green
        } else {
            Write-Host " 错误" -ForegroundColor Red
            Write-Host $configResult -ForegroundColor Red
        }
    }
    
    # 检查PHP配置
    if (Test-Path $phpExe) {
        Write-Host "检查PHP配置..." -NoNewline
        $phpConfigResult = & $phpExe -i | Select-String "Configuration File"
        
        if ($phpConfigResult) {
            Write-Host " 正确" -ForegroundColor Green
            Write-Host $phpConfigResult
        } else {
            Write-Host " 无法获取配置信息" -ForegroundColor Yellow
        }
        
        # 检查PHP扩展
        Write-Host "检查PHP扩展..."
        $extensions = & $phpExe -m
        
        $criticalExtensions = @("mysqli", "pdo_mysql", "openssl", "mbstring", "gd", "curl", "fileinfo", "json", "session")
        foreach ($ext in $criticalExtensions) {
            if ($extensions -contains $ext) {
                Write-Success "扩展已加载: $ext"
            } else {
                Write-Warning "关键扩展未加载: $ext"
            }
        }
    }
}

# 检查日志
if ($checkLogs -or $all) {
    Write-Header "日志检查"
    
    $errorLog = "$apacheRoot\logs\error.log"
    if (Test-Path $errorLog) {
        Write-Host "最近的错误日志条目:"
        Get-Content $errorLog -Tail 10 | ForEach-Object {
            if ($_ -match "error|fatal") {
                Write-Host $_ -ForegroundColor Red
            } elseif ($_ -match "warn") {
                Write-Host $_ -ForegroundColor Yellow
            } else {
                Write-Host $_
            }
        }
    } else {
        Write-Warning "找不到错误日志文件: $errorLog"
    }
    
    $phpErrorLog = "c:\php\logs\php_error.log"
    if (Test-Path $phpErrorLog) {
        Write-Host "`nPHP错误日志条目:"
        Get-Content $phpErrorLog -Tail 10 | ForEach-Object {
            if ($_ -match "Fatal error|Parse error") {
                Write-Host $_ -ForegroundColor Red
            } elseif ($_ -match "Warning") {
                Write-Host $_ -ForegroundColor Yellow
            } elseif ($_ -match "Notice") {
                Write-Host $_ -ForegroundColor Cyan
            } else {
                Write-Host $_
            }
        }
    } else {
        Write-Warning "找不到PHP错误日志文件: $phpErrorLog"
    }
}

# 检查权限
if ($checkPermissions -or $all) {
    Write-Header "权限检查"
    
    $webRoot = "$apacheRoot\www"
    if (Test-Path $webRoot) {
        $acl = Get-Acl $webRoot
        Write-Host "Web根目录权限:"
        $acl.Access | ForEach-Object {
            Write-Host "  $($_.IdentityReference) : $($_.FileSystemRights)"
        }
        
        # 检查特殊目录
        $specialDirs = @("uploads", "logs", "temp", "cache")
        foreach ($dir in $specialDirs) {
            $path = "$webRoot\$dir"
            if (Test-Path $path) {
                $dirAcl = Get-Acl $path
                $iisUser = $dirAcl.Access | Where-Object { $_.IdentityReference -like "*IIS_IUSRS*" -or $_.IdentityReference -like "*NETWORK SERVICE*" }
                
                if ($iisUser -and ($iisUser.FileSystemRights -match "Write|Modify")) {
                    Write-Success "$dir 目录具有正确的写入权限"
                } else {
                    Write-Warning "$dir 目录可能缺少写入权限"
                }
            } else {
                Write-Warning "特殊目录不存在: $path"
            }
        }
    } else {
        Write-Error "Web根目录不存在: $webRoot"
    }
}

# 检查服务
if ($checkServices -or $all) {
    Write-Header "服务检查"
    
    $apacheService = Get-Service -Name "Apache*" -ErrorAction SilentlyContinue
    if ($apacheService) {
        Write-Host "Apache服务: $($apacheService.Name) - $($apacheService.Status)"
        if ($apacheService.Status -ne "Running") {
            Write-Warning "Apache服务未运行"
        }
    } else {
        Write-Warning "未找到Apache服务"
    }
    
    $phpFpmService = Get-Service -Name "PHP*" -ErrorAction SilentlyContinue
    if ($phpFpmService) {
        Write-Host "PHP-FPM服务: $($phpFpmService.Name) - $($phpFpmService.Status)"
        if ($phpFpmService.Status -ne "Running") {
            Write-Warning "PHP-FPM服务未运行"
        }
    } else {
        Write-Host "未找到PHP-FPM服务 (可能使用的是Apache模块模式)" -ForegroundColor Cyan
    }
}

# 检查端口
if ($checkPorts -or $all) {
    Write-Header "端口检查"
    
    # 检查Apache端口
    $apachePorts = @(80, 443)
    foreach ($port in $apachePorts) {
        $portInUse = Get-NetTCPConnection -LocalPort $port -ErrorAction SilentlyContinue
        
        if ($portInUse) {
            $process = Get-Process -Id $portInUse[0].OwningProcess -ErrorAction SilentlyContinue
            if ($process.Name -match "httpd|apache") {
                Write-Success "端口 $port 被Apache使用 (PID: $($process.Id))"
            } else {
                Write-Warning "端口 $port 被其他进程使用: $($process.Name) (PID: $($process.Id))"
            }
        } else {
            Write-Warning "端口 $port 未被使用"
        }
    }
    
    # 检查PHP-FPM端口
    $phpFpmPort = 9000
    $phpFpmInUse = Get-NetTCPConnection -LocalPort $phpFpmPort -ErrorAction SilentlyContinue
    
    if ($phpFpmInUse) {
        $process = Get-Process -Id $phpFpmInUse[0].OwningProcess -ErrorAction SilentlyContinue
        Write-Success "PHP-FPM端口 $phpFpmPort 正在使用 (进程: $($process.Name), PID: $($process.Id))"
    } else {
        Write-Host "PHP-FPM端口 $phpFpmPort 未被使用 (可能使用的是Apache模块模式)" -ForegroundColor Cyan
    }
}

Write-Host "`n故障排除完成。如需更详细的分析，请查看日志文件。" -ForegroundColor Green
```

### 7.2 常见问题解决流程图

以下是一个简单的流程图，帮助您系统地解决Apache和PHP环境中的常见问题：

```
开始
 |
 ↓
[服务是否启动?] → 否 → [检查错误日志] → [解决启动问题]
 |                      (端口冲突/配置错误)
 是
 |
 ↓
[网站是否可访问?] → 否 → [检查网络/防火墙] → [解决网络问题]
 |                       (端口开放/DNS设置)
 是
 |
 ↓
[页面显示正常?] → 否 → [检查HTTP状态码]
 |                    |
 |                    ↓
 |                   [403] → [检查文件权限]
 |                    |
 |                   [404] → [检查文件路径]
 |                    |
 |                   [500] → [检查PHP错误日志]
 |                    |
 |                   [502/504] → [检查PHP-FPM配置]
 是
 |
 ↓
[性能是否正常?] → 否 → [检查资源使用] → [优化配置]
 |                     (CPU/内存/磁盘IO)
 是
 |
 ↓
[问题解决]
```

## 8. 自动化维护脚本

以下是一些自动化维护脚本，可以帮助您定期执行维护任务，保持系统健康运行。

### 8.1 日志轮转脚本

```powershell:c:\project\kphub\scripts\rotate_logs.ps1
# 日志轮转脚本
param(
    [string]$logDir = "c:\project\kphub\logs",
    [int]$keepDays = 30,
    [switch]$compress
)

# 创建日志目录（如果不存在）
if (-not (Test-Path $logDir)) {
    New-Item -Path $logDir -ItemType Directory
    Write-Host "创建日志目录: $logDir" -ForegroundColor Green
}

# 获取当前日期
$date = Get-Date -Format "yyyyMMdd"

# 轮转Apache日志
$accessLog = "$logDir\access.log"
$errorLog = "$logDir\error.log"

if (Test-Path $accessLog) {
    $accessLogSize = (Get-Item $accessLog).Length / 1MB
    Write-Host "访问日志大小: $([math]::Round($accessLogSize, 2)) MB" -ForegroundColor Cyan
    
    # 如果日志文件存在且不为空
    if ($accessLogSize -gt 0) {
        $newAccessLog = "$logDir\access_$date.log"
        Copy-Item $accessLog $newAccessLog
        Clear-Content $accessLog
        Write-Host "已轮转访问日志: $newAccessLog" -ForegroundColor Green
        
        # 压缩日志（如果启用）
        if ($compress) {
            Compress-Archive -Path $newAccessLog -DestinationPath "$newAccessLog.zip"
            Remove-Item $newAccessLog
            Write-Host "已压缩访问日志: $newAccessLog.zip" -ForegroundColor Green
        }
    }
}

if (Test-Path $errorLog) {
    $errorLogSize = (Get-Item $errorLog).Length / 1MB
    Write-Host "错误日志大小: $([math]::Round($errorLogSize, 2)) MB" -ForegroundColor Cyan
    
    # 如果日志文件存在且不为空
    if ($errorLogSize -gt 0) {
        $newErrorLog = "$logDir\error_$date.log"
        Copy-Item $errorLog $newErrorLog
        Clear-Content $errorLog
        Write-Host "已轮转错误日志: $newErrorLog" -ForegroundColor Green
        
        # 压缩日志（如果启用）
        if ($compress) {
            Compress-Archive -Path $newErrorLog -DestinationPath "$newErrorLog.zip"
            Remove-Item $newErrorLog
            Write-Host "已压缩错误日志: $newErrorLog.zip" -ForegroundColor Green
        }
    }
}

# 轮转PHP日志
$phpErrorLog = "c:\php\logs\php_error.log"
if (Test-Path $phpErrorLog) {
    $phpLogSize = (Get-Item $phpErrorLog).Length / 1MB
    Write-Host "PHP错误日志大小: $([math]::Round($phpLogSize, 2)) MB" -ForegroundColor Cyan
让我继续完成日志轮转脚本的剩余部分：

```powershell:c:\project\kphub\scripts\rotate_logs.ps1
    $phpLogSize = (Get-Item $phpErrorLog).Length / 1MB
    Write-Host "PHP错误日志大小: $([math]::Round($phpLogSize, 2)) MB" -ForegroundColor Cyan
    
    # 如果日志文件存在且不为空
    if ($phpLogSize -gt 0) {
        $phpLogsDir = Split-Path $phpErrorLog
        $newPhpErrorLog = "$phpLogsDir\php_error_$date.log"
        Copy-Item $phpErrorLog $newPhpErrorLog
        Clear-Content $phpErrorLog
        Write-Host "已轮转PHP错误日志: $newPhpErrorLog" -ForegroundColor Green
        
        # 压缩日志（如果启用）
        if ($compress) {
            Compress-Archive -Path $newPhpErrorLog -DestinationPath "$newPhpErrorLog.zip"
            Remove-Item $newPhpErrorLog
            Write-Host "已压缩PHP错误日志: $newPhpErrorLog.zip" -ForegroundColor Green
        }
    }
}

# 清理旧日志文件
Write-Host "`n清理超过 $keepDays 天的旧日志文件..." -ForegroundColor Cyan
$oldDate = (Get-Date).AddDays(-$keepDays)

# 获取所有日志文件
$logFiles = Get-ChildItem -Path $logDir -Filter "*.log" | Where-Object { $_.LastWriteTime -lt $oldDate }
$zipFiles = Get-ChildItem -Path $logDir -Filter "*.zip" | Where-Object { $_.LastWriteTime -lt $oldDate }

# 删除旧日志文件
foreach ($file in $logFiles) {
    Remove-Item $file.FullName
    Write-Host "已删除旧日志: $($file.Name)" -ForegroundColor Yellow
}

# 删除旧压缩文件
foreach ($file in $zipFiles) {
    Remove-Item $file.FullName
    Write-Host "已删除旧压缩日志: $($file.Name)" -ForegroundColor Yellow
}

# 检查PHP日志目录
$phpLogsDir = "c:\php\logs"
if (Test-Path $phpLogsDir) {
    $phpOldLogs = Get-ChildItem -Path $phpLogsDir -Filter "php_error_*.log" | Where-Object { $_.LastWriteTime -lt $oldDate }
    $phpOldZips = Get-ChildItem -Path $phpLogsDir -Filter "php_error_*.zip" | Where-Object { $_.LastWriteTime -lt $oldDate }
    
    # 删除旧PHP日志
    foreach ($file in $phpOldLogs) {
        Remove-Item $file.FullName
        Write-Host "已删除旧PHP日志: $($file.Name)" -ForegroundColor Yellow
    }
    
    # 删除旧PHP压缩日志
    foreach ($file in $phpOldZips) {
        Remove-Item $file.FullName
        Write-Host "已删除旧PHP压缩日志: $($file.Name)" -ForegroundColor Yellow
    }
}

Write-Host "`n日志轮转完成" -ForegroundColor Green
```

### 8.2 自动备份脚本

```powershell:c:\project\kphub\scripts\backup.ps1
# Apache和PHP环境自动备份脚本
param(
    [string]$backupDir = "c:\project\kphub\backups",
    [string]$webRoot = "c:\project\kphub\www",
    [string]$configDir = "c:\project\kphub\conf",
    [string]$phpConfigFile = "c:\php\php.ini",
    [int]$keepBackups = 5,
    [switch]$includeDatabase,
    [string]$mysqlUser = "root",
    [string]$mysqlPassword = "",
    [string]$mysqlHost = "localhost",
    [string]$mysqlDatabases = "all"
)

# 创建备份目录（如果不存在）
if (-not (Test-Path $backupDir)) {
    New-Item -Path $backupDir -ItemType Directory
    Write-Host "创建备份目录: $backupDir" -ForegroundColor Green
}

# 获取当前日期和时间
$date = Get-Date -Format "yyyyMMdd_HHmmss"
$backupName = "backup_$date"
$backupPath = "$backupDir\$backupName"

# 创建当前备份目录
New-Item -Path $backupPath -ItemType Directory
Write-Host "创建备份: $backupPath" -ForegroundColor Cyan

# 备份网站文件
if (Test-Path $webRoot) {
    Write-Host "正在备份网站文件..." -ForegroundColor Cyan
    $webBackupPath = "$backupPath\www"
    New-Item -Path $webBackupPath -ItemType Directory
    
    # 使用robocopy进行高效复制
    $robocopyArgs = @(
        $webRoot,
        $webBackupPath,
        "/E",        # 复制子目录，包括空目录
        "/Z",        # 可恢复模式复制
        "/R:1",      # 失败重试次数
        "/W:1",      # 重试等待时间（秒）
        "/MT:8",     # 多线程复制
        "/XD", "$webRoot\cache", "$webRoot\logs", "$webRoot\temp"  # 排除不需要备份的目录
    )
    
    & robocopy $robocopyArgs
    
    if ($LASTEXITCODE -lt 8) {
        Write-Host "网站文件备份完成" -ForegroundColor Green
    } else {
        Write-Host "网站文件备份过程中出现错误" -ForegroundColor Red
    }
} else {
    Write-Host "网站根目录不存在: $webRoot" -ForegroundColor Red
}

# 备份Apache配置
if (Test-Path $configDir) {
    Write-Host "正在备份Apache配置..." -ForegroundColor Cyan
    $configBackupPath = "$backupPath\conf"
    New-Item -Path $configBackupPath -ItemType Directory
    
    # 使用robocopy备份配置文件
    & robocopy $configDir $configBackupPath /E /Z /R:1 /W:1
    
    if ($LASTEXITCODE -lt 8) {
        Write-Host "Apache配置备份完成" -ForegroundColor Green
    } else {
        Write-Host "Apache配置备份过程中出现错误" -ForegroundColor Red
    }
} else {
    Write-Host "Apache配置目录不存在: $configDir" -ForegroundColor Red
}

# 备份PHP配置
if (Test-Path $phpConfigFile) {
    Write-Host "正在备份PHP配置..." -ForegroundColor Cyan
    $phpBackupPath = "$backupPath\php"
    New-Item -Path $phpBackupPath -ItemType Directory
    
    Copy-Item $phpConfigFile $phpBackupPath
    Write-Host "PHP配置备份完成" -ForegroundColor Green
} else {
    Write-Host "PHP配置文件不存在: $phpConfigFile" -ForegroundColor Red
}

# 备份数据库
if ($includeDatabase) {
    Write-Host "正在备份数据库..." -ForegroundColor Cyan
    $dbBackupPath = "$backupPath\database"
    New-Item -Path $dbBackupPath -ItemType Directory
    
    # 检查mysqldump是否可用
    $mysqldump = "mysqldump"
    if (-not (Get-Command $mysqldump -ErrorAction SilentlyContinue)) {
        # 尝试查找MySQL安装目录
        $possiblePaths = @(
            "C:\Program Files\MySQL\MySQL Server 8.0\bin\mysqldump.exe",
            "C:\Program Files\MySQL\MySQL Server 5.7\bin\mysqldump.exe",
            "C:\xampp\mysql\bin\mysqldump.exe"
        )
        
        foreach ($path in $possiblePaths) {
            if (Test-Path $path) {
                $mysqldump = $path
                break
            }
        }
    }
    
    if (Get-Command $mysqldump -ErrorAction SilentlyContinue) {
        # 构建mysqldump命令基础部分
        $mysqlCred = "--user=$mysqlUser"
        if ($mysqlPassword) {
            $mysqlCred += " --password=$mysqlPassword"
        }
        $mysqlConn = "--host=$mysqlHost --port=3306"
        $mysqlOpts = "--single-transaction --routines --triggers --events"
        
        # 获取数据库列表
        if ($mysqlDatabases -eq "all") {
            $query = "SHOW DATABASES WHERE `Database` NOT IN ('information_schema', 'performance_schema', 'mysql', 'sys')"
            $databases = & mysql --user=$mysqlUser --password=$mysqlPassword --host=$mysqlHost --skip-column-names -e $query
        } else {
            $databases = $mysqlDatabases -split ','
        }
        
        # 备份每个数据库
        foreach ($db in $databases) {
            $db = $db.Trim()
            if ($db) {
                $outputFile = "$dbBackupPath\$db.sql"
                Write-Host "  备份数据库: $db" -ForegroundColor Cyan
                
                $cmd = "$mysqldump $mysqlCred $mysqlConn $mysqlOpts $db > `"$outputFile`""
                Invoke-Expression $cmd
                
                if (Test-Path $outputFile) {
                    Write-Host "  数据库 $db 备份完成" -ForegroundColor Green
                    
                    # 压缩SQL文件
                    Compress-Archive -Path $outputFile -DestinationPath "$outputFile.zip"
                    Remove-Item $outputFile
                    Write-Host "  已压缩数据库备份: $db.sql.zip" -ForegroundColor Green
                } else {
                    Write-Host "  数据库 $db 备份失败" -ForegroundColor Red
                }
            }
        }
    } else {
        Write-Host "找不到mysqldump工具，无法备份数据库" -ForegroundColor Red
    }
}

# 压缩整个备份
Write-Host "正在压缩备份..." -ForegroundColor Cyan
$zipFile = "$backupDir\$backupName.zip"
Compress-Archive -Path $backupPath -DestinationPath $zipFile
Remove-Item -Path $backupPath -Recurse -Force
Write-Host "备份已压缩: $zipFile" -ForegroundColor Green

# 清理旧备份
$backups = Get-ChildItem -Path $backupDir -Filter "backup_*.zip" | Sort-Object LastWriteTime -Descending | Select-Object -Skip $keepBackups
foreach ($backup in $backups) {
    Remove-Item $backup.FullName
    Write-Host "已删除旧备份: $($backup.Name)" -ForegroundColor Yellow
}

Write-Host "`n备份完成: $zipFile" -ForegroundColor Green
Write-Host "保留最近 $keepBackups 个备份" -ForegroundColor Cyan
```

### 8.3 性能监控脚本

```powershell:c:\project\kphub\scripts\monitor_performance.ps1
# Apache和PHP性能监控脚本
param(
    [int]$duration = 3600,    # 监控持续时间（秒）
    [int]$interval = 10,      # 采样间隔（秒）
    [string]$outputFile = "c:\project\kphub\logs\performance_$(Get-Date -Format 'yyyyMMdd_HHmmss').csv",
    [switch]$generateReport
)

# 检查是否有管理员权限
$isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
if (-not $isAdmin) {
    Write-Host "警告: 此脚本需要管理员权限才能收集完整的性能数据。" -ForegroundColor Yellow
}

# 创建输出目录（如果不存在）
$outputDir = Split-Path $outputFile
if (-not (Test-Path $outputDir)) {
    New-Item -Path $outputDir -ItemType Directory
}

# 初始化CSV文件
$header = "Timestamp,CPU_Total,CPU_Apache,Memory_Total_MB,Memory_Free_MB,Memory_Apache_MB,Disk_IO_Read_KB,Disk_IO_Write_KB,Network_Sent_KB,Network_Received_KB,Apache_Workers,Apache_Requests,PHP_Processes"
$header | Out-File -FilePath $outputFile -Encoding utf8

# 计算采样次数
$samples = [math]::Ceiling($duration / $interval)

Write-Host "开始性能监控..." -ForegroundColor Cyan
Write-Host "监控持续时间: $($duration / 60) 分钟, 采样间隔: $interval 秒" -ForegroundColor Cyan
Write-Host "输出文件: $outputFile" -ForegroundColor Cyan

# 获取初始磁盘和网络计数器
$initialDiskRead = (Get-Counter -Counter "\PhysicalDisk(_Total)\Disk Read Bytes/sec").CounterSamples.CookedValue
$initialDiskWrite = (Get-Counter -Counter "\PhysicalDisk(_Total)\Disk Write Bytes/sec").CounterSamples.CookedValue
$initialNetSent = (Get-Counter -Counter "\Network Interface(*)\Bytes Sent/sec").CounterSamples | Measure-Object -Property CookedValue -Sum | Select-Object -ExpandProperty Sum
$initialNetReceived = (Get-Counter -Counter "\Network Interface(*)\Bytes Received/sec").CounterSamples | Measure-Object -Property CookedValue -Sum | Select-Object -ExpandProperty Sum

# 监控循环
for ($i = 0; $i -lt $samples; $i++) {
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $elapsedMinutes = [math]::Round(($i * $interval) / 60, 1)
    
    # 获取系统性能数据
    $cpuTotal = (Get-Counter -Counter "\Processor(_Total)\% Processor Time").CounterSamples.CookedValue
    $memoryTotal = (Get-CimInstance -ClassName Win32_ComputerSystem).TotalPhysicalMemory / 1MB
    $memoryFree = (Get-Counter -Counter "\Memory\Available MBytes").CounterSamples.CookedValue
    
    # 获取磁盘和网络性能
    $diskRead = ((Get-Counter -Counter "\PhysicalDisk(_Total)\Disk Read Bytes/sec").CounterSamples.CookedValue - $initialDiskRead) / 1KB
    $diskWrite = ((Get-Counter -Counter "\PhysicalDisk(_Total)\Disk Write Bytes/sec").CounterSamples.CookedValue - $initialDiskWrite) / 1KB
    $netSent = ((Get-Counter -Counter "\Network Interface(*)\Bytes Sent/sec").CounterSamples | Measure-Object -Property CookedValue -Sum | Select-Object -ExpandProperty Sum - $initialNetSent) / 1KB
    $netReceived = ((Get-Counter -Counter "\Network Interface(*)\Bytes Received/sec").CounterSamples | Measure-Object -Property CookedValue -Sum | Select-Object -ExpandProperty Sum - $initialNetReceived) / 1KB
    
    # 更新初始值
    $initialDiskRead = (Get-Counter -Counter "\PhysicalDisk(_Total)\Disk Read Bytes/sec").CounterSamples.CookedValue
    $initialDiskWrite = (Get-Counter -Counter "\PhysicalDisk(_Total)\Disk Write Bytes/sec").CounterSamples.CookedValue
    $initialNetSent = (Get-Counter -Counter "\Network Interface(*)\Bytes Sent/sec").CounterSamples | Measure-Object -Property CookedValue -Sum | Select-Object -ExpandProperty Sum
    $initialNetReceived = (Get-Counter -Counter "\Network Interface(*)\Bytes Received/sec").CounterSamples | Measure-Object -Property CookedValue -Sum | Select-Object -ExpandProperty Sum
    
    # 获取Apache和PHP进程信息
    $apacheProcesses = Get-Process -Name httpd, apache* -ErrorAction SilentlyContinue
    $phpProcesses = Get-Process -Name php*, php-cgi -ErrorAction SilentlyContinue
    
    $cpuApache = 0
    $memoryApache = 0
    $apacheWorkers = 0
    
    if ($apacheProcesses) {
        $cpuApache = ($apacheProcesses | Measure-Object -Property CPU -Sum).Sum
        $memoryApache = ($apacheProcesses | Measure-Object -Property WorkingSet -Sum).Sum / 1MB
        $apacheWorkers = $apacheProcesses.Count
    }
    
    $phpCount = 0
    if ($phpProcesses) {
        $phpCount = $phpProcesses.Count
    }
    
    # 获取Apache请求数（如果可能）
    $apacheRequests = 0
    $serverStatusUrl = "http://localhost/server-status?auto"
    try {
        $statusContent = Invoke-WebRequest -Uri $serverStatusUrl -UseBasicParsing -TimeoutSec 2
        if ($statusContent.Content -match "Total Accesses:\s+(\d+)") {
            $apacheRequests = $matches[1]
        }
    } catch {
        # 无法获取Apache状态
    }
    
    # 构建CSV行
    $csvLine = "$timestamp,$([math]::Round($cpuTotal, 2)),$([math]::Round($cpuApache, 2)),$([math]::Round($memoryTotal, 2)),$([math]::Round($memoryFree, 2)),$([math]::Round($memoryApache, 2)),$([math]::Round($diskRead, 2)),$([math]::Round($diskWrite, 2)),$([math]::Round($netSent, 2)),$([math]::Round($netReceived, 2)),$apacheWorkers,$apacheRequests,$phpCount"
    $csvLine | Out-File -FilePath $outputFile -Encoding utf8 -Append
    
    # 显示当前状态
    Write-Host "[$elapsedMinutes 分钟] CPU: $([math]::Round($cpuTotal, 1))%, 内存: $([math]::Round(($memoryTotal - $memoryFree), 0))/$([math]::Round($memoryTotal, 0))MB, Apache: $apacheWorkers 进程"
    
    # 检测性能问题
    if ($cpuTotal -gt 80) {
        Write-Host "  ⚠️ CPU使用率高 ($([math]::Round($cpuTotal, 1))%)" -ForegroundColor Red
    }
    
    if ($memoryFree -lt ($memoryTotal * 0.1)) {
        Write-Host "  ⚠️ 可用内存低 ($([math]::Round($memoryFree, 0))MB)" -ForegroundColor Red
    }
    
    if ($diskWrite -gt 10000) {
        Write-Host "  ⚠️ 磁盘写入高 ($([math]::Round($diskWrite, 0))KB/s)" -ForegroundColor Yellow
    }
    
    # 等待下一个采样间隔
    if ($i -lt $samples - 1) {
        Start-Sleep -Seconds $interval
    }
}

Write-Host "`n监控完成，数据已保存到: $outputFile" -ForegroundColor Green

# 生成HTML报告
if ($generateReport) {
    $reportFile = $outputFile -replace "\.csv$", ".html"
    Write-Host "正在生成HTML报告..." -ForegroundColor Cyan
    
    $htmlReport = @"
<!DOCTYPE html>
<html>
<head>
    <title>Apache和PHP性能监控报告</title>
    <meta charset="utf-8">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1, h2 { color: #333; }
        .container { max-width: 1200px; margin: 0 auto; }
        .chart-container { height: 300px; margin-bottom: 30px; }
        .summary { background: #f5f5f5; padding: 15px; margin-bottom: 20px; border-radius: 5px; }
        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f2f2f2; }
        .warning { color: #e74c3c; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
    <div class="container">
        <h1>Apache和PHP性能监控报告</h1>
        <p>监控时间: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")</p>
        <p>监控持续时间: $($duration / 60) 分钟, 采样间隔: $interval 秒</p>
        
        <div class="summary">
            <h2>性能摘要</h2>
            <div id="summary-content">正在计算摘要数据...</div>
        </div>
        
        <h2>CPU使用率</h2>
        <div class="chart-container">
            <canvas id="cpuChart"></canvas>
        </div>
        
        <h2>内存使用</h2>
        <div class="chart-container">
            <canvas id="memoryChart"></canvas>
        </div>
        
        <h2>Apache进程和请求</h2>
        <div class="chart-container">
            <canvas id="apacheChart"></canvas>
        </div>
        
        <h2>磁盘I/O</h2>
        <div class="chart-container">
            <canvas id="diskChart"></canvas>
        </div>
        
        <h2>网络流量</h2>
        <div class="chart-container">
            <canvas id="networkChart"></canvas>
        </div>
    </div>
    
    <script>
        // 加载CSV数据
        fetch('$($outputFile.Replace("\", "\\"))')
            .then(response => response.text())
            .then(data => {
                const rows = data.split('\n');
                const headers = rows[0].split(',');
                const chartData = [];
                
                for (let i = 1; i < rows.length; i++) {
                    if (rows[i].trim() === '') continue;
                    
                    const values = rows[i].split(',');
                    const dataPoint = {};
                    
                    for (let j = 0; j < headers.length; j++) {
                        dataPoint[headers[j]] = values[j];
                    }
                    
                    chartData.push(dataPoint);
                }
                
                // 生成摘要
                generateSummary(chartData);
                
                // 创建图表
                createCpuChart(chartData);
                createMemoryChart(chartData);
                createApacheChart(chartData);
                createDiskChart(chartData);
                createNetworkChart(chartData);
            });
        
        function generateSummary(data) {
            // 计算平均值和最大值
            const cpuTotal = data.map(d => parseFloat(d.CPU_Total));
            const memoryUsed = data.map(d => parseFloat(d.Memory_Total_MB) - parseFloat(d.Memory_Free_MB));
            const apacheWorkers = data.map(d => parseInt(d.Apache_Workers));
            const diskWrite = data.map(d => parseFloat(d.Disk_IO_Write_KB));
            const networkTotal = data.map(d => parseFloat(d.Network_Sent_KB) + parseFloat(d.Network_Received_KB));
            
            const avgCpu = cpuTotal.reduce((a, b) => a + b, 0) / cpuTotal.length;
            const maxCpu = Math.max(...cpuTotal);
            const avgMemory = memoryUsed.reduce((a, b) => a + b, 0) / memoryUsed.length;
            const maxMemory = Math.max(...memoryUsed);
            const avgWorkers = apacheWorkers.reduce((a, b) => a + b, 0) / apacheWorkers.length;
            const maxWorkers = Math.max(...apacheWorkers);
            const avgDiskWrite = diskWrite.reduce((a, b) => a + b, 0) / diskWrite.length;
            const maxDiskWrite = Math.max(...diskWrite);
            const avgNetwork = networkTotal.reduce((a, b) => a + b, 0) / networkTotal.length;
            const maxNetwork = Math.max(...networkTotal);
            
            // 检测性能问题
            const issues = [];
            if (maxCpu > 80) issues.push(`CPU使用率峰值高 (${maxCpu.toFixed(1)}%)`);
            if (avgCpu > 60) issues.push(`CPU平均使用率高 (${avgCpu.toFixed(1)}%)`);
            if (maxMemory > parseFloat(data[0].Memory_Total_MB) * 0.9) issues.push(`内存使用接近上限`);
            if (maxDiskWrite > 10000) issues.push(`磁盘写入峰值高 (${maxDiskWrite.toFixed(0)}KB/s)`);
            
            // 生成HTML
            let html = `
                <table>
                    <tr><th>指标</th><th>平均值</th><th>最大值</th></tr>
                    <tr><td>CPU使用率</td><td>${avgCpu.toFixed(1)}%</td><td>${maxCpu.toFixed(1)}%</td></tr>
                    <tr><td>内存使用</td><td>${avgMemory.toFixed(0)}MB</td><td>${maxMemory.toFixed(0)}MB</td></tr>
                    <tr><td>Apache进程数</td><td>${avgWorkers.toFixed(1)}</td><td>${maxWorkers}</td></tr>
                    <tr><td>磁盘写入</td><td>${avgDiskWrite.toFixed(0)}KB/s</td><td>${maxDiskWrite.toFixed(0)}KB/s</td></tr>
                    <tr><td>网络流量</td><td>${avgNetwork.toFixed(0)}KB/s</td><td>${maxNetwork.toFixed(0)}KB/s</td></tr>
                </table>
            `;
            
            if (issues.length > 0) {
                html += `<div class="warning"><strong>检测到的性能问题:</strong><ul>`;
                issues.forEach(issue => {
                    html += `<li>${issue}</li>`;
                });
                html += `</ul></div>`;
            }
            
            document.getElementById('summary-content').innerHTML = html;
        }
        
        function createCpuChart(data) {
            const ctx = document.getElementById('cpuChart').getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(d => d.Timestamp),
                    datasets: [{
                        label: '总CPU使用率 (%)',
                        data: data.map(d => parseFloat(d.CPU_Total)),
                        borderColor: 'rgba(255, 99, 132, 1)',
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        fill: true
                    }, {
                        label: 'Apache CPU使用率 (%)',
                        data: data.map(d => parseFloat(d.CPU_Apache)),
                        borderColor: 'rgba(54, 162, 235, 1)',
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: '时间'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: 'CPU使用率 (%)'
                            },
                            suggestedMin: 0,
                            suggestedMax: 100
                        }
                    }
                }
            });
        }
        
        function createMemoryChart(data) {
            const ctx = document.getElementById('memoryChart').getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(d => d.Timestamp),
                    datasets: [{
                        label: '总内存使用 (MB)',
                        data: data.map(d => parseFloat(d.Memory_Total_MB) - parseFloat(d.Memory_Free_MB)),
                        borderColor: 'rgba(255, 159, 64, 1)',
                        backgroundColor: 'rgba(255, 159, 64, 0.2)',
                        fill: true
                    }, {
                        label: 'Apache内存使用 (MB)',
                        data: data.map(d => parseFloat(d.Memory_Apache_MB)),
                        borderColor: 'rgba(75, 192, 192, 1)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: '时间'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: '内存使用 (MB)'
                            },
                            suggestedMin: 0
                        }
                    }
                }
            });
        }
        
        function createApacheChart(data) {
            
让我继续完成性能监控脚本的HTML报告生成部分：

```powershell:c:\project\kphub\scripts\monitor_performance.ps1
        function createApacheChart(data) {
            const ctx = document.getElementById('apacheChart').getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(d => d.Timestamp),
                    datasets: [{
                        label: 'Apache进程数',
                        data: data.map(d => parseInt(d.Apache_Workers)),
                        borderColor: 'rgba(153, 102, 255, 1)',
                        backgroundColor: 'rgba(153, 102, 255, 0.2)',
                        fill: true,
                        yAxisID: 'y'
                    }, {
                        label: 'PHP进程数',
                        data: data.map(d => parseInt(d.PHP_Processes)),
                        borderColor: 'rgba(201, 203, 207, 1)',
                        backgroundColor: 'rgba(201, 203, 207, 0.2)',
                        fill: true,
                        yAxisID: 'y'
                    }, {
                        label: 'Apache请求数',
                        data: data.map(d => parseInt(d.Apache_Requests)),
                        borderColor: 'rgba(255, 205, 86, 1)',
                        backgroundColor: 'rgba(255, 205, 86, 0.2)',
                        fill: false,
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: '时间'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: '进程数'
                            },
                            suggestedMin: 0
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: '请求数'
                            },
                            suggestedMin: 0,
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    }
                }
            });
        }
        
        function createDiskChart(data) {
            const ctx = document.getElementById('diskChart').getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(d => d.Timestamp),
                    datasets: [{
                        label: '磁盘读取 (KB/s)',
                        data: data.map(d => parseFloat(d.Disk_IO_Read_KB)),
                        borderColor: 'rgba(54, 162, 235, 1)',
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        fill: true
                    }, {
                        label: '磁盘写入 (KB/s)',
                        data: data.map(d => parseFloat(d.Disk_IO_Write_KB)),
                        borderColor: 'rgba(255, 99, 132, 1)',
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: '时间'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: '磁盘I/O (KB/s)'
                            },
                            suggestedMin: 0
                        }
                    }
                }
            });
        }
        
        function createNetworkChart(data) {
            const ctx = document.getElementById('networkChart').getContext('2d');
            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: data.map(d => d.Timestamp),
                    datasets: [{
                        label: '发送 (KB/s)',
                        data: data.map(d => parseFloat(d.Network_Sent_KB)),
                        borderColor: 'rgba(75, 192, 192, 1)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        fill: true
                    }, {
                        label: '接收 (KB/s)',
                        data: data.map(d => parseFloat(d.Network_Received_KB)),
                        borderColor: 'rgba(153, 102, 255, 1)',
                        backgroundColor: 'rgba(153, 102, 255, 0.2)',
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: '时间'
                            }
                        },
                        y: {
                            display: true,
                            title: {
                                display: true,
                                text: '网络流量 (KB/s)'
                            },
                            suggestedMin: 0
                        }
                    }
                }
            });
        }
    </script>
</body>
</html>
"@

    $htmlReport | Out-File -FilePath $reportFile -Encoding utf8
    Write-Host "HTML报告已生成: $reportFile" -ForegroundColor Green
}
```

## 9. 安全加固指南

以下是一些Apache和PHP环境的安全加固建议，帮助您保护服务器免受常见威胁。

### 9.1 Apache安全配置

```apache:c:\project\kphub\conf\extra\security.conf
# Apache安全配置
# 将此文件包含在主httpd.conf中: Include conf/extra/security.conf

# 隐藏Apache版本信息
ServerTokens Prod
ServerSignature Off

# 禁用目录列表
<Directory />
    Options -Indexes
</Directory>

# 限制HTTP方法
<Location />
    <LimitExcept GET POST HEAD>
        Require all denied
    </LimitExcept>
</Location>

# 设置安全HTTP头
<IfModule mod_headers.c>
    # 启用XSS保护
    Header always set X-XSS-Protection "1; mode=block"
    
    # 防止MIME类型嗅探
    Header always set X-Content-Type-Options "nosniff"
    
    # 点击劫持保护
    Header always set X-Frame-Options "SAMEORIGIN"
    
    # 内容安全策略
    Header always set Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:;"
    
    # 引用策略
    Header always set Referrer-Policy "strict-origin-when-cross-origin"
    
    # 禁止在URL中包含敏感信息
    Header always edit Set-Cookie ^(.*)$ $1;HttpOnly;Secure;SameSite=Strict
    
    # 移除PHP版本信息
    Header unset X-Powered-By
</IfModule>

# 防止访问敏感文件
<FilesMatch "^(\.htaccess|\.htpasswd|\.git|\.env|\.svn|\.DS_Store)">
    Require all denied
</FilesMatch>

# 防止访问备份和源代码文件
<FilesMatch "\.(bak|config|sql|fla|psd|ini|log|sh|inc|swp|dist|md|lock|json)$">
    Require all denied
</FilesMatch>

# 限制PHP文件执行
<FilesMatch "\.php$">
    # 只允许在特定目录中执行PHP
    <If "%{REQUEST_URI} !~ m#^/(app|public|index\.php)#">
        Require all denied
    </If>
</FilesMatch>

# 防止SQL注入和XSS攻击的基本规则
<IfModule mod_rewrite.c>
    RewriteEngine On
    
    # 阻止SQL注入攻击
    RewriteCond %{QUERY_STRING} (\<|%3C).*script.*(\>|%3E) [NC,OR]
    RewriteCond %{QUERY_STRING} GLOBALS(=|\[|\%[0-9A-Z]{0,2}) [OR]
    RewriteCond %{QUERY_STRING} _REQUEST(=|\[|\%[0-9A-Z]{0,2}) [OR]
    RewriteCond %{QUERY_STRING} union([^a]*a)+ll([^s]*s)+elect [NC,OR]
    RewriteCond %{QUERY_STRING} insert|update|delete|select|drop|union|truncate [NC]
    RewriteRule ^(.*)$ - [F,L]
    
    # 阻止包含可疑用户代理的请求
    RewriteCond %{HTTP_USER_AGENT} libwww-perl [NC,OR]
    RewriteCond %{HTTP_USER_AGENT} wget [NC,OR]
    RewriteCond %{HTTP_USER_AGENT} ^$ [OR]
    RewriteCond %{HTTP_USER_AGENT} ^(java|curl|python|perl) [NC]
    RewriteRule ^(.*)$ - [F,L]
</IfModule>

# 启用HTTP严格传输安全(HSTS)
<IfModule mod_headers.c>
    Header always set Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
</IfModule>

# 设置Cookie安全属性
php_value session.cookie_httponly 1
php_value session.cookie_secure 1
php_value session.cookie_samesite "Strict"
php_value session.use_strict_mode 1

# 限制上传文件大小
LimitRequestBody 10485760

# 防止DoS攻击的超时设置
Timeout 60
KeepAliveTimeout 5
MaxRequestWorkers 150
```

### 9.2 PHP安全配置

```ini:c:\php\php.ini-security
; PHP安全配置
; 将这些设置添加到php.ini文件中

; 基本安全设置
expose_php = Off
display_errors = Off
display_startup_errors = Off
log_errors = On
error_log = "c:/php/logs/php_error.log"
error_reporting = E_ALL & ~E_DEPRECATED & ~E_STRICT
allow_url_fopen = Off
allow_url_include = Off
max_execution_time = 30
max_input_time = 60
memory_limit = 128M
post_max_size = 8M
upload_max_filesize = 2M
max_file_uploads = 20
file_uploads = On
enable_dl = Off

; 禁用危险函数
disable_functions = exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source,phpinfo

; 会话安全
session.use_strict_mode = 1
session.use_cookies = 1
session.use_only_cookies = 1
session.cookie_httponly = 1
session.cookie_secure = 1
session.cookie_samesite = "Strict"
session.gc_maxlifetime = 1440
session.gc_probability = 1
session.gc_divisor = 100
session.sid_length = 48
session.sid_bits_per_character = 6
session.hash_function = "sha256"

; 文件上传安全
upload_tmp_dir = "c:/php/upload_tmp"
upload_max_filesize = 2M
max_file_uploads = 5

; 错误处理
display_errors = Off
log_errors = On
error_log = "c:/php/logs/php_error.log"
ignore_repeated_errors = On
ignore_repeated_source = On

; 输入验证
filter.default = "unsafe_raw"
filter.default_flags = 0

; 数据库安全
mysqli.allow_persistent = Off
pdo_mysql.cache_size = 2000

; 邮件安全
mail.add_x_header = Off

; 限制包含路径
open_basedir = "c:/project/kphub/www;c:/php/temp;c:/php/upload_tmp"

; 文件系统安全
allow_url_fopen = Off
allow_url_include = Off
```

### 9.3 安全检查脚本

```powershell:c:\project\kphub\scripts\security_check.ps1
# Apache和PHP安全检查脚本
param(
    [switch]$fixIssues,
    [string]$outputFile = "c:\project\kphub\logs\security_check_$(Get-Date -Format 'yyyyMMdd').html"
)

# 定义颜色函数
function Write-ColorOutput {
    param(
        [string]$text,
        [string]$status
    )
    
    switch ($status) {
        "PASS" { Write-Host "✓ $text" -ForegroundColor Green }
        "WARN" { Write-Host "⚠️ $text" -ForegroundColor Yellow }
        "FAIL" { Write-Host "✗ $text" -ForegroundColor Red }
        default { Write-Host $text }
    }
}

# 初始化结果数组
$results = @()

Write-Host "开始安全检查..." -ForegroundColor Cyan

# 检查Apache配置
$apacheRoot = "c:\project\kphub"
$apacheConf = "$apacheRoot\conf\httpd.conf"
$phpIni = "c:\php\php.ini"

Write-Host "`n检查Apache配置..." -ForegroundColor Cyan

# 检查ServerTokens设置
$serverTokens = Select-String -Path $apacheConf -Pattern "ServerTokens\s+(\w+)" -AllMatches | ForEach-Object { $_.Matches.Groups[1].Value }
if ($serverTokens -eq "Prod") {
    Write-ColorOutput "ServerTokens设置正确 (Prod)" "PASS"
    $results += @{
        Category = "Apache配置"
        Check = "ServerTokens"
        Status = "PASS"
        Description = "ServerTokens设置为Prod，隐藏了详细的服务器信息"
        Recommendation = ""
    }
} else {
    Write-ColorOutput "ServerTokens应设置为Prod以隐藏服务器详细信息" "FAIL"
    $results += @{
        Category = "Apache配置"
        Check = "ServerTokens"
        Status = "FAIL"
        Description = "ServerTokens未设置为Prod，可能泄露服务器详细信息"
        Recommendation = "在httpd.conf中添加或修改: ServerTokens Prod"
    }
    
    if ($fixIssues) {
        if ($serverTokens) {
            (Get-Content $apacheConf) -replace "ServerTokens\s+(\w+)", "ServerTokens Prod" | Set-Content $apacheConf
        } else {
            Add-Content $apacheConf "`nServerTokens Prod"
        }
        Write-Host "  已修复ServerTokens设置" -ForegroundColor Green
    }
}

# 检查目录索引
$directoryIndex = Select-String -Path $apacheConf -Pattern "Options\s+.*Indexes" -AllMatches
if (-not $directoryIndex) {
    Write-ColorOutput "目录索引已禁用" "PASS"
    $results += @{
        Category = "Apache配置"
        Check = "目录索引"
        Status = "PASS"
        Description = "目录索引功能已禁用，防止目录内容被列出"
        Recommendation = ""
    }
} else {
    Write-ColorOutput "应禁用目录索引以防止目录内容被列出" "FAIL"
    $results += @{
        Category = "Apache配置"
        Check = "目录索引"
        Status = "FAIL"
        Description = "目录索引功能已启用，可能泄露敏感文件"
        Recommendation = "在httpd.conf中将Options中的Indexes替换为-Indexes"
    }
    
    if ($fixIssues) {
        (Get-Content $apacheConf) -replace "Options\s+.*Indexes", "Options -Indexes" | Set-Content $apacheConf
        Write-Host "  已修复目录索引设置" -ForegroundColor Green
    }
}

# 检查HTTP安全头
$securityHeaders = Select-String -Path $apacheConf -Pattern "X-XSS-Protection|X-Content-Type-Options|X-Frame-Options|Content-Security-Policy" -AllMatches
if ($securityHeaders) {
    Write-ColorOutput "已配置HTTP安全头" "PASS"
    $results += @{
        Category = "Apache配置"
        Check = "HTTP安全头"
        Status = "PASS"
        Description = "已配置关键的HTTP安全头"
        Recommendation = ""
    }
} else {
    Write-ColorOutput "应配置HTTP安全头以增强安全性" "FAIL"
    $results += @{
        Category = "Apache配置"
        Check = "HTTP安全头"
        Status = "FAIL"
        Description = "未配置关键的HTTP安全头，如X-XSS-Protection、X-Content-Type-Options等"
        Recommendation = "在httpd.conf中添加安全头配置，或包含security.conf文件"
    }
    
    if ($fixIssues) {
        $securityConfPath = "$apacheRoot\conf\extra\security.conf"
        if (-not (Test-Path $securityConfPath)) {
            # 创建安全配置文件
            $securityConf = @"
# Apache安全配置
# 隐藏Apache版本信息
ServerTokens Prod
ServerSignature Off

# 禁用目录列表
<Directory />
    Options -Indexes
</Directory>

# 设置安全HTTP头
<IfModule mod_headers.c>
    # 启用XSS保护
    Header always set X-XSS-Protection "1; mode=block"
    
    # 防止MIME类型嗅探
    Header always set X-Content-Type-Options "nosniff"
    
    # 点击劫持保护
    Header always set X-Frame-Options "SAMEORIGIN"
    
    # 内容安全策略
    Header always set Content-Security-Policy "default-src 'self';"
    
    # 移除PHP版本信息
    Header unset X-Powered-By
</IfModule>
"@
            $securityConf | Out-File -FilePath $securityConfPath -Encoding ASCII
            
            # 在主配置文件中包含安全配置
            Add-Content $apacheConf "`n# 包含安全配置`nInclude conf/extra/security.conf"
            
            Write-Host "  已创建安全配置文件并在主配置中包含" -ForegroundColor Green
        }
    }
}

# 检查PHP配置
Write-Host "`n检查PHP配置..." -ForegroundColor Cyan

# 检查expose_php设置
$exposePhp = Select-String -Path $phpIni -Pattern "expose_php\s*=\s*(\w+)" -AllMatches | ForEach-Object { $_.Matches.Groups[1].Value }
if ($exposePhp -eq "Off") {
    Write-ColorOutput "expose_php已禁用" "PASS"
    $results += @{
        Category = "PHP配置"
        Check = "expose_php"
        Status = "PASS"
        Description = "PHP版本信息已隐藏"
        Recommendation = ""
    }
} else {
    Write-ColorOutput "应禁用expose_php以隐藏PHP版本信息" "FAIL"
    $results += @{
        Category = "PHP配置"
        Check = "expose_php"
        Status = "FAIL"
        Description = "PHP版本信息可能被泄露"
        Recommendation = "在php.ini中设置: expose_php = Off"
    }
    
    if ($fixIssues) {
        if ($exposePhp) {
            (Get-Content $phpIni) -replace "expose_php\s*=\s*(\w+)", "expose_php = Off" | Set-Content $phpIni
        } else {
            Add-Content $phpIni "`nexpose_php = Off"
        }
        Write-Host "  已修复expose_php设置" -ForegroundColor Green
    }
}

# 检查危险函数
$disableFunctions = Select-String -Path $phpIni -Pattern "disable_functions\s*=\s*(.*)" -AllMatches | ForEach-Object { $_.Matches.Groups[1].Value }
$dangerousFunctions = @("exec", "passthru", "shell_exec", "system", "proc_open", "popen")
$missingFunctions = @()

if ($disableFunctions) {
    foreach ($func in $dangerousFunctions) {
        if ($disableFunctions -notmatch $func) {
            $missingFunctions += $func
        }
    }
}

if ($missingFunctions.Count -eq 0) {
    Write-ColorOutput "危险函数已禁用" "PASS"
    $results += @{
        Category = "PHP配置"
        Check = "危险函数"
        Status = "PASS"
        Description = "所有危险的系统执行函数已禁用"
        Recommendation = ""
    }
} else {
    Write-ColorOutput "应禁用以下危险函数: $($missingFunctions -join ', ')" "FAIL"
    $results += @{
        Category = "PHP配置"
        Check = "危险函数"
        Status = "FAIL"
        Description = "以下危险函数未被禁用: $($missingFunctions -join ', ')"
        Recommendation = "在php.ini中添加这些函数到disable_functions列表"
    }
    
    if ($fixIssues) {
        if ($disableFunctions) {
            $newDisableFunctions = "$disableFunctions," + ($missingFunctions -join ',')
            (Get-Content $phpIni) -replace "disable_functions\s*=\s*(.*)", "disable_functions = $newDisableFunctions" | Set-Content $phpIni
        } else {
            $newDisableFunctions = $dangerousFunctions -join ','
            Add-Content $phpIni "`ndisable_functions = $newDisableFunctions"
        }
        Write-Host "  已修复危险函数设置" -ForegroundColor Green
    }
}

# 检查会话安全
$sessionSecure = Select-String -Path $phpIni -Pattern "session.cookie_secure\s*=\s*(\d+)" -AllMatches | ForEach-Object { $_.Matches.Groups[1].Value }
$sessionHttpOnly = Select-String -Path $phpIni -Pattern "session.cookie_httponly\s*=\s*(\d+)" -AllMatches | ForEach-Object { $_.Matches.Groups[1].Value }

if ($sessionSecure -eq "1" -and $sessionHttpOnly -eq "1") {
    Write-ColorOutput "会话Cookie安全设置正确" "PASS"
    $results += @{
        Category = "PHP配置"
        Check = "会话安全"
        Status = "PASS"
        Description = "会话Cookie已设置secure和httponly标志"
        Recommendation = ""
    }
} else {
    Write-ColorOutput "应加强会话Cookie安全设置" "FAIL"
    $results += @{
        Category = "PHP配置"
        Check = "会话安全"
        Status = "FAIL"
        Description = "会话Cookie未正确设置secure和httponly标志"
        Recommendation = "在php.ini中设置: session.cookie_secure = 1 和 session.cookie_httponly = 1"
    }
    
    if ($fixIssues) {
        if ($sessionSecure) {
            (Get-Content $phpIni) -replace "session.cookie_secure\s*=\s*(\d+)", "session.cookie_secure = 1" | Set-Content $phpIni
        } else {
            Add-Content $phpIni "`nsession.cookie_secure = 1"
        }
        
        if ($sessionHttpOnly) {
            (Get-Content $phpIni) -replace "session.cookie_httponly\s*=\s*(\d+)", "session.cookie_httponly = 1" | Set-Content $phpIni
        } else {
            Add-Content $phpIni "`nsession.cookie_httponly = 1"
        }
        
        Write-Host "  已修复会话安全设置" -ForegroundColor Green
    }
}

# 检查文件权限
Write-Host "`n检查文件权限..." -ForegroundColor Cyan

$webRoot = "$apacheRoot\www"
$sensitiveDirectories = @(
    "$webRoot\config",
    "$webRoot\includes",
    "$webRoot\admin"
)

foreach ($dir in $sensitiveDirectories) {
    if (Test-Path $dir) {
        $acl = Get-Acl $dir
        $everyoneAccess = $acl.Access | Where-Object { $_.IdentityReference -like "*Everyone*" -or $_.IdentityReference -like "*Users*" }
        
        if ($everyoneAccess -and ($everyoneAccess.FileSystemRights -match "Write|Modify|FullControl")) {
            Write-ColorOutput "目录 $dir 权限过于宽松" "FAIL"
            $results += @{
                Category = "文件权限"
                Check = "敏感目录权限"
                Status = "FAIL"
                Description = "目录 $dir 对普通用户有写入权限"
                Recommendation = "限制该目录的访问权限，仅允许必要的用户和服务账户访问"
            }
            
            if ($fixIssues) {
                # 移除Everyone和Users组的写入权限
                $acl = Get-Acl $dir
                $everyoneAccess | ForEach-Object {
                    $acl.RemoveAccessRule($_)
                }
                Set-Acl -Path $dir -AclObject $acl
                Write-Host "  已修复 $dir 的权限" -ForegroundColor Green
            }
        } else {
            Write-ColorOutput "目录 $dir 权限设置正确" "PASS"
            $results += @{
                Category = "文件权限"
                Check = "敏感目录权限"
                Status = "PASS"
                Description = "目录 $dir 权限设置正确"
                Recommendation = ""
            }
        }
    }
}

# 检查敏感文件
Write-Host "`n检查敏感文件..." -ForegroundColor Cyan

$sensitiveFiles = @(
    ".env",
    "config.php",
    "database.php",
    "db.php",
    "connection.php",
    "settings.php"
)

$foundSensitiveFiles = @()
foreach ($file in $sensitiveFiles) {
    $foundFiles = Get-ChildItem -Path $webRoot -Filter $file -Recurse -ErrorAction SilentlyContinue
    foreach ($foundFile in $foundFiles) {
        $foundSensitiveFiles += $foundFile.FullName
    }
}

if ($foundSensitiveFiles.Count -eq 0) {
    Write-ColorOutput "未发现暴露的敏感配置文件" "PASS"
    $results += @{
        Category = "敏感文件"
        Check = "配置文件"
        Status = "PASS"
        Description = "未发现暴露的敏感配置文件"
        Recommendation = ""
    }
} else {
    Write-ColorOutput "发现可能暴露的敏感配置文件: $($foundSensitiveFiles -join ', ')" "WARN"
    $results += @{
        Category = "敏感文件"
        Check = "配置文件"
        Status = "WARN"
        Description = "发现可能暴露的敏感配置文件: $($foundSensitiveFiles -join ', ')"
        Recommendation = "确保这些文件不能被直接访问，或移动到Web根目录之外"
    }
    
    if ($fixIssues) {
        foreach ($file in $foundSensitiveFiles) {
            $fileDir = Split-Path $file
            $htaccess = "$fileDir\.htaccess"
            
            if (-not (Test-Path $htaccess)) {
                @"
<Files ~ "^\.env|config\.php|database\.php|db\.php|connection\.php|settings\.php$">
    Require all denied
</Files>
"@ | Out-File -FilePath $htaccess -Encoding ASCII
                
                Write-Host "  已创建 $htaccess 保护敏感文件" -ForegroundColor Green
            }
        }
    }
}

# 生成HTML报告
Write-Host "`n生成安全检查报告..." -ForegroundColor Cyan

$htmlReport = @"
<!DOCTYPE html>
<html>
<head>
    <title>Apache和PHP安全检查报告</title>
    <meta charset="utf-8">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        h1, h2 { color: #333; }
        .container { max-width: 1200px; margin: 0 auto; }
        .summary { background: #f5f5f5; padding: 15px; margin-bottom: 20px; border-radius: 5px; }
        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f2f2f2; }
        .pass { color: green; }
        .warn { color: orange; }
        .fail { color: red; }
        .category { font-weight: bold; background-color: #e9e9e9; }
    
让我继续完成安全检查脚本的HTML报告生成部分：

```powershell:c:\project\kphub\scripts\security_check.ps1
        .category { font-weight: bold; background-color: #e9e9e9; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Apache和PHP安全检查报告</h1>
        <p>检查时间: $(Get-Date -Format "yyyy-MM-dd HH:mm:ss")</p>
        
        <div class="summary">
            <h2>安全检查摘要</h2>
            <p>
                通过: $($results | Where-Object { $_.Status -eq "PASS" } | Measure-Object | Select-Object -ExpandProperty Count) 项<br>
                警告: $($results | Where-Object { $_.Status -eq "WARN" } | Measure-Object | Select-Object -ExpandProperty Count) 项<br>
                失败: $($results | Where-Object { $_.Status -eq "FAIL" } | Measure-Object | Select-Object -ExpandProperty Count) 项
            </p>
        </div>
        
        <h2>详细检查结果</h2>
        <table>
            <tr>
                <th>类别</th>
                <th>检查项</th>
                <th>状态</th>
                <th>描述</th>
                <th>建议</th>
            </tr>
"@

$currentCategory = ""
foreach ($result in $results) {
    if ($result.Category -ne $currentCategory) {
        $currentCategory = $result.Category
        $htmlReport += @"
            <tr class="category">
                <td colspan="5">$($result.Category)</td>
            </tr>
"@
    }
    
    $statusClass = switch ($result.Status) {
        "PASS" { "pass" }
        "WARN" { "warn" }
        "FAIL" { "fail" }
        default { "" }
    }
    
    $statusText = switch ($result.Status) {
        "PASS" { "通过" }
        "WARN" { "警告" }
        "FAIL" { "失败" }
        default { $result.Status }
    }
    
    $htmlReport += @"
            <tr>
                <td></td>
                <td>$($result.Check)</td>
                <td class="$statusClass">$statusText</td>
                <td>$($result.Description)</td>
                <td>$($result.Recommendation)</td>
            </tr>
"@
}

$htmlReport += @"
        </table>
        
        <h2>安全建议</h2>
        <ul>
"@

# 添加失败项的建议
$failedItems = $results | Where-Object { $_.Status -eq "FAIL" }
foreach ($item in $failedItems) {
    if ($item.Recommendation) {
        $htmlReport += @"
            <li><strong>$($item.Category) - $($item.Check):</strong> $($item.Recommendation)</li>
"@
    }
}

# 添加警告项的建议
$warnItems = $results | Where-Object { $_.Status -eq "WARN" }
foreach ($item in $warnItems) {
    if ($item.Recommendation) {
        $htmlReport += @"
            <li><strong>$($item.Category) - $($item.Check):</strong> $($item.Recommendation)</li>
"@
    }
}

$htmlReport += @"
        </ul>
        
        <h2>一般安全最佳实践</h2>
        <ul>
            <li>定期更新Apache和PHP到最新版本</li>
            <li>使用HTTPS加密所有流量</li>
            <li>实施强密码策略</li>
            <li>定期备份网站和数据库</li>
            <li>使用Web应用防火墙(WAF)保护网站</li>
            <li>定期进行安全审计和渗透测试</li>
            <li>监控日志文件以检测可疑活动</li>
            <li>实施IP限制和访问控制</li>
            <li>使用内容安全策略(CSP)防止XSS攻击</li>
            <li>对所有用户输入进行验证和过滤</li>
        </ul>
    </div>
</body>
</html>
"@

$htmlReport | Out-File -FilePath $outputFile -Encoding utf8
Write-Host "安全检查报告已生成: $outputFile" -ForegroundColor Green

# 总结结果
$passCount = ($results | Where-Object { $_.Status -eq "PASS" } | Measure-Object).Count
$warnCount = ($results | Where-Object { $_.Status -eq "WARN" } | Measure-Object).Count
$failCount = ($results | Where-Object { $_.Status -eq "FAIL" } | Measure-Object).Count

Write-Host "`n安全检查完成" -ForegroundColor Cyan
Write-Host "通过: $passCount 项" -ForegroundColor Green
Write-Host "警告: $warnCount 项" -ForegroundColor Yellow
Write-Host "失败: $failCount 项" -ForegroundColor Red

if ($fixIssues) {
    Write-Host "`n已尝试自动修复发现的问题。请重启Apache和PHP服务以应用更改。" -ForegroundColor Cyan
}
```

## 10. 常见问题解答

以下是一些关于Apache和PHP环境的常见问题及其解答：

### 10.1 Apache常见问题

#### Q: Apache无法启动，提示端口80被占用怎么办？
A: 这通常是因为其他服务（如IIS、Skype或其他Web服务器）已经占用了80端口。解决方法：
1. 使用`netstat -ano | findstr :80`命令找出占用端口的进程ID
2. 在任务管理器中终止该进程，或更改其配置不使用80端口
3. 或者修改Apache配置文件中的`Listen`指令，使用其他端口（如8080）

#### Q: 访问网站显示"403 Forbidden"错误怎么解决？
A: 这通常是权限问题导致的，解决方法：
1. 检查网站目录的文件权限，确保Apache用户有读取权限
2. 检查`.htaccess`文件中是否有限制访问的规则
3. 检查Apache配置中的`<Directory>`指令，确保允许访问该目录

#### Q: 如何隐藏Apache和PHP版本信息？
A: 在Apache配置文件中添加：
```
ServerTokens Prod
ServerSignature Off
```
在PHP配置文件中设置：
```
expose_php = Off
```

#### Q: 如何启用HTTPS？
A: 需要配置SSL证书和启用SSL模块：
1. 确保`mod_ssl`模块已加载
2. 在配置文件中添加SSL虚拟主机配置
3. 指定SSL证书和私钥文件路径
4. 重启Apache服务

### 10.2 PHP常见问题

#### Q: PHP脚本执行超时怎么解决？
A: 可以在php.ini中增加超时限制：
```
max_execution_time = 300  ; 增加到300秒
```
或在PHP脚本开头添加：
```php
set_time_limit(300);  // 增加到300秒
```

#### Q: 如何增加PHP上传文件大小限制？
A: 需要修改php.ini中的几个相关设置：
```
upload_max_filesize = 20M
post_max_size = 20M
memory_limit = 128M
```

#### Q: PHP显示"Fatal error: Allowed memory size exhausted"错误怎么解决？
A: 增加PHP内存限制：
1. 在php.ini中设置：`memory_limit = 256M`
2. 或在PHP脚本开头添加：`ini_set('memory_limit', '256M');`

#### Q: 如何启用PHP错误显示进行调试？
A: 在php.ini中设置：
```
display_errors = On
display_startup_errors = On
error_reporting = E_ALL
```
或在PHP脚本开头添加：
```php
ini_set('display_errors', 1);
ini_set('display_startup_errors', 1);
error_reporting(E_ALL);
```

### 10.3 性能优化问题

#### Q: Apache占用内存过高怎么优化？
A: 可以通过以下方法优化：
1. 减少`MaxRequestWorkers`和`ServerLimit`的值
2. 使用`mpm_event_module`替代`prefork`
3. 禁用不必要的模块
4. 优化KeepAlive设置

#### Q: PHP脚本执行缓慢怎么优化？
A: 常见的PHP优化方法：
1. 启用OPcache加速PHP代码执行
2. 使用PHP-FPM替代mod_php
3. 优化数据库查询
4. 实施缓存机制（如Redis或Memcached）
5. 使用代码分析工具找出性能瓶颈

#### Q: 如何处理高流量网站的并发请求？
A: 高并发处理策略：
1. 使用负载均衡分散请求
2. 配置Apache的MPM为event或worker模式
3. 增加MaxRequestWorkers但不超过服务器能力
4. 使用PHP-FPM并优化其进程管理
5. 实施内容缓存和静态资源CDN

## 11. 参考资源

以下是一些有用的Apache和PHP参考资源：

### 11.1 官方文档
- [Apache HTTP Server文档](https://httpd.apache.org/docs/)
- [PHP官方文档](https://www.php.net/docs.php)

### 11.2 安全指南
- [OWASP Web安全测试指南](https://owasp.org/www-project-web-security-testing-guide/)
- [Apache安全提示](https://httpd.apache.org/docs/current/misc/security_tips.html)
- [PHP安全手册](https://www.php.net/manual/en/security.php)

### 11.3 性能优化资源
- [Apache性能调优](https://httpd.apache.org/docs/current/misc/perf-tuning.html)
- [PHP性能优化技巧](https://www.php.net/manual/en/performance.php)

### 11.4 故障排除资源
- [Apache常见问题](https://httpd.apache.org/docs/current/faq/)
- [PHP常见问题](https://www.php.net/manual/en/faq.php)
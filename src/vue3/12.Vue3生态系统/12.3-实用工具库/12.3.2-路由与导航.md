---
title: 路由与导航
icon: route
order: 2
---

# 路由与导航

在现代单页应用(SPA)中，路由系统是连接用户界面与应用状态的关键桥梁。Vue生态系统提供了强大的路由解决方案Vue Router，以及丰富的导航组件和增强工具，使开发者能够构建直观、高效的用户导航体验。本章将深入探讨Vue Router 4的核心功能、路由增强技术以及常见导航组件的实现方案。

## Vue Router 4

Vue Router是Vue.js官方的路由管理器，专为Vue.js应用程序开发设计。Vue Router 4是为Vue 3优化的版本，采用了与Vue 3相同的组合式API设计理念，提供了更灵活、更强大的路由管理能力。

### 路由配置与使用

#### 基础安装与配置

首先，需要安装Vue Router 4：

```bash
npm install vue-router@4
```

然后，创建路由实例并配置路由：

```javascript
// src/router/index.js
import { createRouter, createWebHistory } from 'vue-router'
import Home from '../views/Home.vue'
import About from '../views/About.vue'
import NotFound from '../views/NotFound.vue'

const routes = [
  {
    path: '/',
    name: 'Home',
    component: Home,
    // 路由元信息，可用于权限控制、页面标题等
    meta: { 
      title: '首页',
      requiresAuth: false
    }
  },
  {
    path: '/about',
    name: 'About',
    component: About,
    meta: { 
      title: '关于我们',
      requiresAuth: false
    }
  },
  // 动态路由参数
  {
    path: '/user/:id',
    name: 'User',
    // 路由懒加载，提高首屏加载速度
    component: () => import('../views/User.vue'),
    meta: { 
      title: '用户详情',
      requiresAuth: true
    }
  },
  // 嵌套路由
  {
    path: '/products',
    name: 'Products',
    component: () => import('../views/Products.vue'),
    children: [
      {
        path: '',
        name: 'ProductList',
        component: () => import('../views/ProductList.vue')
      },
      {
        path: ':id',
        name: 'ProductDetail',
        component: () => import('../views/ProductDetail.vue')
      }
    ]
  },
  // 命名视图（一个路由显示多个组件）
  {
    path: '/dashboard',
    name: 'Dashboard',
    components: {
      default: () => import('../views/Dashboard.vue'),
      sidebar: () => import('../components/Sidebar.vue'),
      header: () => import('../components/Header.vue')
    }
  },
  // 重定向
  {
    path: '/home',
    redirect: '/'
  },
  // 别名
  {
    path: '/main',
    alias: '/',
    component: Home
  },
  // 捕获所有未匹配路由
  {
    path: '/:pathMatch(.*)*',
    name: 'NotFound',
    component: NotFound
  }
]

const router = createRouter({
  // 使用HTML5历史模式，利用history.pushState API实现URL变化而无需刷新页面
  history: createWebHistory(),
  routes,
  // 自定义滚动行为
  scrollBehavior(to, from, savedPosition) {
    if (savedPosition) {
      // 如果是通过浏览器的前进/后退按钮导航，则恢复之前的滚动位置
      return savedPosition
    } else {
      // 否则滚动到页面顶部
      return { top: 0 }
    }
  }
})

export default router
```

在主应用中注册路由：

```javascript
// src/main.js
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'

const app = createApp(App)
app.use(router)
app.mount('#app')
```

#### 路由组件与导航

在模板中使用路由组件和导航链接：

```vue
<!-- App.vue -->
<template>
  <div class="app">
    <nav>
      <!-- 使用router-link组件进行导航 -->
      <router-link to="/">首页</router-link> |
      <router-link to="/about">关于</router-link> |
      <router-link :to="{ name: 'Products' }">产品</router-link> |
      <router-link :to="{ name: 'User', params: { id: 123 } }">用户</router-link>
    </nav>
    
    <!-- 路由出口，路由匹配的组件将渲染在这里 -->
    <router-view></router-view>
    
    <!-- 命名视图的出口 -->
    <router-view name="sidebar" class="sidebar"></router-view>
    <router-view name="header" class="header"></router-view>
  </div>
</template>
```

#### 路由模式

Vue Router支持三种路由模式：

1. **HTML5 History模式**：使用浏览器的history.pushState API实现URL变化而无需刷新页面。
   ```javascript
   createRouter({
     history: createWebHistory(),
     routes
   })
   ```

2. **Hash模式**：使用URL的hash部分（#后面的部分）来模拟完整的URL，不需要服务器配置。
   ```javascript
   import { createRouter, createWebHashHistory } from 'vue-router'
   
   createRouter({
     history: createWebHashHistory(),
     routes
   })
   ```

3. **内存模式**：不改变URL，适用于非浏览器环境或需要内嵌到其他应用的场景。
   ```javascript
   import { createRouter, createMemoryHistory } from 'vue-router'
   
   createRouter({
     history: createMemoryHistory(),
     routes
   })
   ```

#### 编程式导航

除了使用`<router-link>`组件，还可以通过编程方式导航：

```javascript
// 导航到指定路径
router.push('/about')

// 导航到命名路由
router.push({ name: 'User', params: { id: 123 } })

// 导航到带查询参数的路由
router.push({ path: '/search', query: { q: 'vue' } })

// 替换当前历史记录（不会新增历史记录）
router.replace('/about')

// 前进或后退
router.go(1)   // 前进一步
router.go(-1)  // 后退一步

// 直接前进或后退
router.back()  // 后退
router.forward() // 前进
```

### 组合式API中的路由

Vue Router 4与Vue 3的组合式API完美集成，提供了一系列组合式函数，使路由操作更加直观和灵活。

#### 基本路由钩子

```vue
<script setup>
import { useRouter, useRoute } from 'vue-router'
import { watch } from 'vue'

// 获取路由实例，用于编程式导航
const router = useRouter()

// 获取当前路由对象，包含当前URL解析得到的信息
const route = useRoute()

// 访问路由参数
console.log(route.params.id)

// 访问查询参数
console.log(route.query.q)

// 访问路由元信息
console.log(route.meta.title)

// 监听路由参数变化
watch(
  () => route.params.id,
  (newId) => {
    // 路由参数变化时执行操作
    console.log(`用户ID变更为: ${newId}`)
    fetchUserData(newId)
  }
)

// 编程式导航
function navigateToHome() {
  router.push('/')
}

function navigateToUser(id) {
  router.push({ name: 'User', params: { id } })
}
</script>
```

#### 路由组件生命周期钩子

在Vue 3的组合式API中，可以使用`onBeforeRouteUpdate`和`onBeforeRouteLeave`钩子：

```vue
<script setup>
import { onBeforeRouteUpdate, onBeforeRouteLeave } from 'vue-router'

// 在当前路由改变，但组件被复用时调用
onBeforeRouteUpdate((to, from) => {
  // 例如，路由从/user/1变为/user/2时
  console.log(`从${from.path}导航到${to.path}`)
  
  // 可以访问组件实例 `this`
  // 返回false取消导航
  // return false
})

// 在导航离开该组件的对应路由时调用
onBeforeRouteLeave((to, from) => {
  // 例如，用户填写了表单但未保存就要离开
  const answer = window.confirm('您有未保存的更改，确定要离开吗？')
  if (!answer) return false
})
</script>
```

#### 自定义组合式函数

可以创建自定义组合式函数封装路由相关逻辑：

```javascript
// composables/usePageTitle.js
import { watch } from 'vue'
import { useRoute } from 'vue-router'

export function usePageTitle(titleTemplate = '%s - My App') {
  const route = useRoute()
  
  // 更新页面标题的函数
  const updateTitle = (title) => {
    document.title = titleTemplate.replace('%s', title)
  }
  
  // 初始化标题
  if (route.meta.title) {
    updateTitle(route.meta.title)
  }
  
  // 监听路由变化，更新标题
  watch(
    () => route.meta.title,
    (newTitle) => {
      if (newTitle) {
        updateTitle(newTitle)
      }
    }
  )
  
  return { updateTitle }
}

// 在组件中使用
// <script setup>
// import { usePageTitle } from '@/composables/usePageTitle'
// 
// usePageTitle('%s - 我的应用')
// </script>
```

### 导航守卫最佳实践

导航守卫是Vue Router提供的一种机制，用于控制导航的行为，例如权限验证、数据预加载等。Vue Router提供了全局守卫、路由独享守卫和组件内守卫。

#### 全局前置守卫

全局前置守卫在导航触发时被调用，常用于权限验证、页面标题设置等：

```javascript
// src/router/index.js
router.beforeEach((to, from) => {
  // 设置页面标题
  if (to.meta.title) {
    document.title = `${to.meta.title} - My App`
  }
  
  // 权限验证
  if (to.meta.requiresAuth && !isAuthenticated()) {
    // 重定向到登录页
    return {
      name: 'Login',
      query: { redirect: to.fullPath }
    }
  }
})
```

#### 全局解析守卫

全局解析守卫在所有组件内守卫和异步路由组件被解析之后调用：

```javascript
router.beforeResolve(async (to) => {
  // 在导航被确认前，同时在所有组件内守卫和异步路由组件被解析后调用
  // 适合用于获取数据或执行其他异步操作
  if (to.meta.fetchData) {
    try {
      // 显示加载指示器
      showLoadingIndicator()
      // 执行数据预加载
      await loadData(to.params.id)
    } catch (error) {
      // 处理错误
      console.error('数据加载失败:', error)
      return false // 取消导航
    } finally {
      // 隐藏加载指示器
      hideLoadingIndicator()
    }
  }
})
```

#### 全局后置钩子

全局后置钩子在导航完成后调用，不会影响导航本身：

```javascript
router.afterEach((to, from) => {
  // 导航完成后的逻辑
  // 例如，发送页面访问统计
  sendAnalytics(to.fullPath)
  
  // 或者，滚动到页面顶部
  window.scrollTo(0, 0)
})
```

#### 路由独享守卫

路由独享守卫直接定义在路由配置中：

```javascript
const routes = [
  {
    path: '/admin',
    component: Admin,
    beforeEnter: (to, from) => {
      // 检查用户是否有管理员权限
      if (!hasAdminRole()) {
        return { name: 'Forbidden' }
      }
    }
  }
]
```

#### 组件内守卫

在组合式API中使用组件内守卫：

```vue
<script setup>
import { onBeforeRouteUpdate, onBeforeRouteLeave } from 'vue-router'

// 在当前路由改变，但组件被复用时调用
onBeforeRouteUpdate(async (to, from) => {
  // 例如，当路由参数变化时重新获取数据
  if (to.params.id !== from.params.id) {
    try {
      await fetchData(to.params.id)
    } catch (error) {
      // 处理错误
      showError(error.message)
      return false // 取消导航
    }
  }
})

// 在导航离开该组件的对应路由时调用
onBeforeRouteLeave((to, from) => {
  // 例如，防止用户意外离开编辑页面
  if (hasUnsavedChanges()) {
    const confirmed = window.confirm('您有未保存的更改，确定要离开吗？')
    if (!confirmed) return false
  }
})
</script>
```

#### 导航守卫最佳实践

1. **权限控制模式**：

```javascript
// src/router/guards/auth.js
export function setupAuthGuard(router) {
  router.beforeEach((to, from) => {
    const isAuthenticated = checkAuthStatus()
    
    // 需要认证但用户未登录
    if (to.meta.requiresAuth && !isAuthenticated) {
      return {
        name: 'Login',
        query: { redirect: to.fullPath }
      }
    }
    
    // 已登录用户访问登录页，重定向到首页
    if (to.name === 'Login' && isAuthenticated) {
      return { name: 'Home' }
    }
    
    // 角色权限检查
    if (to.meta.roles && !hasRequiredRole(to.meta.roles)) {
      return { name: 'Forbidden' }
    }
  })
}

// 在router/index.js中使用
import { setupAuthGuard } from './guards/auth'
// ...创建router实例后
setupAuthGuard(router)
```

2. **数据预加载模式**：

```javascript
// src/router/guards/dataLoader.js
export function setupDataLoaderGuard(router, store) {
  router.beforeResolve(async (to) => {
    // 获取需要预加载数据的组件
    const matched = to.matched.filter(record => record.meta.fetchData)
    
    if (matched.length === 0) return
    
    // 显示全局加载状态
    store.commit('setLoading', true)
    
    try {
      // 并行执行所有数据加载
      const dataPromises = matched.map(record => {
        return record.meta.fetchData({ 
          store, 
          route: to 
        })
      })
      
      await Promise.all(dataPromises)
    } catch (error) {
      console.error('数据预加载失败:', error)
      // 可以选择继续导航或取消
      // return false
    } finally {
      // 隐藏全局加载状态
      store.commit('setLoading', false)
    }
  })
}
```

3. **页面分析与跟踪模式**：

```javascript
// src/router/guards/analytics.js
export function setupAnalyticsGuard(router) {
  // 页面访问跟踪
  router.afterEach((to) => {
    // 发送页面访问事件
    sendPageView({
      page: to.fullPath,
      title: to.meta.title || 'Unknown Page',
      referrer: document.referrer
    })
    
    // 记录页面访问时间（用于计算停留时间）
    window._pageEnterTime = Date.now()
  })
  
  // 页面离开跟踪
  router.beforeEach((to, from) => {
    if (window._pageEnterTime) {
      const stayDuration = Date.now() - window._pageEnterTime
      
      // 发送页面停留时间事件
      sendPageStayEvent({
        page: from.fullPath,
        duration: stayDuration
      })
    }
  })
}
```

## 路由增强工具

基础的Vue Router功能已经能满足大多数应用需求，但在复杂应用中，我们通常需要更强大的路由管理能力。本节将介绍一些路由增强工具和技术，帮助开发者构建更灵活、更强大的路由系统。

### 路由元信息管理

路由元信息(meta)是附加在路由记录上的任意数据，可用于实现各种功能，如权限控制、页面标题、导航菜单等。

#### 结构化元信息

为了更好地管理路由元信息，可以定义一个结构化的元信息模式：

```javascript
// src/router/meta.js
/**
 * 路由元信息类型定义
 * @typedef {Object} RouteMeta
 * @property {string} title - 页面标题
 * @property {boolean} requiresAuth - 是否需要认证
 * @property {string[]} [roles] - 允许访问的角色列表
 * @property {string} [icon] - 菜单图标
 * @property {boolean} [hideInMenu] - 是否在菜单中隐藏
 * @property {boolean} [hideChildrenInMenu] - 是否在菜单中隐藏子项
 * @property {Function} [fetchData] - 数据预加载函数
 * @property {Object} [transition] - 页面过渡动画配置
 */

/**
 * 创建路由元信息
 * @param {Partial<RouteMeta>} meta - 元信息对象
 * @returns {RouteMeta} - 完整的元信息对象
 */
export function createRouteMeta(meta = {}) {
  return {
    title: 'Untitled Page',
    requiresAuth: false,
    ...meta
  }
}

// 使用示例
// import { createRouteMeta } from './meta'
// 
// const routes = [
//   {
//     path: '/dashboard',
//     component: Dashboard,
//     meta: createRouteMeta({
//       title: '控制台',
//       requiresAuth: true,
//       roles: ['admin', 'manager'],
//       icon: 'dashboard'
//     })
//   }
// ]
```

#### 元信息工具函数

创建一些工具函数，简化元信息的使用：

```javascript
// src/router/metaUtils.js
import { useRoute } from 'vue-router'
import { computed } from 'vue'

/**
 * 检查当前路由是否需要认证
 * @returns {boolean} 是否需要认证
 */
export function useRequiresAuth() {
  const route = useRoute()
  return computed(() => route.meta.requiresAuth === true)
}

/**
 * 检查当前路由是否对指定角色可访问
 * @param {string|string[]} roles - 要检查的角色
 * @returns {boolean} 是否可访问
 */
export function useHasAccess(roles) {
  const route = useRoute()
  
  return computed(() => {
    // 如果路由没有指定角色限制，则所有人可访问
    if (!route.meta.roles || route.meta.roles.length === 0) {
      return true
    }
    
    // 将单个角色转换为数组
    const userRoles = Array.isArray(roles) ? roles : [roles]
    
    // 检查用户角色是否有交集
    return userRoles.some(role => route.meta.roles.includes(role))
  })
}

/**
 * 获取当前路由的页面标题
 * @param {string} [defaultTitle=''] - 默认标题
 * @returns {string} 页面标题
 */
export function usePageTitle(defaultTitle = '') {
  const route = useRoute()
  return computed(() => route.meta.title || defaultTitle)
}
```

#### 基于元信息的组件

利用路由元信息创建通用组件：

```vue
<!-- src/components/AuthRequired.vue -->
<template>
  <slot v-if="isAuthenticated"></slot>
  <div v-else class="auth-required">
    <h2>需要登录</h2>
    <p>请先登录后再访问此页面</p>
    <button @click="login">登录</button>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const route = useRoute()
const router = useRouter()
const authStore = useAuthStore()

const isAuthenticated = computed(() => authStore.isAuthenticated)

function login() {
  router.push({
    name: 'Login',
    query: { redirect: route.fullPath }
  })
}
</script>

<!-- 使用示例 -->
<!-- 
<template>
  <AuthRequired>
    <DashboardContent />
  </AuthRequired>
</template>
-->
```

### 动态路由与权限控制

动态路由是指在应用运行时添加、修改或删除路由配置，常用于实现基于用户权限的路由控制。

#### 基于角色的动态路由

```javascript
// src/router/index.js
import { createRouter, createWebHistory } from 'vue-router'

// 基础路由，所有用户可访问
const constantRoutes = [
  {
    path: '/',
    name: 'Home',
    component: () => import('../views/Home.vue')
  },
  {
    path: '/login',
    name: 'Login',
    component: () => import('../views/Login.vue')
  },
  {
    path: '/404',
    name: 'NotFound',
    component: () => import('../views/NotFound.vue')
  }
]

// 动态路由，根据用户角色动态添加
const asyncRoutes = [
  {
    path: '/dashboard',
    name: 'Dashboard',
    component: () => import('../views/Dashboard.vue'),
    meta: { roles: ['admin', 'editor'] }
  },
  {
    path: '/user',
    name: 'User',
    component: () => import('../views/User.vue'),
    meta: { roles: ['admin'] }
  },
  {
    path: '/article',
    name: 'Article',
    component: () => import('../views/Article.vue'),
    meta: { roles: ['editor'] }
  }
]

const router = createRouter({
  history: createWebHistory(),
  routes: constantRoutes
})

// 根据用户角色过滤路由
function filterAsyncRoutes(routes, roles) {
  const res = []
  
  routes.forEach(route => {
    const tmp = { ...route }
    
    // 检查用户是否有权限访问该路由
    if (hasPermission(roles, tmp)) {
      // 递归处理子路由
      if (tmp.children) {
        tmp.children = filterAsyncRoutes(tmp.children, roles)
      }
      res.push(tmp)
    }
  })
  
  return res
}

// 检查用户角色是否有权限
function hasPermission(roles, route) {
  if (route.meta && route.meta.roles) {
    // 检查用户角色是否与路由所需角色有交集
    return roles.some(role => route.meta.roles.includes(role))
  }
  // 如果路由没有设置roles，则认为所有人可访问
  return true
}

// 动态添加路由的函数
export function setupDynamicRoutes(roles) {
  // 根据用户角色过滤路由
  const accessibleRoutes = filterAsyncRoutes(asyncRoutes, roles)
  
  // 动态添加路由
  accessibleRoutes.forEach(route => {
    router.addRoute(route)
  })
  
  // 添加404路由，必须放在最后
  router.addRoute({
    path: '/:pathMatch(.*)*',
    redirect: '/404'
  })
}

export default router
```

在用户登录后动态添加路由：

```javascript
// src/stores/auth.js
import { defineStore } from 'pinia'
import { setupDynamicRoutes } from '@/router'

export const useAuthStore = defineStore('auth', {
  state: () => ({
    user: null,
    token: null,
    roles: []
  }),
  
  getters: {
    isAuthenticated: (state) => !!state.token,
    userRoles: (state) => state.roles
  },
  
  actions: {
    async login(credentials) {
      try {
        // 调用登录API
        const response = await api.login(credentials)
        
        // 保存用户信息和token
        this.user = response.user
        this.token = response.token
        this.roles = response.roles
        
        // 根据用户角色设置动态路由
        setupDynamicRoutes(this.roles)
        
        return true
      } catch (error) {
        console.error('登录失败:', error)
        return false
      }
    },
    
    logout() {
      this.user = null
      this.token = null
      this.roles = []
      
      // 重置路由
      window.location.reload()
    }
  }
})
```

#### 基于权限的菜单生成

利用路由配置自动生成导航菜单：

```vue
<!-- src/components/SideMenu.vue -->
<template>
  <div class="side-menu">
    <div v-for="route in menuRoutes" :key="route.path" class="menu-item">
      <router-link :to="route.path" v-if="!route.children || route.children.length === 0">
        <i v-if="route.meta && route.meta.icon" :class="route.meta.icon"></i>
        <span>{{ route.meta?.title || route.name }}</span>
      </router-link>
      
      <div v-else class="submenu">
        <div class="submenu-title">
          <i v-if="route.meta && route.meta.icon" :class="route.meta.icon"></i>
          <span>{{ route.meta?.title || route.name }}</span>
        </div>
        
        <div class="submenu-items">
          <router-link 
            v-for="child in route.children" 
            :key="child.path"
            :to="`${route.path}/${child.path}`"
          >
            <i v-if="child.meta && child.meta.icon" :class="child.meta.icon"></i>
            <span>{{ child.meta?.title || child.name }}</span>
          </router-link>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useRouter } from 'vue-router'
import { useAuthStore } from '@/stores/auth'

const router = useRouter()
const authStore = useAuthStore()

// 获取用户角色
const userRoles = computed(() => authStore.userRoles)

// 过滤路由，生成菜单
const menuRoutes = computed(() => {
  // 获取所有路由
  const routes = router.getRoutes()
  
  // 过滤出要显示在菜单中的路由
  return routes.filter(route => {
    // 排除不显示在菜单中的路由
    if (route.meta && route.meta.hideInMenu) {
      return false
    }
    
    // 检查权限
    if (route.meta && route.meta.roles) {
      return userRoles.value.some(role => route.meta.roles.includes(role))
    }
    
    return true
  }).map(route => {
    // 处理子路由
    if (route.children) {
      // 过滤子路由
      const children = route.children.filter(child => {
        if (child.meta && child.meta.hideInMenu) {
          return false
        }
        
        if (child.meta && child.meta.roles) {
          return userRoles.value.some(role => child.meta.roles.includes(role))
        }
        
        return true
      })
      
      return {
        ...route,
        children
      }
    }
    
    return route
  })
})
</script>
```

### 路由过渡动画

Vue Router与Vue的过渡系统无缝集成，可以为路由切换添加平
让我继续完成关于路由过渡动画的内容：

### 路由过渡动画

Vue Router与Vue的过渡系统无缝集成，可以为路由切换添加平滑的过渡效果，提升用户体验。

#### 基础路由过渡

最简单的方式是使用`<router-view>`外层包裹`<transition>`组件：

```vue
<template>
  <div class="app">
    <!-- 基础过渡效果 -->
    <transition name="fade">
      <router-view></router-view>
    </transition>
  </div>
</template>

<style>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}

.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
```

#### 基于路由的动态过渡

可以根据路由信息动态选择不同的过渡效果：

```vue
<template>
  <div class="app">
    <!-- 动态过渡名称 -->
    <transition :name="transitionName">
      <router-view></router-view>
    </transition>
  </div>
</template>

<script setup>
import { ref, watch } from 'vue'
import { useRoute } from 'vue-router'

const route = useRoute()
const transitionName = ref('fade')

// 监听路由变化，根据路由元信息设置过渡效果
watch(
  () => route.meta.transition,
  (transition) => {
    if (transition) {
      transitionName.value = transition
    } else {
      // 默认过渡效果
      transitionName.value = 'fade'
    }
  },
  { immediate: true }
)
</script>

<style>
/* 淡入淡出过渡 */
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}
.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}

/* 滑动过渡 */
.slide-left-enter-active,
.slide-left-leave-active,
.slide-right-enter-active,
.slide-right-leave-active {
  transition: transform 0.3s ease;
}
.slide-left-enter-from,
.slide-right-leave-to {
  transform: translateX(-100%);
}
.slide-left-leave-to,
.slide-right-enter-from {
  transform: translateX(100%);
}

/* 缩放过渡 */
.zoom-enter-active,
.zoom-leave-active {
  transition: transform 0.3s ease, opacity 0.3s ease;
}
.zoom-enter-from,
.zoom-leave-to {
  transform: scale(0.9);
  opacity: 0;
}
</style>
```

在路由配置中设置过渡效果：

```javascript
const routes = [
  {
    path: '/',
    component: Home,
    meta: { transition: 'fade' }
  },
  {
    path: '/about',
    component: About,
    meta: { transition: 'slide-left' }
  },
  {
    path: '/contact',
    component: Contact,
    meta: { transition: 'zoom' }
  }
]
```

#### 基于导航方向的过渡

根据导航方向（前进/后退）选择不同的过渡效果：

```vue
<template>
  <div class="app">
    <transition :name="transitionName">
      <router-view v-slot="{ Component }">
        <component :is="Component" />
      </router-view>
    </transition>
  </div>
</template>

<script setup>
import { ref, watch } from 'vue'
import { useRouter } from 'vue-router'

const router = useRouter()
const transitionName = ref('fade')

// 记录历史堆栈位置
let historyState = window.history.state?.position || 0

// 监听路由变化
watch(
  () => router.currentRoute.value,
  (to, from) => {
    // 获取当前历史位置
    const toState = window.history.state?.position || 0
    
    // 判断导航方向
    if (toState > historyState) {
      // 前进
      transitionName.value = 'slide-left'
    } else if (toState < historyState) {
      // 后退
      transitionName.value = 'slide-right'
    } else {
      // 直接导航（非前进/后退）
      transitionName.value = 'fade'
    }
    
    // 更新历史位置
    historyState = toState
  }
)
</script>
```

#### 页面过渡组件

创建一个可复用的页面过渡组件：

```vue
<!-- src/components/PageTransition.vue -->
<template>
  <transition
    :name="name"
    :mode="mode"
    :duration="duration"
    :appear="appear"
    @before-enter="onBeforeEnter"
    @enter="onEnter"
    @after-enter="onAfterEnter"
    @enter-cancelled="onEnterCancelled"
    @before-leave="onBeforeLeave"
    @leave="onLeave"
    @after-leave="onAfterLeave"
    @leave-cancelled="onLeaveCancelled"
  >
    <slot></slot>
  </transition>
</template>

<script setup>
import { computed } from 'vue'
import { useRoute } from 'vue-router'

const props = defineProps({
  // 过渡名称，如果未提供则从路由元信息获取
  name: {
    type: String,
    default: null
  },
  // 过渡模式：默认同时进行，'out-in'先出后进，'in-out'先进后出
  mode: {
    type: String,
    default: 'out-in'
  },
  // 过渡持续时间
  duration: {
    type: [Number, Object],
    default: null
  },
  // 是否在初始渲染时应用过渡
  appear: {
    type: Boolean,
    default: true
  }
})

const emit = defineEmits([
  'before-enter',
  'enter',
  'after-enter',
  'enter-cancelled',
  'before-leave',
  'leave',
  'after-leave',
  'leave-cancelled'
])

const route = useRoute()

// 计算实际使用的过渡名称
const transitionName = computed(() => {
  // 优先使用props中的name
  if (props.name) {
    return props.name
  }
  
  // 其次使用路由元信息中的transition
  if (route.meta.transition) {
    return route.meta.transition
  }
  
  // 默认使用fade过渡
  return 'fade'
})

// 过渡钩子函数
const onBeforeEnter = (el) => emit('before-enter', el)
const onEnter = (el, done) => emit('enter', el, done)
const onAfterEnter = (el) => emit('after-enter', el)
const onEnterCancelled = (el) => emit('enter-cancelled', el)
const onBeforeLeave = (el) => emit('before-leave', el)
const onLeave = (el, done) => emit('leave', el, done)
const onAfterLeave = (el) => emit('after-leave', el)
const onLeaveCancelled = (el) => emit('leave-cancelled', el)
</script>

<style>
/* 基础过渡效果 */
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.3s ease;
}
.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}

/* 滑动过渡 */
.slide-left-enter-active,
.slide-left-leave-active,
.slide-right-enter-active,
.slide-right-leave-active {
  transition: transform 0.3s ease;
}
.slide-left-enter-from,
.slide-right-leave-to {
  transform: translateX(-100%);
}
.slide-left-leave-to,
.slide-right-enter-from {
  transform: translateX(100%);
}

/* 缩放过渡 */
.zoom-enter-active,
.zoom-leave-active {
  transition: transform 0.3s ease, opacity 0.3s ease;
}
.zoom-enter-from,
.zoom-leave-to {
  transform: scale(0.9);
  opacity: 0;
}

/* 翻转过渡 */
.flip-enter-active,
.flip-leave-active {
  transition: transform 0.6s;
  transform-style: preserve-3d;
}
.flip-enter-from,
.flip-leave-to {
  transform: rotateY(180deg);
}
</style>
```

在应用中使用：

```vue
<template>
  <div class="app">
    <PageTransition>
      <router-view v-slot="{ Component }">
        <component :is="Component" />
      </router-view>
    </PageTransition>
  </div>
</template>

<script setup>
import PageTransition from '@/components/PageTransition.vue'
</script>
```

#### 使用JavaScript动画库

对于更复杂的动画效果，可以结合JavaScript动画库，如GSAP：

```vue
<template>
  <div class="app">
    <router-view v-slot="{ Component }">
      <transition
        @enter="onEnter"
        @leave="onLeave"
        :css="false"
      >
        <component :is="Component" />
      </transition>
    </router-view>
  </div>
</template>

<script setup>
import { gsap } from 'gsap'

// 使用GSAP实现进入动画
const onEnter = (el, done) => {
  gsap.fromTo(
    el,
    {
      opacity: 0,
      y: 30
    },
    {
      opacity: 1,
      y: 0,
      duration: 0.5,
      ease: 'power2.out',
      onComplete: done
    }
  )
}

// 使用GSAP实现离开动画
const onLeave = (el, done) => {
  gsap.to(el, {
    opacity: 0,
    y: -30,
    duration: 0.5,
    ease: 'power2.in',
    onComplete: done
  })
}
</script>
```

## 导航组件库

导航组件是用户界面中的重要元素，帮助用户了解当前位置并在应用中移动。本节将介绍几种常见的导航组件实现方案。

### 面包屑导航

面包屑导航显示用户在应用中的位置层次，帮助用户理解当前页面在整个网站结构中的位置，并提供快速返回上级页面的途径。

#### 基础面包屑组件

```vue
<!-- src/components/Breadcrumb.vue -->
<template>
  <nav aria-label="breadcrumb" class="breadcrumb">
    <ol>
      <li v-for="(item, index) in breadcrumbs" :key="index">
        <router-link
          v-if="index < breadcrumbs.length - 1"
          :to="item.path"
        >
          {{ item.title }}
        </router-link>
        <span v-else>{{ item.title }}</span>
      </li>
    </ol>
  </nav>
</template>

<script setup>
import { computed } from 'vue'
import { useRoute, useRouter } from 'vue-router'

const route = useRoute()
const router = useRouter()

// 生成面包屑数据
const breadcrumbs = computed(() => {
  // 获取当前路由的匹配记录
  const matched = route.matched.filter(item => item.meta && item.meta.title)
  
  // 始终添加首页
  const result = [
    {
      path: '/',
      title: '首页'
    }
  ]
  
  // 添加匹配的路由
  matched.forEach(item => {
    // 解析动态路由参数
    const path = item.path.replace(/:([^/]+)/g, (_, key) => {
      return route.params[key]
    })
    
    result.push({
      path,
      title: item.meta.title
    })
  })
  
  return result
})
</script>

<style>
.breadcrumb {
  margin: 16px 0;
}

.breadcrumb ol {
  display: flex;
  flex-wrap: wrap;
  list-style: none;
  padding: 0;
  margin: 0;
}

.breadcrumb li {
  display: flex;
  align-items: center;
}

.breadcrumb li:not(:last-child)::after {
  content: '/';
  margin: 0 8px;
  color: #ccc;
}

.breadcrumb a {
  color: #1890ff;
  text-decoration: none;
}

.breadcrumb a:hover {
  color: #40a9ff;
}

.breadcrumb span {
  color: rgba(0, 0, 0, 0.65);
}
</style>
```

#### 高级面包屑组件

增加自定义面包屑和图标支持：

```vue
<!-- src/components/AdvancedBreadcrumb.vue -->
<template>
  <nav aria-label="breadcrumb" class="breadcrumb">
    <ol>
      <li v-for="(item, index) in breadcrumbItems" :key="index">
        <router-link
          v-if="index < breadcrumbItems.length - 1 && item.path"
          :to="item.path"
        >
          <i v-if="item.icon" :class="item.icon"></i>
          {{ item.title }}
        </router-link>
        <span v-else>
          <i v-if="item.icon" :class="item.icon"></i>
          {{ item.title }}
        </span>
      </li>
    </ol>
  </nav>
</template>

<script setup>
import { computed } from 'vue'
import { useRoute, useRouter } from 'vue-router'

const props = defineProps({
  // 自定义面包屑项
  items: {
    type: Array,
    default: () => []
  },
  // 是否显示首页
  showHome: {
    type: Boolean,
    default: true
  },
  // 首页配置
  home: {
    type: Object,
    default: () => ({
      title: '首页',
      path: '/',
      icon: 'icon-home'
    })
  }
})

const route = useRoute()
const router = useRouter()

// 生成面包屑数据
const breadcrumbItems = computed(() => {
  // 如果提供了自定义项，则使用自定义项
  if (props.items && props.items.length > 0) {
    return props.items
  }
  
  // 否则根据路由自动生成
  const result = []
  
  // 添加首页
  if (props.showHome) {
    result.push(props.home)
  }
  
  // 获取当前路由的匹配记录
  const matched = route.matched.filter(item => item.meta && item.meta.title)
  
  // 添加匹配的路由
  matched.forEach(item => {
    // 解析动态路由参数
    const path = item.path.replace(/:([^/]+)/g, (_, key) => {
      return route.params[key]
    })
    
    result.push({
      path,
      title: item.meta.title,
      icon: item.meta.icon
    })
  })
  
  return result
})
</script>
```

#### 动态面包屑

有时路由配置无法完全满足面包屑需求，例如显示动态内容（如文章标题）。可以创建一个动态面包屑系统：

```vue
<!-- src/components/DynamicBreadcrumb.vue -->
<template>
  <nav aria-label="breadcrumb" class="breadcrumb">
    <ol>
      <li v-for="(item, index) in breadcrumbItems" :key="index">
        <router-link
          v-if="index < breadcrumbItems.length - 1 && item.path"
          :to="item.path"
        >
          <i v-if="item.icon" :class="item.icon"></i>
          {{ item.title }}
        </router-link>
        <span v-else>
          <i v-if="item.icon" :class="item.icon"></i>
          {{ item.title }}
        </span>
      </li>
    </ol>
  </nav>
</template>

<script setup>
import { computed, inject, provide, ref } from 'vue'
import { useRoute } from 'vue-router'

// 创建面包屑上下文
const BreadcrumbKey = Symbol('breadcrumb')

// 提供面包屑上下文
export function provideBreadcrumb() {
  // 存储动态面包屑项
  const dynamicItems = ref({})
  
  // 设置面包屑项
  const setBreadcrumb = (key, item) => {
    dynamicItems.value[key] = item
  }
  
  // 清除面包屑项
  const clearBreadcrumb = (key) => {
    if (key) {
      delete dynamicItems.value[key]
    } else {
      dynamicItems.value = {}
    }
  }
  
  // 提供上下文
  provide(BreadcrumbKey, {
    dynamicItems,
    setBreadcrumb,
    clearBreadcrumb
  })
  
  return {
    setBreadcrumb,
    clearBreadcrumb
  }
}

// 在组件中使用面包屑上下文
export function useBreadcrumb() {
  const context = inject(BreadcrumbKey)
  
  if (!context) {
    throw new Error('useBreadcrumb must be used within a component that calls provideBreadcrumb')
  }
  
  return context
}

// 组件props
const props = defineProps({
  // 是否显示首页
  showHome: {
    type: Boolean,
    default: true
  },
  // 首页配置
  home: {
    type: Object,
    default: () => ({
      title: '首页',
      path: '/',
      icon: 'icon-home'
    })
  }
})

// 获取路由和面包屑上下文
const route = useRoute()
const breadcrumbContext = inject(BreadcrumbKey, { dynamicItems: ref({}) })

// 生成面包屑数据
const breadcrumbItems = computed(() => {
  const result = []
  
  // 添加首页
  if (props.showHome) {
    result.push(props.home)
  }
  
  // 获取当前路由的匹配记录
  const matched = route.matched.filter(item => item.meta && item.meta.title)
  
  // 添加匹配的路由
  matched.forEach(item => {
    // 解析动态路由参数
    const path = item.path.replace(/:([^/]+)/g, (_, key) => {
      return route.params[key]
    })
    
    // 检查是否有动态面包屑项
    const dynamicItem = breadcrumbContext.dynamicItems.value[item.name]
    
    if (dynamicItem) {
      // 使用动态项
      result.push({
        ...dynamicItem,
        path: dynamicItem.path || path
      })
    } else {
      // 使用路由元信息
      result.push({
        path,
        title: item.meta.title,
        icon: item.meta.icon
      })
    }
  })
  
  return result
})
</script>
```

在应用中使用动态面包屑：

```vue
<!-- App.vue -->
<template>
  <div class="app">
    <DynamicBreadcrumb />
    <router-view></router-view>
  </div>
</template>

<script setup>
import DynamicBreadcrumb, { provideBreadcrumb } from '@/components/DynamicBreadcrumb.vue'

// 提供面包屑上下文
provideBreadcrumb()
</script>

<!-- 文章详情页 -->
<template>
  <div class="article-detail">
    <h1>{{ article.title }}</h1>
    <div class="content">{{ article.content }}</div>
  </div>
</template>

<script setup>
import { onMounted, onUnmounted } from 'vue'
import { useRoute } from 'vue-router'
import { useBreadcrumb } from '@/components/DynamicBreadcrumb.vue'

const route = useRoute()
const { setBreadcrumb, clearBreadcrumb } = useBreadcrumb()

// 模拟文章数据
const article = ref({
  id: 0,
  title: '',
  content: ''
})

// 获取文章数据
const fetchArticle = async (id) => {
  // 模拟API调用
  const response = await fetch(`/api/articles/${id}`)
  article.value = await response.json()
  
  // 设置动态面包屑
  setBreadcrumb('ArticleDetail', {
    title: article.value.title
  })
}

onMounted(() => {
  fetchArticle(route.params.id)
})

onUnmounted(() => {
  // 清除动态面包屑
  clearBreadcrumb('ArticleDetail')
})
</script>
```

### 菜单组件

菜单是应用导航的核心组件，提供了应用的主要导航结构。

#### 基础菜单组件

```vue
<!-- src/components/Menu.vue -->
<template>
  <nav class="menu">
    <ul>
      <li v-for="item in menuItems" :key="item.path" :class="{ active: isActive(item) }">
        <router-link v-if="!item.children" :to="item.path">
          <i v-if="item.icon" :class="item.icon"></i>
          <span>{{ item.title }}</span>
        </router-link>
        
        <div v-else class="submenu">
          <div class="submenu-title" @click="toggleSubmenu(item)">
            <i v-if="item.icon" :class="item.icon"></i>
            <span>{{ item.title }}</span>
            <i :class="[item.open ? 'icon-arrow-up' : 'icon-arrow-down']"></i>
          </div>
          
          <transition name="submenu">
            <ul v-show="item.open">
              <li 
                v-for="child in item.children" 
                :key="child.path"
                :class="{ active: isActive(child) }"
              >
                <router-link :to="child.path">
                  <i v-if="child.icon" :class="child.icon"></i>
                  <span>{{ child.title }}</span>
                </router-link>
              </li>
            </ul>
          </transition>
        </div>
      </li>
    </ul>
  </nav>
</template>

<script setup>
import { ref, computed, watch } from 'vue'
import { useRoute, useRouter } from 'vue-router'

const props = defineProps({
  // 菜单项配置
  items: {
    type: Array,
    required: true
  },
  // 是否默认展开所有子菜单
  defaultOpenAll: {
    type: Boolean,
    default: false
  },
  // 是否只允许一个子菜单展开
  accordion: {
    type: Boolean,
    default: false
  }
})

const route = useRoute()
const router = useRouter()

// 处理菜单项，添加open状态
const menuItems = ref([])

// 初始化菜单项
const initMenuItems = () => {
  menuItems.value = props.items.map(item => ({
    ...item,
    open: props.defaultOpenAll || isInPath(item)
  }))
}

// 检查路由是否在当前路径中
const isInPath = (item) => {
  if (!item.children) {
    return false
  }
  
  // 检查子项是否包含当前路径
  return item.children.some(child => {
    return route.path.startsWith(child.path)
  })
}

// 检查菜单项是否激活
const isActive = (item) => {
  return route.path === item.path || route.path.startsWith(`${item.path}/`)
}

// 切换子菜单展开状态
const toggleSubmenu = (item) => {
  item.open = !item.open
  
  // 如果是手风琴模式，关闭其他子菜单
  if (props.accordion && item.open) {
    menuItems.value.forEach(menuItem => {
      if (menuItem !== item) {
        menuItem.open = false
      }
    })
  }
}

// 监听路由变化，更新菜单状态
watch(
  () => route.path,
  () => {
    // 如果不是手风琴模式，根据路径自动展开子菜单
    if (!props.accordion) {
      menuItems.value.forEach(item => {
        if (item.children) {
          item.open = isInPath(item)
        }
      })
    }
  }
)

// 初始化
initMenuItems()
</script>

<style>
.menu {
  width: 240px;
  background-color: #001529;
  color: rgba(255, 255, 255, 0.65);
}

.menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

.menu li {
  line-height: 40px;
}

.menu a {
  display: block;
  padding: 0 16px;
  color: rgba(255, 255, 255, 0.65);
  text-decoration: none;
  transition: color 0.3s;
}

.menu a:hover,
.menu .active > a {
  color: #fff;
}

.menu .submenu-title {
  padding: 0 16px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.menu .submenu-title:hover {
  color: #fff;
}

.menu .submenu ul {
  background-color: #000c17;
}

.menu .submenu li a {
  padding-left: 32px;
}

.menu i {
  margin-right: 8px;
}

/* 子菜单动画 */
.submenu-enter-active,
.submenu-leave-active {
  transition: max-height 0.3s ease;
  overflow: hidden;
}

.submenu-enter-from,
.submenu-leave-to {
  max-height: 0;
}

.submenu-enter-to,
.submenu-leave-from {
  max-height: 500px; /* 足够大的值以容纳内容 */
}
</style>
```

使用菜单组件：

```vue
<template>
  <div class="app">
    <Menu :items="menuItems" :accordion="true" />
    <div class="content">
      <router-view></router-view>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import Menu from '@/components/Menu.vue'

// 菜单配置
const menuItems = ref([
  {
    path: '/',
    title: '首页',
    icon: 'icon-home'
  },
  {
    path: '/dashboard',
    title: '控制台',
    icon: 'icon-dashboard'
  },
  {
    title: '用户管理',
    icon: 'icon-user',
    children: [
      {
        path: '/users',
        title: '用户列表'
      },
      {
        path: '/users/create',
        title: '创建用户'
      },
      {
        path: '/roles',
        title: '角色管理'
      }
    ]
  },
  {
    title: '内容管理',
    icon: 'icon-file',
    children: [
      {
        path: '/articles',
        title: '文章列表'
      },
      {
        path: '/categories',
        title: '分类管理'
      },
      {
        path: '/tags',
        title: '标签管理'
      }
    ]
  },
  {
    path: '/settings',
    title: '系统设置',
    icon: 'icon-setting'
  }
])
</script>
```

#### 基于路由的菜单生成

自动根据路由配置生成菜单：

```vue
<!-- src/components/RouterMenu.vue -->
<template>
  <Menu :items="menuItems" :accordion="accordion" :defaultOpenAll="defaultOpenAll" />
</template>

<script setup>
import { computed } from 'vue'
import { useRouter } from 'vue-router'
import Menu from '@/components/Menu.vue'

const props = defineProps({
  // 是否默认展开所有子菜单
  defaultOpenAll: {
    type: Boolean,
    default: false
  },
  // 是否只允许一个子菜单展开
  accordion: {
    type: Boolean,
    default: false
  }
})

const router = useRouter()

// 根据路由生成菜单项
const menuItems = computed(() => {
  // 获取所有路由
  const routes = router.getRoutes()
  
  // 过滤和转换路由
  const items = routes
    .filter(route => {
      // 排除不显示在菜单中的路由
      return !(route.meta && route.meta.hideInMenu)
    })
    .map(route => {
      // 转换为菜单项格式
      return {
        path: route
让我继续完成关于基于路由的菜单生成组件的内容：

```vue
<!-- src/components/RouterMenu.vue -->
<template>
  <Menu :items="menuItems" :accordion="accordion" :defaultOpenAll="defaultOpenAll" />
</template>

<script setup>
import { computed } from 'vue'
import { useRouter } from 'vue-router'
import Menu from '@/components/Menu.vue'

const props = defineProps({
  // 是否默认展开所有子菜单
  defaultOpenAll: {
    type: Boolean,
    default: false
  },
  // 是否只允许一个子菜单展开
  accordion: {
    type: Boolean,
    default: false
  }
})

const router = useRouter()

// 根据路由生成菜单项
const menuItems = computed(() => {
  // 获取所有路由
  const routes = router.getRoutes()
  
  // 过滤和转换路由
  const items = routes
    .filter(route => {
      // 排除不显示在菜单中的路由
      return !(route.meta && route.meta.hideInMenu)
    })
    .map(route => {
      // 转换为菜单项格式
      return {
        path: route.path,
        title: route.meta?.title || route.name,
        icon: route.meta?.icon,
        order: route.meta?.order || 0
      }
    })
    .sort((a, b) => a.order - b.order)
  
  // 构建菜单树
  const result = []
  const map = {}
  
  // 第一步：创建映射
  items.forEach(item => {
    map[item.path] = { ...item, children: [] }
  })
  
  // 第二步：构建树结构
  items.forEach(item => {
    const path = item.path
    
    // 跳过根路径
    if (path === '/') {
      result.push(map[path])
      return
    }
    
    // 查找父路径
    const segments = path.split('/').filter(Boolean)
    
    if (segments.length === 1) {
      // 一级路径，直接添加到结果
      result.push(map[path])
    } else {
      // 查找父路径
      const parentPath = '/' + segments.slice(0, segments.length - 1).join('/')
      
      if (map[parentPath]) {
        // 如果父路径存在，添加为子项
        map[parentPath].children.push(map[path])
      } else {
        // 如果父路径不存在，添加到结果
        result.push(map[path])
      }
    }
  })
  
  // 过滤掉没有子项的父菜单
  return result.map(item => {
    if (item.children && item.children.length === 0) {
      const { children, ...rest } = item
      return rest
    }
    return item
  })
})
</script>
```

### 标签页导航

标签页导航是一种常见的导航模式，允许用户在多个页面之间快速切换，类似于浏览器的标签页。

#### 基础标签页导航组件

```vue
<!-- src/components/TabsNav.vue -->
<template>
  <div class="tabs-nav">
    <div class="tabs-wrapper" ref="tabsWrapper">
      <div class="tabs-scroll" ref="tabsScroll">
        <div 
          v-for="tab in tabs" 
          :key="tab.path" 
          class="tab" 
          :class="{ active: isActive(tab) }"
          @click="switchTab(tab)"
        >
          <span class="tab-title">{{ tab.title }}</span>
          <button 
            v-if="tab.closable" 
            class="tab-close" 
            @click.stop="closeTab(tab)"
          >
            ×
          </button>
        </div>
      </div>
    </div>
    
    <div class="tabs-actions">
      <button class="tabs-action" @click="refreshCurrent">
        <i class="icon-refresh"></i>
      </button>
      <button class="tabs-action" @click="showContextMenu">
        <i class="icon-more"></i>
      </button>
    </div>
    
    <!-- 右键菜单 -->
    <div 
      v-show="contextMenuVisible" 
      class="context-menu" 
      :style="contextMenuStyle"
      @click="contextMenuVisible = false"
    >
      <div class="menu-item" @click="refreshCurrent">刷新当前标签</div>
      <div class="menu-item" @click="closeOthers">关闭其他标签</div>
      <div class="menu-item" @click="closeAll">关闭所有标签</div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch, nextTick, onMounted, onUnmounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'

const props = defineProps({
  // 固定标签（不可关闭）
  fixedTabs: {
    type: Array,
    default: () => [{ path: '/', title: '首页' }]
  },
  // 缓存标签数量
  cacheSize: {
    type: Number,
    default: 10
  }
})

const route = useRoute()
const router = useRouter()

// 标签列表
const tabs = ref([...props.fixedTabs])

// 右键菜单
const contextMenuVisible = ref(false)
const contextMenuStyle = ref({
  top: '0px',
  left: '0px'
})

// DOM引用
const tabsWrapper = ref(null)
const tabsScroll = ref(null)

// 检查标签是否激活
const isActive = (tab) => {
  return tab.path === route.fullPath
}

// 切换标签
const switchTab = (tab) => {
  router.push(tab.path)
}

// 关闭标签
const closeTab = (tab) => {
  // 查找标签索引
  const index = tabs.value.findIndex(item => item.path === tab.path)
  
  if (index === -1) return
  
  // 如果关闭的是当前标签，需要跳转到其他标签
  if (isActive(tab)) {
    // 优先跳转到右侧标签，如果没有则跳转到左侧标签
    const nextTab = tabs.value[index + 1] || tabs.value[index - 1]
    
    if (nextTab) {
      router.push(nextTab.path)
    }
  }
  
  // 移除标签
  tabs.value.splice(index, 1)
}

// 刷新当前标签
const refreshCurrent = () => {
  const { fullPath } = route
  
  // 先跳转到一个空白路由，然后再跳回来
  router.replace('/redirect')
    .then(() => {
      nextTick(() => {
        router.replace(fullPath)
      })
    })
}

// 关闭其他标签
const closeOthers = () => {
  // 保留固定标签和当前标签
  tabs.value = [
    ...props.fixedTabs,
    ...tabs.value.filter(tab => 
      !props.fixedTabs.some(fixed => fixed.path === tab.path) && 
      tab.path === route.fullPath
    )
  ]
}

// 关闭所有标签
const closeAll = () => {
  // 只保留固定标签
  tabs.value = [...props.fixedTabs]
  
  // 跳转到第一个固定标签
  if (props.fixedTabs.length > 0) {
    router.push(props.fixedTabs[0].path)
  }
}

// 显示右键菜单
const showContextMenu = (event) => {
  event.preventDefault()
  
  // 设置菜单位置
  contextMenuStyle.value = {
    top: `${event.clientY}px`,
    left: `${event.clientX}px`
  }
  
  // 显示菜单
  contextMenuVisible.value = true
  
  // 添加点击外部关闭菜单的事件
  document.addEventListener('click', closeContextMenu)
}

// 关闭右键菜单
const closeContextMenu = () => {
  contextMenuVisible.value = false
  document.removeEventListener('click', closeContextMenu)
}

// 滚动到当前标签
const scrollToActiveTab = () => {
  nextTick(() => {
    if (!tabsWrapper.value || !tabsScroll.value) return
    
    // 查找当前激活的标签
    const activeTab = tabsScroll.value.querySelector('.tab.active')
    
    if (!activeTab) return
    
    // 计算滚动位置
    const wrapperWidth = tabsWrapper.value.offsetWidth
    const activeTabLeft = activeTab.offsetLeft
    const activeTabWidth = activeTab.offsetWidth
    
    // 如果标签不在可视区域内，滚动到可见位置
    if (activeTabLeft < tabsWrapper.value.scrollLeft || 
        activeTabLeft + activeTabWidth > tabsWrapper.value.scrollLeft + wrapperWidth) {
      // 居中显示
      tabsWrapper.value.scrollLeft = activeTabLeft - (wrapperWidth - activeTabWidth) / 2
    }
  })
}

// 监听路由变化，更新标签
watch(
  () => route.fullPath,
  (newPath) => {
    // 检查标签是否已存在
    const existingTab = tabs.value.find(tab => tab.path === newPath)
    
    if (!existingTab) {
      // 创建新标签
      const newTab = {
        path: newPath,
        title: route.meta.title || route.name || '未命名页面',
        closable: !props.fixedTabs.some(tab => tab.path === newPath)
      }
      
      // 添加新标签
      tabs.value.push(newTab)
      
      // 如果标签数量超过缓存大小，移除最早的非固定标签
      if (tabs.value.length > props.cacheSize) {
        // 查找第一个可关闭的标签
        const firstClosableIndex = tabs.value.findIndex(tab => tab.closable)
        
        if (firstClosableIndex !== -1) {
          tabs.value.splice(firstClosableIndex, 1)
        }
      }
    }
    
    // 滚动到当前标签
    scrollToActiveTab()
  },
  { immediate: true }
)

// 监听窗口大小变化，调整滚动位置
const handleResize = () => {
  scrollToActiveTab()
}

onMounted(() => {
  window.addEventListener('resize', handleResize)
})

onUnmounted(() => {
  window.removeEventListener('resize', handleResize)
  document.removeEventListener('click', closeContextMenu)
})
</script>

<style>
.tabs-nav {
  display: flex;
  height: 40px;
  background-color: #f0f2f5;
  border-bottom: 1px solid #d9d9d9;
  position: relative;
}

.tabs-wrapper {
  flex: 1;
  overflow-x: auto;
  overflow-y: hidden;
  white-space: nowrap;
  scrollbar-width: none; /* Firefox */
}

.tabs-wrapper::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Edge */
}

.tabs-scroll {
  display: inline-flex;
  height: 100%;
}

.tab {
  display: inline-flex;
  align-items: center;
  padding: 0 16px;
  height: 100%;
  cursor: pointer;
  transition: all 0.3s;
  border-right: 1px solid #d9d9d9;
}

.tab:hover {
  background-color: #e6f7ff;
}

.tab.active {
  background-color: #fff;
  border-bottom: 2px solid #1890ff;
}

.tab-title {
  margin-right: 8px;
}

.tab-close {
  width: 16px;
  height: 16px;
  line-height: 16px;
  text-align: center;
  border-radius: 50%;
  border: none;
  background: transparent;
  font-size: 12px;
  cursor: pointer;
}

.tab-close:hover {
  background-color: #c0c4cc;
  color: #fff;
}

.tabs-actions {
  display: flex;
  align-items: center;
  padding: 0 8px;
}

.tabs-action {
  width: 32px;
  height: 32px;
  border: none;
  background: transparent;
  cursor: pointer;
  border-radius: 4px;
}

.tabs-action:hover {
  background-color: #e6f7ff;
}

.context-menu {
  position: fixed;
  background-color: #fff;
  border: 1px solid #d9d9d9;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
  z-index: 1000;
}

.menu-item {
  padding: 8px 16px;
  cursor: pointer;
}

.menu-item:hover {
  background-color: #e6f7ff;
}
</style>
```

#### 标签页导航与缓存

结合Vue的`<keep-alive>`组件，实现标签页切换时保持组件状态：

```vue
<!-- src/components/TabsNavWithCache.vue -->
<template>
  <div class="app-container">
    <!-- 标签页导航 -->
    <TabsNav :fixedTabs="fixedTabs" :cacheSize="cacheSize" />
    
    <!-- 内容区域 -->
    <div class="content">
      <router-view v-slot="{ Component }">
        <keep-alive :include="cachedComponents">
          <component :is="Component" />
        </keep-alive>
      </router-view>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch } from 'vue'
import { useRoute } from 'vue-router'
import TabsNav from '@/components/TabsNav.vue'

const props = defineProps({
  // 固定标签
  fixedTabs: {
    type: Array,
    default: () => [{ path: '/', title: '首页' }]
  },
  // 缓存标签数量
  cacheSize: {
    type: Number,
    default: 10
  }
})

const route = useRoute()

// 缓存的组件名称列表
const cachedComponents = ref([])

// 监听路由变化，更新缓存组件
watch(
  () => route.matched,
  (matched) => {
    // 获取当前路由对应的组件名称
    const componentName = matched[matched.length - 1]?.components?.default?.name
    
    if (componentName && !cachedComponents.value.includes(componentName)) {
      // 添加到缓存列表
      cachedComponents.value.push(componentName)
      
      // 如果缓存数量超过限制，移除最早的组件
      if (cachedComponents.value.length > props.cacheSize) {
        cachedComponents.value.shift()
      }
    }
  },
  { immediate: true }
)
</script>

<style>
.app-container {
  display: flex;
  flex-direction: column;
  height: 100vh;
}

.content {
  flex: 1;
  overflow: auto;
  padding: 16px;
}
</style>
```

#### 持久化标签页

使用localStorage保存标签页状态，实现刷新页面后恢复标签页：

```vue
<!-- src/components/PersistentTabsNav.vue -->
<template>
  <div class="app-container">
    <!-- 标签页导航 -->
    <TabsNav 
      :fixedTabs="fixedTabs" 
      :cacheSize="cacheSize"
      :tabs="tabs"
      @update:tabs="updateTabs"
    />
    
    <!-- 内容区域 -->
    <div class="content">
      <router-view v-slot="{ Component }">
        <keep-alive :include="cachedComponents">
          <component :is="Component" />
        </keep-alive>
      </router-view>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch, onMounted } from 'vue'
import { useRoute, useRouter } from 'vue-router'
import TabsNav from '@/components/TabsNav.vue'

const props = defineProps({
  // 固定标签
  fixedTabs: {
    type: Array,
    default: () => [{ path: '/', title: '首页' }]
  },
  // 缓存标签数量
  cacheSize: {
    type: Number,
    default: 10
  },
  // 本地存储键名
  storageKey: {
    type: String,
    default: 'tabs-nav-state'
  }
})

const route = useRoute()
const router = useRouter()

// 标签列表
const tabs = ref([...props.fixedTabs])

// 缓存的组件名称列表
const cachedComponents = ref([])

// 更新标签列表
const updateTabs = (newTabs) => {
  tabs.value = newTabs
  saveTabs()
}

// 保存标签到本地存储
const saveTabs = () => {
  // 过滤掉固定标签，只保存动态标签
  const dynamicTabs = tabs.value.filter(tab => 
    !props.fixedTabs.some(fixed => fixed.path === tab.path)
  )
  
  localStorage.setItem(props.storageKey, JSON.stringify(dynamicTabs))
}

// 从本地存储加载标签
const loadTabs = () => {
  try {
    const savedTabs = localStorage.getItem(props.storageKey)
    
    if (savedTabs) {
      const dynamicTabs = JSON.parse(savedTabs)
      
      // 合并固定标签和动态标签
      tabs.value = [
        ...props.fixedTabs,
        ...dynamicTabs
      ]
    }
  } catch (error) {
    console.error('Failed to load tabs from localStorage:', error)
  }
}

// 监听路由变化，更新缓存组件
watch(
  () => route.matched,
  (matched) => {
    // 获取当前路由对应的组件名称
    const componentName = matched[matched.length - 1]?.components?.default?.name
    
    if (componentName && !cachedComponents.value.includes(componentName)) {
      // 添加到缓存列表
      cachedComponents.value.push(componentName)
      
      // 如果缓存数量超过限制，移除最早的组件
      if (cachedComponents.value.length > props.cacheSize) {
        cachedComponents.value.shift()
      }
    }
  },
  { immediate: true }
)

// 监听标签变化，保存到本地存储
watch(
  () => [...tabs.value],
  () => {
    saveTabs()
  },
  { deep: true }
)

// 组件挂载时加载标签
onMounted(() => {
  loadTabs()
  
  // 如果当前路由不在标签列表中，添加它
  const currentPath = route.fullPath
  const existingTab = tabs.value.find(tab => tab.path === currentPath)
  
  if (!existingTab) {
    tabs.value.push({
      path: currentPath,
      title: route.meta.title || route.name || '未命名页面',
      closable: !props.fixedTabs.some(tab => tab.path === currentPath)
    })
  }
})
</script>
```

## 总结

Vue Router 4为Vue 3应用提供了强大而灵活的路由管理能力，结合Vue 3的组合式API，可以更加直观地处理路由相关逻辑。通过路由元信息、导航守卫和动态路由等功能，可以实现复杂的导航控制和权限管理。

路由增强工具如路由元信息管理、动态路由和路由过渡动画，进一步提升了用户体验和开发效率。面包屑导航、菜单组件和标签页导航等导航组件，则为用户提供了直观、高效的应用导航体验。

在实际应用中，可以根据项目需求选择合适的导航模式和组件，或者基于本章介绍的基础组件进行定制开发，构建符合特定业务需求的导航系统。通过合理的路由设计和导航组件，可以显著提升应用的可用性和用户体验。
---
title: 网络请求工具
icon: cloud
order: 3
---

# 网络请求工具

在现代前端开发中，网络请求是连接前端应用与后端服务的关键桥梁。Vue应用需要高效、可靠的网络请求工具来处理数据获取、提交和同步等操作。本章将详细介绍几种主流的网络请求解决方案，包括Axios、Fetch API以及GraphQL客户端，并探讨它们在Vue应用中的最佳实践。

## Axios与Vue集成

Axios是一个基于Promise的HTTP客户端，可以用于浏览器和Node.js环境。它提供了丰富的功能，如拦截请求和响应、转换请求和响应数据、自动转换JSON数据、客户端防御XSRF等。在Vue项目中，Axios是最常用的网络请求库之一。

### 基础配置与使用

首先，安装Axios：

```bash
npm install axios
```

#### 创建Axios实例

在Vue项目中，通常会创建一个Axios实例，并进行基础配置：

```javascript
// src/utils/request.js
import axios from 'axios'

// 创建Axios实例
const request = axios.create({
  // API的基础URL，可以从环境变量中获取
  baseURL: import.meta.env.VITE_API_BASE_URL || '/api',
  // 请求超时时间
  timeout: 15000,
  // 请求头设置
  headers: {
    'Content-Type': 'application/json'
  }
})

export default request
```

#### 在Vue组件中使用

在Vue组件中使用Axios发起请求：

```vue
<script setup>
import { ref, onMounted } from 'vue'
import request from '@/utils/request'

const users = ref([])
const loading = ref(false)
const error = ref(null)

// 获取用户列表
const fetchUsers = async () => {
  loading.value = true
  error.value = null
  
  try {
    const response = await request.get('/users')
    users.value = response.data
  } catch (err) {
    error.value = err.message || '获取用户列表失败'
    console.error('获取用户列表失败:', err)
  } finally {
    loading.value = false
  }
}

// 创建新用户
const createUser = async (userData) => {
  try {
    const response = await request.post('/users', userData)
    // 添加到用户列表
    users.value.push(response.data)
    return response.data
  } catch (err) {
    error.value = err.message || '创建用户失败'
    console.error('创建用户失败:', err)
    throw err
  }
}

onMounted(() => {
  fetchUsers()
})
</script>

<template>
  <div>
    <div v-if="loading">加载中...</div>
    <div v-else-if="error" class="error">{{ error }}</div>
    <ul v-else>
      <li v-for="user in users" :key="user.id">
        {{ user.name }} ({{ user.email }})
      </li>
    </ul>
  </div>
</template>
```

### 请求拦截器配置

请求拦截器允许在请求发送前对其进行修改，例如添加认证令牌、修改请求头或参数等。

```javascript
// src/utils/request.js
import axios from 'axios'
import { useAuthStore } from '@/stores/auth'

const request = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || '/api',
  timeout: 15000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// 请求拦截器
request.interceptors.request.use(
  config => {
    // 获取认证状态
    const authStore = useAuthStore()
    
    // 如果有token，添加到请求头
    if (authStore.token) {
      config.headers.Authorization = `Bearer ${authStore.token}`
    }
    
    // 添加时间戳防止缓存（仅GET请求）
    if (config.method === 'get') {
      config.params = {
        ...config.params,
        _t: Date.now()
      }
    }
    
    // 日志记录
    console.log(`[API Request] ${config.method.toUpperCase()} ${config.url}`, config)
    
    return config
  },
  error => {
    // 请求错误处理
    console.error('[API Request Error]', error)
    return Promise.reject(error)
  }
)
```

#### 高级请求拦截器

在复杂应用中，可能需要更高级的请求拦截功能，如请求重试、请求队列或请求取消：

```javascript
// src/utils/request.js
import axios from 'axios'
import { useAuthStore } from '@/stores/auth'
import { useLoadingStore } from '@/stores/loading'

// 创建Axios实例
const request = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL || '/api',
  timeout: 15000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// 存储取消令牌的Map
const pendingRequests = new Map()

// 生成请求的唯一键
const generateRequestKey = config => {
  const { url, method, params, data } = config
  return [url, method, JSON.stringify(params), JSON.stringify(data)].join('&')
}

// 添加请求拦截器
request.interceptors.request.use(
  config => {
    // 获取认证状态和加载状态
    const authStore = useAuthStore()
    const loadingStore = useLoadingStore()
    
    // 如果有token，添加到请求头
    if (authStore.token) {
      config.headers.Authorization = `Bearer ${authStore.token}`
    }
    
    // 创建取消令牌
    const controller = new AbortController()
    config.signal = controller.signal
    
    // 生成请求键
    const requestKey = generateRequestKey(config)
    
    // 如果存在相同的请求，取消之前的请求
    if (config.cancelDuplicate && pendingRequests.has(requestKey)) {
      const previousController = pendingRequests.get(requestKey)
      previousController.abort()
      console.log(`[API] 取消重复请求: ${config.url}`)
    }
    
    // 存储当前请求的取消控制器
    pendingRequests.set(requestKey, controller)
    
    // 如果配置了自动显示加载状态
    if (config.showLoading !== false) {
      loadingStore.addLoading(config.loadingKey || 'global')
    }
    
    // 添加请求时间戳
    config._requestTime = Date.now()
    
    return config
  },
  error => {
    return Promise.reject(error)
  }
)
```

### 响应处理最佳实践

响应拦截器允许在接收到响应后对其进行处理，例如统一处理响应格式、提取数据、处理错误等。

```javascript
// src/utils/request.js
// ... 前面的代码

// 响应拦截器
request.interceptors.response.use(
  response => {
    // 获取加载状态
    const loadingStore = useLoadingStore()
    
    // 请求完成，移除取消令牌
    const requestKey = generateRequestKey(response.config)
    pendingRequests.delete(requestKey)
    
    // 隐藏加载状态
    if (response.config.showLoading !== false) {
      loadingStore.removeLoading(response.config.loadingKey || 'global')
    }
    
    // 计算请求耗时
    const requestTime = Date.now() - response.config._requestTime
    console.log(`[API Response] ${response.config.method.toUpperCase()} ${response.config.url} (${requestTime}ms)`, response.data)
    
    // 处理自定义响应格式
    // 假设后端返回格式为 { code: 0, data: {}, message: '' }
    const res = response.data
    
    if (res.code !== undefined) {
      // 如果后端定义了业务状态码
      if (res.code === 0) {
        // 业务成功，返回数据
        return res.data
      } else {
        // 业务失败，抛出错误
        const error = new Error(res.message || '请求失败')
        error.code = res.code
        error.data = res.data
        error.response = response
        
        // 显示错误消息
        if (response.config.showError !== false) {
          // 使用UI库的消息提示
          // 例如：ElMessage.error(res.message || '请求失败')
        }
        
        return Promise.reject(error)
      }
    }
    
    // 如果后端没有定义业务状态码，直接返回数据
    return response.data
  },
  error => {
    // 获取加载状态
    const loadingStore = useLoadingStore()
    
    // 如果请求已被取消，不做处理
    if (axios.isCancel(error)) {
      console.log('[API] 请求已取消:', error.message)
      return Promise.reject(error)
    }
    
    // 请求配置
    const config = error.config
    
    // 隐藏加载状态
    if (config && config.showLoading !== false) {
      loadingStore.removeLoading(config.loadingKey || 'global')
    }
    
    // 从pendingRequests中移除
    if (config) {
      const requestKey = generateRequestKey(config)
      pendingRequests.delete(requestKey)
    }
    
    // 处理错误
    console.error('[API Response Error]', error)
    
    // 显示错误消息
    if (config && config.showError !== false) {
      // 使用UI库的消息提示
      // 例如：ElMessage.error(error.message || '网络请求失败')
    }
    
    return Promise.reject(error)
  }
)
```

#### 响应数据转换

有时需要对响应数据进行转换，例如日期格式化、数据结构调整等：

```javascript
// src/utils/request.js
// ... 前面的代码

// 添加响应转换器
request.defaults.transformResponse = [
  ...axios.defaults.transformResponse,
  data => {
    // 如果不是对象，直接返回
    if (!data || typeof data !== 'object') return data
    
    // 递归处理对象中的日期字符串
    const transformDate = (obj) => {
      if (!obj || typeof obj !== 'object') return obj
      
      for (const key in obj) {
        const value = obj[key]
        
        // 检查是否是日期字符串（ISO 8601格式）
        if (typeof value === 'string' && /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/.test(value)) {
          obj[key] = new Date(value)
        } else if (typeof value === 'object') {
          // 递归处理嵌套对象
          transformDate(value)
        }
      }
      
      return obj
    }
    
    return transformDate(data)
  }
]
```

### 错误处理策略

有效的错误处理对于提升用户体验至关重要。以下是一些常见的错误处理策略：

#### 全局错误处理

```javascript
// src/utils/request.js
// ... 前面的代码

// 错误处理函数
const handleError = (error) => {
  const authStore = useAuthStore()
  const router = useRouter()
  
  // 获取错误信息
  let message = error.message || '请求失败'
  
  // 根据HTTP状态码处理错误
  if (error.response) {
    const status = error.response.status
    
    switch (status) {
      case 400:
        message = '请求错误'
        break
      case 401:
        message = '未授权，请登录'
        // 清除token并跳转到登录页
        authStore.logout()
        router.push('/login')
        break
      case 403:
        message = '拒绝访问'
        break
      case 404:
        message = '请求地址不存在'
        break
      case 408:
        message = '请求超时'
        break
      case 500:
        message = '服务器内部错误'
        break
      case 501:
        message = '服务未实现'
        break
      case 502:
        message = '网关错误'
        break
      case 503:
        message = '服务不可用'
        break
      case 504:
        message = '网关超时'
        break
      default:
        message = `未知错误(${status})`
    }
    
    // 尝试从响应中获取更详细的错误信息
    if (error.response.data && error.response.data.message) {
      message = error.response.data.message
    }
  } else if (error.request) {
    // 请求已发送但未收到响应
    message = '网络异常，服务器未响应'
  }
  
  // 设置错误信息
  error.displayMessage = message
  
  return error
}

// 在响应拦截器中使用
request.interceptors.response.use(
  response => {
    // ... 成功处理代码
  },
  error => {
    // 处理错误
    error = handleError(error)
    
    // 显示错误消息
    if (error.config && error.config.showError !== false) {
      // 使用UI库的消息提示
      // 例如：ElMessage.error(error.displayMessage)
    }
    
    return Promise.reject(error)
  }
)
```

#### 请求重试机制

对于因网络问题导致的请求失败，可以实现自动重试机制：

```javascript
// src/utils/request.js
// ... 前面的代码

// 请求重试拦截器
request.interceptors.response.use(
  response => response,
  async error => {
    // 获取原始请求配置
    const config = error.config
    
    // 如果没有配置或已经重试过，直接拒绝
    if (!config || !config.retry) return Promise.reject(error)
    
    // 设置重试计数器
    config.__retryCount = config.__retryCount || 0
    
    // 检查是否已超过最大重试次数
    if (config.__retryCount >= config.retry) {
      return Promise.reject(error)
    }
    
    // 增加重试计数
    config.__retryCount += 1
    
    console.log(`[API] 重试请求 (${config.__retryCount}/${config.retry}): ${config.url}`)
    
    // 创建延迟Promise
    const delay = ms => new Promise(resolve => setTimeout(resolve, ms))
    
    // 等待一段时间后重试
    // 可以使用指数退避策略增加重试间隔
    const retryDelay = config.retryDelay || 1000
    const exponentialDelay = retryDelay * Math.pow(2, config.__retryCount - 1)
    
    await delay(exponentialDelay)
    
    // 重新发送请求
    return request(config)
  }
)

// 使用重试机制的请求示例
const fetchWithRetry = () => {
  return request.get('/users', {
    retry: 3,        // 最大重试次数
    retryDelay: 1000 // 初始重试延迟（毫秒）
  })
}
```

#### 请求取消

Axios支持使用AbortController取消请求，这在用户快速切换页面或组件卸载时特别有用：

```javascript
// 在组件中使用
<script setup>
import { ref, onMounted, onUnmounted } from 'vue'
import request from '@/utils/request'

const data = ref(null)
const loading = ref(false)
const error = ref(null)

// 创建AbortController
const controller = new AbortController()

const fetchData = async () => {
  loading.value = true
  error.value = null
  
  try {
    const response = await request.get('/api/data', {
      signal: controller.signal // 传递取消信号
    })
    data.value = response
  } catch (err) {
    if (axios.isCancel(err)) {
      console.log('请求已取消')
    } else {
      error.value = err.message
      console.error('获取数据失败:', err)
    }
  } finally {
    loading.value = false
  }
}

onMounted(() => {
  fetchData()
})

onUnmounted(() => {
  // 组件卸载时取消请求
  controller.abort()
})
</script>
```

### 封装API服务

为了更好地组织API调用，通常会将相关的API请求封装到服务模块中：

```javascript
// src/api/user.js
import request from '@/utils/request'

export const userApi = {
  /**
   * 获取用户列表
   * @param {Object} params - 查询参数
   * @returns {Promise<Array>} 用户列表
   */
  getUsers(params) {
    return request.get('/users', { params })
  },
  
  /**
   * 获取用户详情
   * @param {string|number} id - 用户ID
   * @returns {Promise<Object>} 用户详情
   */
  getUserById(id) {
    return request.get(`/users/${id}`)
  },
  
  /**
   * 创建用户
   * @param {Object} data - 用户数据
   * @returns {Promise<Object>} 创建的用户
   */
  createUser(data) {
    return request.post('/users', data)
  },
  
  /**
   * 更新用户
   * @param {string|number} id - 用户ID
   * @param {Object} data - 更新的用户数据
   * @returns {Promise<Object>} 更新后的用户
   */
  updateUser(id, data) {
    return request.put(`/users/${id}`, data)
  },
  
  /**
   * 删除用户
   * @param {string|number} id - 用户ID
   * @returns {Promise<void>}
   */
  deleteUser(id) {
    return request.delete(`/users/${id}`)
  }
}
```

在组件中使用API服务：

```vue
<script setup>
import { ref, onMounted } from 'vue'
import { userApi } from '@/api/user'

const users = ref([])
const loading = ref(false)
const error = ref(null)

const fetchUsers = async () => {
  loading.value = true
  error.value = null
  
  try {
    users.value = await userApi.getUsers()
  } catch (err) {
    error.value = err.displayMessage || '获取用户列表失败'
  } finally {
    loading.value = false
  }
}

onMounted(() => {
  fetchUsers()
})
</script>
```

## Fetch API封装

Fetch API是现代浏览器提供的原生网络请求接口，相比XMLHttpRequest更简洁、更强大。然而，原生Fetch API相对简单，缺少一些Axios提供的高级功能，如拦截器、自动转换JSON等。因此，通常需要对Fetch API进行封装，以提供更便捷的使用体验。

### 基于Fetch的请求库

下面是一个基于Fetch API的简单请求库封装：

```javascript
// src/utils/fetchRequest.js
import { useAuthStore } from '@/stores/auth'

/**
 * 基于Fetch API的请求库
 */
class FetchRequest {
  constructor(baseURL = '') {
    this.baseURL = baseURL
    this.defaultConfig = {
      headers: {
        'Content-Type': 'application/json'
      },
      credentials: 'same-origin', // 包含cookies
      timeout: 15000, // 超时时间
      showError: true, // 是否显示错误
      showLoading: true // 是否显示加载状态
    }
  }
  
  /**
   * 发送请求
   * @param {string} url - 请求URL
   * @param {Object} options - 请求选项
   * @returns {Promise} 响应Promise
   */
  async request(url, options = {}) {
    // 合并配置
    const config = {
      ...this.defaultConfig,
      ...options,
      headers: {
        ...this.defaultConfig.headers,
        ...options.headers
      }
    }
    
    // 构建完整URL
    const fullUrl = this._buildUrl(url, config.params)
    
    // 处理请求体
    if (config.body && typeof config.body === 'object') {
      config.body = JSON.stringify(config.body)
    }
    
    // 添加认证头
    this._addAuthHeader(config)
    
    // 显示加载状态
    if (config.showLoading) {
      this._showLoading(config.loadingKey)
    }
    
    // 创建AbortController用于超时控制
    const controller = new AbortController()
    config.signal = controller.signal
    
    // 设置超时
    const timeoutId = setTimeout(() => {
      controller.abort()
    }, config.timeout)
    
    try {
      // 发送请求
      const response = await fetch(fullUrl, config)
      
      // 清除超时
      clearTimeout(timeoutId)
      
      // 隐藏加载状态
      if (config.showLoading) {
        this._hideLoading(config.loadingKey)
      }
      
      // 处理响应
      return await this._handleResponse(response, config)
    } catch (error) {
      // 清除超时
      clearTimeout(timeoutId)
      
      // 隐藏加载状态
      if (config.showLoading) {
        this._hideLoading(config.loadingKey)
      }
      
      // 处理错误
      return this._handleError(error, config)
    }
  }
  
  /**
   * 构建URL（添加查询参数）
   * @private
   */
  _buildUrl(url, params) {
    // 构建完整URL
    const fullUrl = url.startsWith('http') ? url : `${this.baseURL}${url}`
    
    // 如果没有参数，直接返回
    if (!params) return fullUrl
    
    // 构建URL对象
    const urlObj = new URL(fullUrl)
    
    // 添加查询参数
    Object.entries(params).forEach(([key, value]) => {
      urlObj.searchParams.append(key, value)
    })
    
    return urlObj.toString()
  }
  
  /**
   * 添加认证头
   * @private
   */
  _addAuthHeader(config) {
    const authStore = useAuthStore()
    
    if (authStore.token) {
      config.headers.Authorization = `Bearer ${authStore.token}`
    }
  }
  
  /**
   * 显示加载状态
   * @private
   */
  _showLoading(key = 'global') {
    // 实现加载状态显示逻辑
    console.log(`[Fetch] 显示加载状态: ${key}`)
  }
  
  /**
   * 隐藏加载状态
   * @private
   */
  _hideLoading(key = 'global') {
    // 实现加载状态隐藏逻辑
    console.log(`[Fetch] 隐藏加载状态: ${key}`)
  }
  
  /**
   * 处理响应
   * @private
   */
  async _handleResponse(response, config) {
    // 检查HTTP状态
    if (!response.ok) {
      const error = new Error(`HTTP错误: ${response.status}`)
      error.status = response.status
      error.response = response
      
      // 尝试解析错误响应
      try {
        error.data = await response.json()
      } catch (e) {
        // 忽略解析错误
      }
      
      throw error
    }
    
    // 检查响应类型并解析
    const contentType = response.headers.get('content-type')
    
    if (contentType && contentType.includes('application/json')) {
      const data = await response.json()
      
      // 处理自定义响应格式
      if (data.code !== undefined) {
        if (data.code === 0) {
          return data.data
        } else {
          const error = new Error(data.message || '请求失败')
          error.code = data.code
          error.data = data.data
          
          if (config.showError) {
            // 显示错误消息
            console.error(`[Fetch] 业务错误: ${error.message}`)
          }
          
          throw error
        }
      }
      
      return data
    } else if (contentType && contentType.includes('text/')) {
      return response.text()
    } else {
      return response.blob()
    }
  }
  
  /**
   * 处理错误
   * @private
   */
  _handleError(error, config) {
    // 处理超时错误
    if (error.name === 'AbortError') {
      error.message = '请求超时'
    }
    
    // 显示错误消息
    if (config.showError) {
      console.error(`[Fetch] 请求错误: ${error.message}`)
    }
    
    throw error
  }
  
  /**
   * GET请求
   */
  get(url, options = {}) {
    return this.request(url, {
      method: 'GET',
      ...options
    })
  }
  
  /**
   * POST请求
   */
  post(url, data, options = {}) {
    return this.request(url, {
      method: 'POST',
      body: data,
      ...options
    })
  }
  
  /**
   * PUT请求
   */
  put(url, data, options = {}) {
    return this.request(url, {
      method: 'PUT',
      body: data,
      ...options
    })
  }
  
  /**
   * DELETE请求
   */
  delete(url, options = {}) {
    return this.request(url, {
      method: 'DELETE',
      ...options
    })
  }
  
  /**
   * PATCH请求
   */
  patch(url, data, options = {}) {
    return this.request(url, {
      method: 'PATCH',
      body: data,
      ...options
    })
  }
}

// 创建实例
const fetchRequest = new FetchRequest(import.meta.env.VITE_API_BASE_URL || '/api')

export default fetchRequest
```

### 与Axios的对比

Fetch API和Axios各有优缺点，下面是它们的详细对比：

| 特性 | Fetch API | Axios |
|------|-----------|-------|
| **浏览器支持** | 现代浏览器原生支持，旧浏览器需要polyfill | 所有浏览器都支持（基于XMLHttpRequest） |
| **请求取消** | 支持（使用AbortController） | 支持（使用CancelToken或AbortController） |
| **请求超时** | 需要手动实现 | 内置支持 |
| **自动转换JSON** | 需要手动调用response.json() | 自动转换 |
| **拦截器** | 需要手动实现 | 内置支持 |
| **下载进度** | 支持（使用Response.body） | 支持 |
| **上传进度** | 不支持 | 支持 |
| **CSRF保护** | 需要手动实现 | 内置支持 |
| **并发请求** | 使用Promise.all | 使用axios.all |
| **错误处理** | HTTP错误不会reject Promise | HTTP错误会reject Promise |
| **体积** | 浏览器原生API，无额外体积 | 约15KB（min+gzip） |
| **Node.js支持** | 需要使用node-fetch等库 | 原生支持 |

#### 何时选择Fetch API

- 当项目需要减少依赖和包体积时
- 当只需要基本的HTTP请求功能时
- 当目标浏览器都是现代浏览器时
- 当希望使用浏览器原生API时

#### 何时选择Axios

- 当需要更丰富的功能和更好的开箱即用体验时
- 当需要支持旧浏览器时
- 当需要在Node.js和浏览器中使用相同的API时
- 当项目已经使用了其他依赖，额外的15KB不是问题时

### 组合式API封装

使用Vue 3的组合式API，可以创建可复用的网络请求钩子，使网络请求逻辑更加模块化和可测试。

#### 基础请求钩子

```javascript
// src/composables/useRequest.js
import { ref, unref, isRef } from 
让我继续完成关于组合式API封装的内容：

#### 基础请求钩子

```javascript
// src/composables/useRequest.js
import { ref, unref, isRef } from 'vue'
import { useLoadingStore } from '@/stores/loading'

/**
 * 通用请求钩子
 * @param {Function} requestFn - 请求函数
 * @param {Object} options - 配置选项
 * @returns {Object} 请求状态和方法
 */
export function useRequest(requestFn, options = {}) {
  // 默认选项
  const defaultOptions = {
    immediate: false,      // 是否立即执行
    initialData: null,     // 初始数据
    resetOnExecute: true,  // 执行时是否重置数据
    onSuccess: null,       // 成功回调
    onError: null,         // 错误回调
    onFinally: null,       // 完成回调
    loadingKey: 'default', // 加载状态key
    formatResult: data => data, // 结果格式化函数
  }
  
  // 合并选项
  const mergedOptions = { ...defaultOptions, ...options }
  
  // 状态
  const data = ref(mergedOptions.initialData)
  const loading = ref(false)
  const error = ref(null)
  const loadingStore = useLoadingStore()
  
  // 执行请求
  const execute = async (...args) => {
    // 重置状态
    if (mergedOptions.resetOnExecute) {
      data.value = mergedOptions.initialData
      error.value = null
    }
    
    loading.value = true
    loadingStore.addLoading(mergedOptions.loadingKey)
    
    try {
      // 执行请求函数
      const rawResult = await requestFn(...args)
      
      // 格式化结果
      const formattedResult = mergedOptions.formatResult(rawResult)
      
      // 更新数据
      data.value = formattedResult
      
      // 调用成功回调
      if (mergedOptions.onSuccess) {
        mergedOptions.onSuccess(formattedResult, ...args)
      }
      
      return formattedResult
    } catch (err) {
      // 更新错误
      error.value = err
      
      // 调用错误回调
      if (mergedOptions.onError) {
        mergedOptions.onError(err, ...args)
      }
      
      throw err
    } finally {
      // 更新加载状态
      loading.value = false
      loadingStore.removeLoading(mergedOptions.loadingKey)
      
      // 调用完成回调
      if (mergedOptions.onFinally) {
        mergedOptions.onFinally(...args)
      }
    }
  }
  
  // 如果需要立即执行
  if (mergedOptions.immediate) {
    execute()
  }
  
  return {
    data,
    loading,
    error,
    execute,
    // 重置数据
    reset: () => {
      data.value = mergedOptions.initialData
      error.value = null
    }
  }
}
```

#### 特定请求类型的钩子

基于基础钩子，可以创建特定类型请求的钩子：

```javascript
// src/composables/useGet.js
import { useRequest } from './useRequest'
import request from '@/utils/request'

/**
 * GET请求钩子
 * @param {string|Ref<string>} url - 请求URL
 * @param {Object|Ref<Object>} params - 请求参数
 * @param {Object} options - 配置选项
 * @returns {Object} 请求状态和方法
 */
export function useGet(url, params = {}, options = {}) {
  // 创建请求函数
  const requestFn = async () => {
    // 解包可能的ref
    const resolvedUrl = unref(url)
    const resolvedParams = unref(params)
    
    return request.get(resolvedUrl, { params: resolvedParams })
  }
  
  return useRequest(requestFn, options)
}

// src/composables/usePost.js
import { useRequest } from './useRequest'
import request from '@/utils/request'

/**
 * POST请求钩子
 * @param {string|Ref<string>} url - 请求URL
 * @param {Object|Ref<Object>} data - 请求数据
 * @param {Object} options - 配置选项
 * @returns {Object} 请求状态和方法
 */
export function usePost(url, data = {}, options = {}) {
  // 创建请求函数
  const requestFn = async (payload) => {
    // 解包可能的ref
    const resolvedUrl = unref(url)
    const resolvedData = payload || unref(data)
    
    return request.post(resolvedUrl, resolvedData)
  }
  
  return useRequest(requestFn, options)
}
```

#### 分页请求钩子

处理分页数据是常见需求，可以创建专门的分页请求钩子：

```javascript
// src/composables/usePagination.js
import { ref, computed, watch } from 'vue'
import { useRequest } from './useRequest'

/**
 * 分页请求钩子
 * @param {Function} requestFn - 请求函数，接收(page, pageSize, ...args)参数
 * @param {Object} options - 配置选项
 * @returns {Object} 分页状态和方法
 */
export function usePagination(requestFn, options = {}) {
  // 默认选项
  const defaultOptions = {
    immediate: false,
    initialPage: 1,
    initialPageSize: 10,
    initialTotal: 0,
    initialData: [],
    formatResult: (res) => ({
      list: res.list || res.data || [],
      total: res.total || 0
    })
  }
  
  // 合并选项
  const mergedOptions = { ...defaultOptions, ...options }
  
  // 分页状态
  const currentPage = ref(mergedOptions.initialPage)
  const pageSize = ref(mergedOptions.initialPageSize)
  const total = ref(mergedOptions.initialTotal)
  
  // 创建请求函数
  const fetchData = async (...args) => {
    return requestFn(currentPage.value, pageSize.value, ...args)
  }
  
  // 使用基础请求钩子
  const { data, loading, error, execute } = useRequest(fetchData, {
    ...mergedOptions,
    formatResult: (res) => {
      const formatted = mergedOptions.formatResult(res)
      total.value = formatted.total
      return formatted.list
    }
  })
  
  // 计算属性
  const pageCount = computed(() => {
    return Math.ceil(total.value / pageSize.value)
  })
  
  // 是否有上一页
  const hasPrevious = computed(() => {
    return currentPage.value > 1
  })
  
  // 是否有下一页
  const hasNext = computed(() => {
    return currentPage.value < pageCount.value
  })
  
  // 切换页码
  const changePage = (page) => {
    if (page === currentPage.value) return
    
    currentPage.value = page
    return execute()
  }
  
  // 切换每页条数
  const changePageSize = (size) => {
    if (size === pageSize.value) return
    
    pageSize.value = size
    // 切换每页条数时，通常回到第一页
    currentPage.value = 1
    return execute()
  }
  
  // 刷新当前页
  const refresh = () => {
    return execute()
  }
  
  // 重置到第一页
  const reset = () => {
    currentPage.value = mergedOptions.initialPage
    pageSize.value = mergedOptions.initialPageSize
    return execute()
  }
  
  // 监听分页参数变化
  if (mergedOptions.immediate) {
    execute()
  }
  
  return {
    // 数据和状态
    data,
    loading,
    error,
    total,
    currentPage,
    pageSize,
    pageCount,
    hasPrevious,
    hasNext,
    
    // 方法
    execute,
    changePage,
    changePageSize,
    refresh,
    reset
  }
}
```

#### 在组件中使用

```vue
<script setup>
import { useGet } from '@/composables/useGet'
import { usePagination } from '@/composables/usePagination'
import { userApi } from '@/api/user'

// 基础GET请求
const { 
  data: user, 
  loading: userLoading, 
  error: userError,
  execute: fetchUser
} = useGet('/users/1', null, { immediate: true })

// 带参数的GET请求
const userId = ref(1)
const { 
  data: userDetail, 
  loading: detailLoading,
  execute: fetchUserDetail
} = useGet(
  () => `/users/${userId.value}`,
  null,
  { 
    immediate: true,
    onSuccess: (data) => {
      console.log('用户详情获取成功:', data)
    }
  }
)

// 当userId变化时重新获取数据
watch(userId, () => {
  fetchUserDetail()
})

// 使用API服务的分页请求
const { 
  data: userList,
  loading: listLoading,
  total,
  currentPage,
  pageSize,
  changePage,
  changePageSize
} = usePagination(
  (page, pageSize) => userApi.getUsers({ page, pageSize }),
  { 
    immediate: true,
    initialPageSize: 20
  }
)
</script>

<template>
  <div>
    <!-- 用户详情 -->
    <div v-if="detailLoading">加载用户详情中...</div>
    <div v-else-if="userDetail">
      <h2>{{ userDetail.name }}</h2>
      <p>{{ userDetail.email }}</p>
    </div>
    
    <!-- 用户列表 -->
    <div>
      <h3>用户列表 (总计: {{ total }})</h3>
      <div v-if="listLoading">加载用户列表中...</div>
      <ul v-else>
        <li v-for="user in userList" :key="user.id">
          {{ user.name }} - {{ user.email }}
        </li>
      </ul>
      
      <!-- 分页控件 -->
      <div class="pagination">
        <button 
          :disabled="currentPage <= 1" 
          @click="changePage(currentPage - 1)"
        >
          上一页
        </button>
        <span>{{ currentPage }} / {{ Math.ceil(total / pageSize) }}</span>
        <button 
          :disabled="currentPage >= Math.ceil(total / pageSize)" 
          @click="changePage(currentPage + 1)"
        >
          下一页
        </button>
        
        <select v-model="pageSize" @change="changePageSize(pageSize)">
          <option :value="10">10条/页</option>
          <option :value="20">20条/页</option>
          <option :value="50">50条/页</option>
        </select>
      </div>
    </div>
  </div>
</template>
```

## GraphQL客户端

GraphQL是一种用于API的查询语言，它允许客户端精确地指定所需的数据，避免了传统REST API中的过度获取和欠获取问题。在Vue应用中，有几种流行的GraphQL客户端可供选择。

### Apollo Client

Apollo Client是最流行的GraphQL客户端之一，它提供了丰富的功能和良好的Vue集成。

#### 安装与配置

首先，安装所需的依赖：

```bash
npm install @apollo/client graphql @vue/apollo-composable
```

然后，创建Apollo Client实例：

```javascript
// src/apollo/index.js
import { ApolloClient, InMemoryCache, createHttpLink, from } from '@apollo/client/core'
import { onError } from '@apollo/client/link/error'
import { setContext } from '@apollo/client/link/context'
import { useAuthStore } from '@/stores/auth'

// 创建HTTP链接
const httpLink = createHttpLink({
  uri: import.meta.env.VITE_GRAPHQL_URL || '/graphql'
})

// 错误处理链接
const errorLink = onError(({ graphQLErrors, networkError }) => {
  if (graphQLErrors) {
    graphQLErrors.forEach(({ message, locations, path }) => {
      console.error(
        `[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`
      )
    })
  }
  
  if (networkError) {
    console.error(`[Network error]: ${networkError}`)
  }
})

// 认证链接
const authLink = setContext((_, { headers }) => {
  // 获取认证状态
  const authStore = useAuthStore()
  
  // 返回带有认证头的上下文
  return {
    headers: {
      ...headers,
      authorization: authStore.token ? `Bearer ${authStore.token}` : ''
    }
  }
})

// 创建缓存
const cache = new InMemoryCache({
  typePolicies: {
    // 定义类型策略
    Query: {
      fields: {
        // 示例：合并分页数据
        users: {
          keyArgs: ['filter'], // 用于缓存键的参数
          merge(existing = { items: [] }, incoming) {
            return {
              ...incoming,
              items: [...existing.items, ...incoming.items]
            }
          }
        }
      }
    }
  }
})

// 创建Apollo客户端
export const apolloClient = new ApolloClient({
  link: from([errorLink, authLink, httpLink]),
  cache,
  defaultOptions: {
    watchQuery: {
      fetchPolicy: 'cache-and-network',
      errorPolicy: 'all'
    },
    query: {
      fetchPolicy: 'network-only',
      errorPolicy: 'all'
    },
    mutate: {
      errorPolicy: 'all'
    }
  }
})
```

在Vue应用中提供Apollo客户端：

```javascript
// src/main.js
import { createApp, provide, h } from 'vue'
import { DefaultApolloClient } from '@vue/apollo-composable'
import { apolloClient } from './apollo'
import App from './App.vue'

const app = createApp({
  setup() {
    provide(DefaultApolloClient, apolloClient)
    return () => h(App)
  }
})

app.mount('#app')
```

#### 基础查询与变更

使用Apollo Composable API进行查询和变更：

```vue
<script setup>
import { useQuery, useMutation } from '@vue/apollo-composable'
import { gql } from '@apollo/client/core'

// 定义查询
const GET_USERS = gql`
  query GetUsers($page: Int!, $pageSize: Int!) {
    users(page: $page, pageSize: $pageSize) {
      items {
        id
        name
        email
      }
      total
      page
      pageSize
    }
  }
`

// 定义变更
const CREATE_USER = gql`
  mutation CreateUser($input: CreateUserInput!) {
    createUser(input: $input) {
      id
      name
      email
    }
  }
`

// 查询参数
const variables = ref({
  page: 1,
  pageSize: 10
})

// 执行查询
const { result, loading, error, refetch } = useQuery(
  GET_USERS,
  variables,
  {
    // 查询选项
    fetchPolicy: 'cache-and-network',
    notifyOnNetworkStatusChange: true
  }
)

// 计算属性：用户列表
const users = computed(() => result.value?.users.items || [])
const total = computed(() => result.value?.users.total || 0)

// 执行变更
const { mutate: createUser, loading: creating } = useMutation(CREATE_USER)

// 创建用户方法
const handleCreateUser = async (userData) => {
  try {
    const { data } = await createUser({
      input: userData
    })
    
    console.log('用户创建成功:', data.createUser)
    
    // 刷新查询
    refetch()
    
    return data.createUser
  } catch (error) {
    console.error('创建用户失败:', error)
    throw error
  }
}

// 切换页码
const changePage = (page) => {
  variables.value.page = page
}
</script>

<template>
  <div>
    <h2>用户列表</h2>
    
    <!-- 加载状态 -->
    <div v-if="loading && !result">加载中...</div>
    
    <!-- 错误状态 -->
    <div v-else-if="error">
      加载失败: {{ error.message }}
      <button @click="refetch">重试</button>
    </div>
    
    <!-- 数据展示 -->
    <div v-else>
      <ul>
        <li v-for="user in users" :key="user.id">
          {{ user.name }} ({{ user.email }})
        </li>
      </ul>
      
      <!-- 分页控件 -->
      <div class="pagination">
        <button 
          :disabled="variables.page <= 1" 
          @click="changePage(variables.page - 1)"
        >
          上一页
        </button>
        <span>{{ variables.page }} / {{ Math.ceil(total / variables.pageSize) }}</span>
        <button 
          :disabled="variables.page >= Math.ceil(total / variables.pageSize)" 
          @click="changePage(variables.page + 1)"
        >
          下一页
        </button>
      </div>
    </div>
    
    <!-- 创建用户表单 -->
    <div>
      <h3>创建用户</h3>
      <form @submit.prevent="handleCreateUser(formData)">
        <!-- 表单内容 -->
      </form>
    </div>
  </div>
</template>
```

#### 缓存管理

Apollo Client的一个强大特性是其缓存系统，它可以自动合并和更新数据：

```javascript
// 更新缓存中的数据
const updateCache = (cache, { data }) => {
  // 读取缓存
  const existingUsers = cache.readQuery({
    query: GET_USERS,
    variables: { page: 1, pageSize: 10 }
  })
  
  // 更新缓存
  cache.writeQuery({
    query: GET_USERS,
    variables: { page: 1, pageSize: 10 },
    data: {
      users: {
        ...existingUsers.users,
        items: [data.createUser, ...existingUsers.users.items],
        total: existingUsers.users.total + 1
      }
    }
  })
}

// 在变更中使用
const { mutate: createUser } = useMutation(CREATE_USER, {
  update: updateCache
})
```

#### 订阅

GraphQL还支持实时订阅，Apollo Client可以通过WebSocket处理订阅：

```javascript
// 安装依赖
// npm install @apollo/client subscriptions-transport-ws

// 配置WebSocket链接
import { WebSocketLink } from '@apollo/client/link/ws'
import { split } from '@apollo/client/core'
import { getMainDefinition } from '@apollo/client/utilities'

// 创建WebSocket链接
const wsLink = new WebSocketLink({
  uri: import.meta.env.VITE_GRAPHQL_WS_URL || 'ws://localhost:4000/graphql',
  options: {
    reconnect: true,
    connectionParams: () => {
      const authStore = useAuthStore()
      return {
        authorization: authStore.token ? `Bearer ${authStore.token}` : ''
      }
    }
  }
})

// 根据操作类型分割链接
const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query)
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    )
  },
  wsLink,
  from([errorLink, authLink, httpLink])
)

// 更新Apollo客户端
export const apolloClient = new ApolloClient({
  link: splitLink,
  cache
})
```

在组件中使用订阅：

```vue
<script setup>
import { useSubscription } from '@vue/apollo-composable'
import { gql } from '@apollo/client/core'

// 定义订阅
const USER_CREATED = gql`
  subscription OnUserCreated {
    userCreated {
      id
      name
      email
    }
  }
`

// 执行订阅
const { result } = useSubscription(USER_CREATED)

// 监听新用户创建
watch(
  () => result.value?.userCreated,
  newUser => {
    if (newUser) {
      console.log('新用户创建:', newUser)
      // 更新本地状态或显示通知
    }
  }
)
</script>
```

### urql

urql是一个轻量级的GraphQL客户端，相比Apollo Client更简单，但仍提供了强大的功能。

#### 安装与配置

```bash
npm install @urql/vue graphql
```

创建urql客户端：

```javascript
// src/urql/index.js
import { createClient, dedupExchange, cacheExchange, fetchExchange, errorExchange } from '@urql/vue'
import { useAuthStore } from '@/stores/auth'

// 创建urql客户端
export const urqlClient = createClient({
  url: import.meta.env.VITE_GRAPHQL_URL || '/graphql',
  
  // 配置交换器
  exchanges: [
    dedupExchange,
    cacheExchange,
    errorExchange({
      onError: (error) => {
        const { graphQLErrors, networkError } = error
        
        if (graphQLErrors) {
          graphQLErrors.forEach(({ message, locations, path }) => {
            console.error(
              `[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`
            )
          })
        }
        
        if (networkError) {
          console.error(`[Network error]: ${networkError}`)
        }
      }
    }),
    fetchExchange
  ],
  
  // 请求配置
  fetchOptions: () => {
    const authStore = useAuthStore()
    
    return {
      headers: {
        authorization: authStore.token ? `Bearer ${authStore.token}` : ''
      }
    }
  }
})
```

在Vue应用中提供urql客户端：

```javascript
// src/main.js
import { createApp } from 'vue'
import { createClient, provideClient } from '@urql/vue'
import { urqlClient } from './urql'
import App from './App.vue'

const app = createApp(App)

// 提供urql客户端
app.use(urqlClient)

app.mount('#app')
```

#### 基础查询与变更

使用urql的组合式API进行查询和变更：

```vue
<script setup>
import { useQuery, useMutation } from '@urql/vue'
import { ref, computed } from 'vue'

// 定义查询
const GET_USERS = `
  query GetUsers($page: Int!, $pageSize: Int!) {
    users(page: $page, pageSize: $pageSize) {
      items {
        id
        name
        email
      }
      total
      page
      pageSize
    }
  }
`

// 定义变更
const CREATE_USER = `
  mutation CreateUser($input: CreateUserInput!) {
    createUser(input: $input) {
      id
      name
      email
    }
  }
`

// 查询参数
const variables = ref({
  page: 1,
  pageSize: 10
})

// 执行查询
const { data, fetching, error, executeQuery } = useQuery({
  query: GET_USERS,
  variables: variables
})

// 计算属性：用户列表
const users = computed(() => data.value?.users.items || [])
const total = computed(() => data.value?.users.total || 0)

// 执行变更
const { executeMutation } = useMutation(CREATE_USER)

// 创建用户方法
const handleCreateUser = async (userData) => {
  try {
    const result = await executeMutation({
      input: userData
    })
    
    if (result.error) {
      throw result.error
    }
    
    console.log('用户创建成功:', result.data.createUser)
    
    // 刷新查询
    executeQuery({ requestPolicy: 'network-only' })
    
    return result.data.createUser
  } catch (error) {
    console.error('创建用户失败:', error)
    throw error
  }
}

// 切换页码
const changePage = (page) => {
  variables.value.page = page
}
</script>

<template>
  <div>
    <h2>用户列表</h2>
    
    <!-- 加载状态 -->
    <div v-if="fetching && !data">加载中...</div>
    
    <!-- 错误状态 -->
    <div v-else-if="error">
      加载失败: {{ error.message }}
      <button @click="executeQuery({ requestPolicy: 'network-only' })">重试</button>
    </div>
    
    <!-- 数据展示 -->
    <div v-else>
      <ul>
        <li v-for="user in users" :key="user.id">
          {{ user.name }} ({{ user.email }})
        </li>
      </ul>
      
      <!-- 分页控件 -->
      <div class="pagination">
        <button 
          :disabled="variables.page <= 1" 
          @click="changePage(variables.page - 1)"
        >
          上一页
        </button>
        <span>{{ variables.page }} / {{ Math.ceil(total / variables.pageSize) }}</span>
        <button 
          :disabled="variables.page >= Math.ceil(total / variables.pageSize)" 
          @click="changePage(variables.page + 1)"
        >
          下一页
        </button>
      </div>
    </div>
  </div>
</template>
```

### 与REST API的集成

在许多项目中，需要同时使用GraphQL和REST API。以下是几种集成方式：

#### Apollo REST数据源

Apollo Client提供了REST数据源的支持，可以在GraphQL服务器中包装REST API：

```javascript
// 服务器端代码
const { RESTDataSource } = require('apollo-datasource-rest')

class UsersAPI extends RESTDataSource {
  constructor() {
    super()
    this.baseURL = 'https://api.example.com/'
  }
  
  async getUsers(page = 1, pageSize = 10) {
    return this.get(`users?page=${page}&pageSize=${pageSize}`)
  }
  
  async getUserById(id) {
    return this.get(`users/${id}`)
  }
  
  async createUser(userData) {
    return this.post('users', userData)
  }
}

// 在Apollo Server中使用
const server = new ApolloServer({
  typeDefs,
  resolvers,
  dataSources: () => ({
    usersAPI: new UsersAPI()
  })
})
```

#### 客户端混合使用

在客户端同时使用GraphQL和REST API：

```vue
<script setup>
import { useQuery } from '@vue/apollo-composable'
import { gql } from '@apollo/client/core'
import { ref, onMounted } from 'vue'
import request from '@/utils/request'

// GraphQL查询
const GET_PRODUCTS = gql`
  query GetProducts($page: Int!, $pageSize: Int!) {
    products(page: $page, pageSize: $pageSize) {
      items {
        id
        name
        price
      }
      total
    }
  }
`

// 查询参数
const variables = ref({
  page: 1,
  pageSize: 10
})

// 执行GraphQL查询
const { result: productsResult, loading: productsLoading } = useQuery(
  GET_PRODUCTS,
  variables
)

// 计算属性：产品列表
const products = computed(() => productsResult.value?.products.items || [])

// REST API数据
const users = ref([])
const usersLoading = ref(false)

// 获取用户列表（REST API）
const fetchUsers = async () => {
  usersLoading.value = true
  
  try {
    const response = await request.get('/users', {
      params: {
        page: variables.value.page,
        pageSize: variables.value.pageSize
      }
    })
    
    users.value = response.data
  } catch (error) {
    console.error('获取用户失败:', error)
  } finally {
    usersLoading.value = false
  }
}

// 组件挂载时获取用户数据
onMounted(() => {
  fetchUsers()
})

// 页码变化时同时更新GraphQL和REST数据
const changePage = (page) => {
  variables.value.page = page
  fetchUsers()
}
</script>
```

#### GraphQL代理层

创建一个GraphQL代理层，统一处理GraphQL和REST API：

```javascript
// 服务器端代码
const { ApolloServer, gql } = require('apollo-server')
const { RESTDataSource } = require('apollo-datasource-rest')

// 定义Schema
const typeDefs = gql`
  type User {
    id: ID!
    name: String!
    email: String!
  }
  
  type Product {
    id: ID!
    name: String!
    price: Float!
  }
  
  type Query {
    users(page: Int, pageSize: Int): [User]
    products(page: Int, pageSize:
让我继续完成关于GraphQL代理层的内容：

#### GraphQL代理层

创建一个GraphQL代理层，统一处理GraphQL和REST API：

```javascript
// 服务器端代码
const { ApolloServer, gql } = require('apollo-server')
const { RESTDataSource } = require('apollo-datasource-rest')

// 定义Schema
const typeDefs = gql`
  type User {
    id: ID!
    name: String!
    email: String!
  }
  
  type Product {
    id: ID!
    name: String!
    price: Float!
  }
  
  type Query {
    users(page: Int, pageSize: Int): [User]
    products(page: Int, pageSize: Int): [Product]
  }
`

// REST API数据源
class UsersAPI extends RESTDataSource {
  constructor() {
    super()
    this.baseURL = 'https://api.example.com/users/'
  }
  
  async getUsers(page = 1, pageSize = 10) {
    return this.get(`?page=${page}&pageSize=${pageSize}`)
  }
}

class ProductsAPI extends RESTDataSource {
  constructor() {
    super()
    this.baseURL = 'https://api.example.com/products/'
  }
  
  async getProducts(page = 1, pageSize = 10) {
    return this.get(`?page=${page}&pageSize=${pageSize}`)
  }
}

// 解析器
const resolvers = {
  Query: {
    users: async (_, { page, pageSize }, { dataSources }) => {
      return dataSources.usersAPI.getUsers(page, pageSize)
    },
    products: async (_, { page, pageSize }, { dataSources }) => {
      return dataSources.productsAPI.getProducts(page, pageSize)
    }
  }
}

// 创建Apollo服务器
const server = new ApolloServer({
  typeDefs,
  resolvers,
  dataSources: () => ({
    usersAPI: new UsersAPI(),
    productsAPI: new ProductsAPI()
  })
})

// 启动服务器
server.listen().then(({ url }) => {
  console.log(`🚀 GraphQL代理服务器运行在 ${url}`)
})
```

这种方式的优点是客户端只需要使用GraphQL API，而不需要关心底层数据来源是GraphQL还是REST API。

#### 使用GraphQL Code Generator

GraphQL Code Generator是一个工具，可以根据GraphQL Schema生成TypeScript类型和API客户端代码，简化GraphQL的使用：

```bash
npm install -D @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typescript-vue-apollo
```

创建配置文件`codegen.yml`：

```yaml
schema: http://localhost:4000/graphql
documents: './src/**/*.graphql'
generates:
  src/generated/graphql.ts:
    plugins:
      - typescript
      - typescript-operations
      - typescript-vue-apollo
    config:
      withCompositionFunctions: true
      vueCompositionApiImportFrom: vue
```

创建GraphQL查询文件：

```graphql
# src/graphql/users.graphql
query GetUsers($page: Int!, $pageSize: Int!) {
  users(page: $page, pageSize: $pageSize) {
    items {
      id
      name
      email
    }
    total
    page
    pageSize
  }
}

mutation CreateUser($input: CreateUserInput!) {
  createUser(input: $input) {
    id
    name
    email
  }
}
```

运行代码生成器：

```bash
npx graphql-codegen
```

在组件中使用生成的代码：

```vue
<script setup>
import { ref } from 'vue'
import { useGetUsersQuery, useCreateUserMutation } from '@/generated/graphql'

// 查询参数
const variables = ref({
  page: 1,
  pageSize: 10
})

// 使用生成的查询钩子
const { result, loading, error, refetch } = useGetUsersQuery(variables)

// 使用生成的变更钩子
const { mutate: createUser, loading: creating } = useCreateUserMutation()

// 创建用户方法
const handleCreateUser = async (userData) => {
  try {
    const { data } = await createUser({
      input: userData
    })
    
    console.log('用户创建成功:', data.createUser)
    
    // 刷新查询
    refetch()
    
    return data.createUser
  } catch (error) {
    console.error('创建用户失败:', error)
    throw error
  }
}
</script>
```

### 自定义GraphQL客户端

对于一些特殊需求，可能需要创建自定义的GraphQL客户端。以下是一个基于Fetch API的简单GraphQL客户端：

```javascript
// src/utils/graphqlClient.js
import { useAuthStore } from '@/stores/auth'

/**
 * 简单的GraphQL客户端
 */
class GraphQLClient {
  constructor(url) {
    this.url = url
  }
  
  /**
   * 执行GraphQL查询
   * @param {string} query - GraphQL查询字符串
   * @param {Object} variables - 查询变量
   * @param {Object} options - 请求选项
   * @returns {Promise} 响应Promise
   */
  async query(query, variables = {}, options = {}) {
    return this.request(query, variables, options)
  }
  
  /**
   * 执行GraphQL变更
   * @param {string} mutation - GraphQL变更字符串
   * @param {Object} variables - 变更变量
   * @param {Object} options - 请求选项
   * @returns {Promise} 响应Promise
   */
  async mutate(mutation, variables = {}, options = {}) {
    return this.request(mutation, variables, options)
  }
  
  /**
   * 发送GraphQL请求
   * @private
   */
  async request(query, variables = {}, options = {}) {
    const authStore = useAuthStore()
    
    // 构建请求体
    const body = JSON.stringify({
      query,
      variables
    })
    
    // 构建请求选项
    const fetchOptions = {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        ...options.headers
      },
      body
    }
    
    // 添加认证头
    if (authStore.token) {
      fetchOptions.headers.Authorization = `Bearer ${authStore.token}`
    }
    
    try {
      // 发送请求
      const response = await fetch(this.url, fetchOptions)
      
      // 解析响应
      const result = await response.json()
      
      // 检查GraphQL错误
      if (result.errors) {
        const error = new Error('GraphQL错误')
        error.graphQLErrors = result.errors
        throw error
      }
      
      return result.data
    } catch (error) {
      console.error('GraphQL请求失败:', error)
      throw error
    }
  }
}

// 创建客户端实例
const graphqlClient = new GraphQLClient(
  import.meta.env.VITE_GRAPHQL_URL || '/graphql'
)

export default graphqlClient
```

在组件中使用自定义客户端：

```vue
<script setup>
import { ref, computed } from 'vue'
import graphqlClient from '@/utils/graphqlClient'

// 查询参数
const variables = ref({
  page: 1,
  pageSize: 10
})

// 数据状态
const users = ref([])
const loading = ref(false)
const error = ref(null)

// 获取用户列表
const fetchUsers = async () => {
  loading.value = true
  error.value = null
  
  try {
    const query = `
      query GetUsers($page: Int!, $pageSize: Int!) {
        users(page: $page, pageSize: $pageSize) {
          items {
            id
            name
            email
          }
          total
          page
          pageSize
        }
      }
    `
    
    const data = await graphqlClient.query(query, variables.value)
    users.value = data.users.items
  } catch (err) {
    error.value = err.message || 'GraphQL查询失败'
    console.error('获取用户列表失败:', err)
  } finally {
    loading.value = false
  }
}

// 创建用户
const createUser = async (userData) => {
  try {
    const mutation = `
      mutation CreateUser($input: CreateUserInput!) {
        createUser(input: $input) {
          id
          name
          email
        }
      }
    `
    
    const data = await graphqlClient.mutate(mutation, { input: userData })
    
    // 添加到用户列表
    users.value.push(data.createUser)
    
    return data.createUser
  } catch (err) {
    console.error('创建用户失败:', err)
    throw err
  }
}

// 初始加载
fetchUsers()
</script>
```

## 总结

网络请求是前端应用的核心部分，选择合适的网络请求工具对于应用的性能和开发效率至关重要。

### Axios的优势

Axios是Vue项目中最常用的HTTP客户端，它提供了丰富的功能和良好的开发体验：
- 拦截器系统允许集中处理请求和响应
- 自动转换JSON数据
- 请求取消和超时控制
- 并发请求处理
- 错误处理和请求重试
- 广泛的浏览器支持

### Fetch API的优势

Fetch API是现代浏览器提供的原生API，它更轻量且符合现代JavaScript标准：
- 浏览器原生支持，无需额外依赖
- 基于Promise，与现代JavaScript异步模式一致
- 更简洁的API设计
- 支持流式响应
- 更好的CORS支持

### GraphQL的优势

GraphQL提供了一种更灵活的数据获取方式：
- 客户端可以精确指定所需数据，避免过度获取
- 单一请求获取多个资源，减少网络往返
- 强类型系统，提供更好的开发体验和工具支持
- 实时订阅功能
- 版本控制更简单

### 最佳实践建议

1. **选择合适的工具**：
   - 对于大多数Vue项目，Axios是一个安全的选择
   - 如果项目追求轻量化，可以考虑封装Fetch API
   - 如果后端提供GraphQL API，或者需要聚合多个API，考虑使用GraphQL客户端

2. **请求封装**：
   - 创建统一的请求实例，配置基础URL、超时等
   - 实现请求拦截器处理认证、参数转换等
   - 实现响应拦截器处理错误、数据转换等
   - 封装API服务层，隔离业务逻辑和数据获取

3. **错误处理**：
   - 实现全局错误处理机制
   - 区分网络错误和业务错误
   - 提供友好的错误提示
   - 实现请求重试机制

4. **状态管理**：
   - 使用加载状态指示器提升用户体验
   - 合理缓存请求结果
   - 考虑使用组合式API封装请求逻辑

5. **性能优化**：
   - 实现请求取消，避免不必要的请求
   - 使用防抖和节流控制请求频率
   - 合理设置缓存策略
   - 考虑使用预取和懒加载

无论选择哪种网络请求工具，关键是建立一套一致的模式和最佳实践，使团队能够高效地开发和维护应用。通过合理的封装和抽象，可以使网络请求代码更加清晰、可测试和可维护。
---
title: 状态管理工具
icon: database
order: 1
---

# 状态管理工具

在现代前端应用开发中，状态管理是一个核心问题。随着应用规模的增长，组件之间共享状态变得越来越复杂，如何有效地管理这些状态成为开发者面临的重要挑战。Vue3生态系统提供了多种状态管理解决方案，从官方推荐的Pinia到实用工具集VueUse，再到基于Vue3新特性的轻量级状态管理方案，为不同规模和需求的应用提供了灵活的选择。

## Pinia

Pinia是Vue官方推荐的状态管理库，它为Vue3应用提供了直观、类型安全且可扩展的状态管理解决方案。作为Vuex的精神继承者，Pinia保留了核心概念的同时，提供了更简洁的API和更好的TypeScript支持。

### Pinia的设计理念

Pinia的设计理念围绕以下几个核心原则：

#### 1. 简单性

Pinia摒弃了Vuex中的mutations概念，只保留state、getters和actions，使API更加精简直观。这种简化不仅减少了样板代码，还使状态管理的心智负担大大降低。

```javascript
// Vuex的写法
const store = createStore({
  state: {
    count: 0
  },
  mutations: {
    increment(state) {
      state.count++
    }
  },
  actions: {
    incrementAsync({ commit }) {
      setTimeout(() => {
        commit('increment')
      }, 1000)
    }
  }
})

// Pinia的写法
const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0
  }),
  actions: {
    increment() {
      this.count++
    },
    incrementAsync() {
      setTimeout(() => {
        this.increment()
      }, 1000)
    }
  }
})
```

#### 2. 类型安全

Pinia从设计之初就考虑了TypeScript支持，提供了完整的类型推断，无需额外的类型声明即可获得IDE的智能提示和类型检查。

```typescript
// 完全类型安全的store定义
const useUserStore = defineStore('user', {
  state: () => ({
    name: 'John Doe',
    age: 30,
    isAdmin: false
  }),
  getters: {
    // 返回类型会被自动推断
    nameWithTitle: (state) => `Mr. ${state.name}`,
    // 使用this访问其他getter时需要定义返回类型
    ageInMonths(): number {
      return this.age * 12
    }
  },
  actions: {
    updateName(newName: string) {
      this.name = newName
    }
  }
})

// 使用时享受完整的类型提示
const userStore = useUserStore()
userStore.name // 类型: string
userStore.updateName('Jane') // 参数类型检查
```

#### 3. 开发者体验

Pinia与Vue DevTools深度集成，提供了友好的调试体验，包括时间旅行、状态编辑和action追踪等功能。同时，Pinia的模块化设计使得代码分割和懒加载变得简单。

#### 4. 可扩展性

Pinia提供了插件系统，允许开发者扩展其功能，如添加持久化存储、日志记录或与服务器状态同步等。

```javascript
// Pinia插件示例：添加持久化功能
const piniaLocalStoragePlugin = ({ store }) => {
  // 从localStorage恢复状态
  const storedState = localStorage.getItem(`pinia-${store.$id}`)
  if (storedState) {
    store.$patch(JSON.parse(storedState))
  }
  
  // 监听状态变化并保存到localStorage
  store.$subscribe((mutation, state) => {
    localStorage.setItem(`pinia-${store.$id}`, JSON.stringify(state))
  })
}

// 使用插件
const pinia = createPinia()
pinia.use(piniaLocalStoragePlugin)
app.use(pinia)
```

### Store定义与使用

Pinia中的核心概念是"Store"，它是一个保存状态和业务逻辑的实体，可以被应用中的任何组件使用。

#### 定义Store

在Pinia中，可以使用`defineStore`函数定义一个store。有两种风格可供选择：选项式API和组合式API。

**选项式API风格**：

```javascript
import { defineStore } from 'pinia'

// 第一个参数是store的唯一ID
export const useCartStore = defineStore('cart', {
  // 状态定义为返回初始状态的函数
  state: () => ({
    items: [],
    loading: false,
    error: null
  }),
  
  // getters类似于组件的计算属性
  getters: {
    totalItems: (state) => state.items.length,
    totalPrice: (state) => state.items.reduce((sum, item) => sum + item.price * item.quantity, 0),
    isEmpty: (state) => state.items.length === 0
  },
  
  // actions包含可以修改状态和执行异步操作的方法
  actions: {
    async fetchItems() {
      this.loading = true
      this.error = null
      
      try {
        const response = await fetch('/api/cart')
        const data = await response.json()
        this.items = data.items
      } catch (err) {
        this.error = err.message
      } finally {
        this.loading = false
      }
    },
    
    addItem(product, quantity = 1) {
      const existingItem = this.items.find(item => item.id === product.id)
      
      if (existingItem) {
        existingItem.quantity += quantity
      } else {
        this.items.push({
          id: product.id,
          name: product.name,
          price: product.price,
          quantity
        })
      }
    },
    
    removeItem(itemId) {
      const index = this.items.findIndex(item => item.id === itemId)
      if (index > -1) {
        this.items.splice(index, 1)
      }
    },
    
    clearCart() {
      this.items = []
    }
  }
})
```

**组合式API风格**：

```javascript
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const useCartStore = defineStore('cart', () => {
  // 状态使用ref/reactive
  const items = ref([])
  const loading = ref(false)
  const error = ref(null)
  
  // getters使用computed
  const totalItems = computed(() => items.value.length)
  const totalPrice = computed(() => 
    items.value.reduce((sum, item) => sum + item.price * item.quantity, 0)
  )
  const isEmpty = computed(() => items.value.length === 0)
  
  // actions使用普通函数
  async function fetchItems() {
    loading.value = true
    error.value = null
    
    try {
      const response = await fetch('/api/cart')
      const data = await response.json()
      items.value = data.items
    } catch (err) {
      error.value = err.message
    } finally {
      loading.value = false
    }
  }
  
  function addItem(product, quantity = 1) {
    const existingItem = items.value.find(item => item.id === product.id)
    
    if (existingItem) {
      existingItem.quantity += quantity
    } else {
      items.value.push({
        id: product.id,
        name: product.name,
        price: product.price,
        quantity
      })
    }
  }
  
  function removeItem(itemId) {
    const index = items.value.findIndex(item => item.id === itemId)
    if (index > -1) {
      items.value.splice(index, 1)
    }
  }
  
  function clearCart() {
    items.value = []
  }
  
  // 返回所有要暴露的状态和方法
  return {
    items,
    loading,
    error,
    totalItems,
    totalPrice,
    isEmpty,
    fetchItems,
    addItem,
    removeItem,
    clearCart
  }
})
```

#### 使用Store

定义好store后，可以在组件中使用它：

```vue
<template>
  <div class="cart">
    <div v-if="cartStore.loading">加载中...</div>
    <div v-else-if="cartStore.error">加载失败: {{ cartStore.error }}</div>
    <div v-else-if="cartStore.isEmpty">购物车为空</div>
    <div v-else>
      <div class="cart-header">
        <h2>购物车 ({{ cartStore.totalItems }}件商品)</h2>
        <button @click="cartStore.clearCart">清空购物车</button>
      </div>
      
      <div class="cart-items">
        <div v-for="item in cartStore.items" :key="item.id" class="cart-item">
          <div class="item-name">{{ item.name }}</div>
          <div class="item-price">¥{{ item.price.toFixed(2) }}</div>
          <div class="item-quantity">
            <button @click="decreaseQuantity(item)">-</button>
            <span>{{ item.quantity }}</span>
            <button @click="cartStore.addItem(item, 1)">+</button>
          </div>
          <div class="item-total">¥{{ (item.price * item.quantity).toFixed(2) }}</div>
          <button @click="cartStore.removeItem(item.id)" class="remove-button">删除</button>
        </div>
      </div>
      
      <div class="cart-footer">
        <div class="cart-total">总计: ¥{{ cartStore.totalPrice.toFixed(2) }}</div>
        <button @click="checkout" class="checkout-button">结算</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { onMounted } from 'vue'
import { useCartStore } from '@/stores/cart'

// 初始化store
const cartStore = useCartStore()

// 组件挂载时加载购物车数据
onMounted(() => {
  cartStore.fetchItems()
})

// 减少商品数量
function decreaseQuantity(item) {
  if (item.quantity > 1) {
    item.quantity--
  } else {
    cartStore.removeItem(item.id)
  }
}

// 结算功能
function checkout() {
  // 实现结算逻辑
  alert(`结算成功，总金额: ¥${cartStore.totalPrice.toFixed(2)}`)
  cartStore.clearCart()
}
</script>
```

#### Store组合与解构

Pinia的一个强大特性是store可以相互使用，这使得复杂状态的组织变得简单：

```javascript
import { useUserStore } from './user'
import { useCartStore } from './cart'

export const useCheckoutStore = defineStore('checkout', {
  state: () => ({
    paymentMethod: null,
    shippingAddress: null,
    status: 'idle' // 'idle' | 'processing' | 'success' | 'error'
  }),
  
  actions: {
    async processCheckout() {
      const userStore = useUserStore()
      const cartStore = useCartStore()
      
      if (!userStore.isLoggedIn) {
        throw new Error('用户未登录')
      }
      
      if (cartStore.isEmpty) {
        throw new Error('购物车为空')
      }
      
      this.status = 'processing'
      
      try {
        // 处理结算逻辑
        await api.createOrder({
          userId: userStore.id,
          items: cartStore.items,
          paymentMethod: this.paymentMethod,
          shippingAddress: this.shippingAddress || userStore.defaultAddress
        })
        
        this.status = 'success'
        cartStore.clearCart()
      } catch (error) {
        this.status = 'error'
        throw error
      }
    }
  }
})
```

Pinia还支持解构store，同时保持其响应性：

```javascript
import { storeToRefs } from 'pinia'
import { useCartStore } from '@/stores/cart'

// 在组件中
const cartStore = useCartStore()

// 使用storeToRefs保持响应性
const { items, totalItems, totalPrice, isEmpty } = storeToRefs(cartStore)
// 方法不需要使用storeToRefs
const { addItem, removeItem, clearCart } = cartStore
```

### 与Vuex的对比

作为Vue官方的新一代状态管理库，Pinia与Vuex有许多相似之处，但也有重要的区别。了解这些区别有助于从Vuex迁移到Pinia，或为新项目选择合适的状态管理解决方案。

#### 核心概念对比

| 特性 | Vuex | Pinia |
|------|------|-------|
| 状态定义 | `state` | `state` |
| 派生状态 | `getters` | `getters` |
| 同步修改 | `mutations` | 直接在`actions`中修改 |
| 异步操作 | `actions` | `actions` |
| 模块化 | 嵌套模块，需要命名空间 | 扁平化设计，天然模块化 |
| TypeScript支持 | 有限，需要额外类型定义 | 原生支持，完整类型推断 |
| 开发工具 | Vue DevTools集成 | Vue DevTools集成，体验更佳 |

#### 代码对比

**Vuex示例**：

```javascript
// store/index.js
import { createStore } from 'vuex'

export default createStore({
  state: {
    count: 0
  },
  getters: {
    doubleCount: state => state.count * 2
  },
  mutations: {
    INCREMENT(state) {
      state.count++
    },
    SET_COUNT(state, value) {
      state.count = value
    }
  },
  actions: {
    incrementAsync({ commit }) {
      setTimeout(() => {
        commit('INCREMENT')
      }, 1000)
    },
    async fetchCount({ commit }) {
      const response = await fetch('/api/count')
      const data = await response.json()
      commit('SET_COUNT', data.count)
    }
  },
  modules: {
    // 嵌套模块...
  }
})

// 在组件中使用
import { useStore } from 'vuex'

export default {
  setup() {
    const store = useStore()
    
    return {
      // 需要使用computed保持响应性
      count: computed(() => store.state.count),
      doubleCount: computed(() => store.getters.doubleCount),
      
      // 方法
      increment() {
        store.commit('INCREMENT')
      },
      incrementAsync() {
        store.dispatch('incrementAsync')
      }
    }
  }
}
```

**Pinia示例**：

```javascript
// stores/counter.js
import { defineStore } from 'pinia'

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0
  }),
  getters: {
    doubleCount: state => state.count * 2
  },
  actions: {
    increment() {
      this.count++
    },
    incrementAsync() {
      setTimeout(() => {
        this.increment()
      }, 1000)
    },
    async fetchCount() {
      const response = await fetch('/api/count')
      const data = await response.json()
      this.count = data.count
    }
  }
})

// 在组件中使用
import { useCounterStore } from '@/stores/counter'
import { storeToRefs } from 'pinia'

export default {
  setup() {
    const counterStore = useCounterStore()
    
    // 解构时保持响应性
    const { count, doubleCount } = storeToRefs(counterStore)
    
    return {
      // 状态和getters
      count,
      doubleCount,
      
      // 方法
      increment: counterStore.increment,
      incrementAsync: counterStore.incrementAsync
    }
  }
}
```

#### 迁移策略

从Vuex迁移到Pinia的基本步骤：

1. **安装Pinia**：`npm install pinia`或`yarn add pinia`

2. **在应用中注册Pinia**：
   ```javascript
   import { createApp } from 'vue'
   import { createPinia } from 'pinia'
   import App from './App.vue'
   
   const app = createApp(App)
   app.use(createPinia())
   app.mount('#app')
   ```

3. **将Vuex模块转换为Pinia stores**：
   - 将`state`保持不变
   - 将`getters`保持不变
   - 将`mutations`中的逻辑移到`actions`中
   - 将`actions`保持不变，但直接修改状态而不是提交mutations

4. **更新组件中的使用方式**：
   - 使用特定的store hook代替通用的`useStore`
   - 使用`storeToRefs`保持解构的响应性

#### 何时选择Pinia

Pinia适合以下场景：

- 新的Vue3项目
- 需要良好TypeScript支持的项目
- 希望减少样板代码的项目
- 需要更好开发体验的项目

Vuex可能适合以下场景：

- 现有的Vue2项目（虽然Pinia也支持Vue2）
- 团队已经非常熟悉Vuex的项目
- 需要严格控制状态修改的项目（通过mutations）

## VueUse

VueUse是一个基于Vue组合式API的实用工具集合，提供了大量可复用的组合式函数，涵盖了状态管理、DOM操作、动画、网络请求等多个方面。它可以看作是Vue生态系统中的"lodash"，为开发者提供了丰富的工具函数，简化常见任务的实现。

### 响应式工具集

VueUse提供了许多增强Vue响应式系统的工具，使状态管理更加灵活和强大。

#### 基础响应式工具

```javascript
import { useStorage, useDebouncedRef, useLocalStorage, useSessionStorage } from '@vueuse/core'

// 创建一个与localStorage同步的响应式状态
const persistedState = useStorage('my-key', { count: 0, name: 'Anonymous' })

// 创建一个防抖的响应式引用
const searchQuery = useDebouncedRef('', 300)

// 专门用于localStorage的快捷方式
const theme = useLocalStorage('theme', 'light')

// 专门用于sessionStorage的快捷方式
const sessionUser = useSessionStorage('user', { id: null, name: '' })
```

#### 响应式状态转换

VueUse提供了多种工具来转换和处理响应式状态：

```javascript
import { 
  useCounter, 
  useToggle, 
  useArrayReduce,
  useArrayMap,
  useArrayFilter
} from '@vueuse/core'

// 计数器状态管理
const { count, inc, dec, set, reset } = useCounter(0)

// 布尔值切换
const [value, toggle] = useToggle(false)

// 响应式数组操作
const list = ref([1, 2, 3, 4, 5])
const sum = useArrayReduce(list, (sum, num) => sum + num, 0)
const doubled = useArrayMap(list, num => num * 2)
const evenNumbers = useArrayFilter(list, num => num % 2 === 0)
```

#### 异步状态管理

VueUse为异步操作提供了专门的工具，简化了加载状态、错误处理等常见需求：

```javascript
import { useAsyncState, useAxios, useFetch } from '@vueuse/core'
import axios from 'axios'

// 通用异步状态管理
const { state, isReady, isLoading, error, execute } = useAsyncState(
  async () => {
    const res = await fetch('/api/users')
    return await res.json()
  },
  [], // 初始状态
  { immediate: true } // 选项
)

// 与Axios集成
const { data, isFinished, isLoading: axiosLoading, error: axiosError } = useAxios('/api/posts')

// 使用Fetch API
const { data: fetchData, error: fetchError, isFetching } = useFetch('/api/comments').json()
```

### 状态管理相关函数

VueUse提供了一系列专门用于状态管理的函数，可以作为轻量级状态管理解决方案，或与Pinia等库配合使用。

#### 创建共享状态

```javascript
import { createGlobalState, createSharedComposable } from '@vueuse/core'

// 创建全局状态
const useGlobalState = createGlobalState(() => {
  const count = ref(0)
  const increment = () => count.value++
  const decrement = () => count.value--
  
  return { count, increment, decrement }
})

// 在任何组件中使用
const { count, increment, decrement } = useGlobalState()

// 创建可共享的组合式函数
function useCounter() {
  const count = ref(0)
  const increment = () => count.value++
  const decrement = () => count.value--
  
  return { count, increment, decrement }
}

// 转换为共享版本
const useSharedCounter = createSharedComposable(useCounter)

// 在不同组件中使用，共享同一个状态
const { count, increment } = useSharedCounter()
```

#### 状态同步与事件管理

```javascript
import { useEventBus, useBroadcastChannel, useShare } from '@vueuse/core'

// 事件总线
const bus = useEventBus('my-bus')

// 发送事件
bus.emit('event-name', { data: 'some data' })

// 监听事件
bus.on('event-name', (data) => {
  console.log('Received:', data)
})

// 跨标签页/窗口通信
const { post, data: receivedData, error } = useBroadcastChannel({
  name: 'my-channel'
})

// 发送消息到其他标签页
post({ type: 'update', payload: { id: 1, value: 'new value' } })

// Web Share API
const { share, isSupported: isShareSupported } = useShare()
const shareData = {
  title: '分享标题',
  text: '分享内容',
  url: window.location.href
}

// 分享内容
if (isShareSupported.value) {
  share(shareData)
}
```

#### 状态监听与副作用

```javascript
import { watchDebounced, watchThrottled, whenever, useRefHistory } from '@vueuse/core'

const searchInput = ref('')

// 防抖监听
watchDebounced(
  searchInput,
  (newValue) => {
    // 执行搜索操作
    console.log('Searching for:', newValue)
  },
  { debounce: 500, maxWait: 1000 }
)

// 节流监听
watchThrottled(
  searchInput,
  (newValue) => {
    // 执行实时预览
    console.log('Preview for:', newValue)
  },
  { throttle: 100 }
)

// 条件监听
const isReady = ref(false)
whenever(isReady, () => {
  // 只有当isReady变为true时才执行
  console.log('Ready!')
})

// 状态历史记录（撤销/重做）
const text = ref('Hello')
const { history, undo, redo, clear } = useRefHistory(text)
```

### 持久化状态解决方案

VueUse提供了多种持久化状态的解决方案，使应用状态可以在页面刷新或关闭后恢复。

#### 基于存储的持久化

```javascript
import { useStorage, useLocalStorage, useSessionStorage, useCookies } from '@vueuse/core'

// 通用存储持久化
const state = useStorage('app-state', {
  user: null,
  theme: 'light',
  sidebar: true
})

// localStorage持久化
const theme = useLocalStorage('theme', 'light')
const recentSearches = useLocalStorage('recent-searches', [])

// sessionStorage持久化
const sessionState = useSessionStorage('session', {
  tabId: Date.now(),
  lastActive: Date.now()
})

// Cookie持久化
const cookies = useCookies(['auth-token', 'user-preferences'])
cookies.set('auth-token', 'my-token', { expires: 7 }) // 7天过期
const token = computed(() => cookies.get('auth-token'))
```

#### 高级持久化策略

```javascript
import { useStorage, usePreferredDark, useMediaQuery } from '@vueuse/core'

// 持久化主题，并与系统主题同步
const prefersDark = usePreferredDark()
const theme = useStorage('theme', 'auto')

// 计算实际使用的主题
const activeTheme = computed(() => {
  if (theme.value === 'auto') {
    return prefersDark.value ? 'dark' : 'light'
  }
  return theme.value
})

// 监听并应用主题变化
watch(activeTheme, (newTheme) => {
  document.documentElement.setAttribute('data-theme', newTheme)
})

// 响应式持久化表单
const formState = useStorage('form-draft', {
  name: '',
  email: '',
  message: ''
})

// 自动保存草稿
const autoSave = (formData) => {
  formState.value = { ...formData }
}

// 使用防抖保存
const debouncedSave = useDebounceFn(autoSave, 500)
```

#### 与Pinia集成的持久化

VueUse可以与Pinia结合，实现store的持久化：

```javascript
import { defineStore } from 'pinia'
import { useStorage } from '@vueuse/core'

export const useUserStore = defineStore('user', () => {
  // 使用useStorage直接创建持久化的状态
  const user = useStorage('user-state', {
    id: null,
    name: '',
    email: '',
    preferences: {
      theme: 'light',
      notifications: true
    }
  })
  
  // 登录操作
  async function login(credentials) {
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials)
      })
      
      if (!response.ok) throw new Error('Login failed')
      
      const userData = await response.json()
      
      // 更新持久化状态
      user.value = userData
      
      return true
    } catch (error) {
      console.error('Login error:', error)
      return false
    }
  }
  
  // 注销操作
  function logout() {
    // 清除用户数据
    user.value = {
      id: null,
      name: '',
      email: '',
      preferences: {
        theme: 'light',
        notifications: true
      }
    }
  }
  
  // 更新用户偏好
  function updatePreferences(newPreferences) {
    user.value.preferences = {
      ...user.value.preferences,
      ...newPreferences
    }
  }
  
  return { user, login, logout, updatePreferences }
})
```

## 轻量级状态管理

对于中小型应用或特定功能模块，完整的状态管理库可能过于复杂。Vue3提供了多种轻量级状态管理方案，可以在不引入额外依赖的情况下实现状态共享和管理。

### provide/inject模式

Vue3的provide/inject API是一种强大的依赖注入机制，可以用于跨多级组件传递数据，是实现轻量级状态管理的理想选择。

#### 基本使用

```vue
<!-- 父组件提供状态 -->
<script setup>
import { ref, provide } from 'vue'

// 创建响应式状态
const count = ref(0)
const increment = () => count.value++
const decrement = () => count.value--

// 提供给后代组件
provide('counter', {
  count,
  increment,
  decrement
})
</script>

<!-- 后代组件注入状态 -->
<script setup>
import { inject } from 'vue'

// 注入由祖先组件提供的状态
const { count, increment, decrement } = inject('counter')
</script>
```

#### 创建可响应的上下文

通过provide/inject可以创建一个响应式的上下文，实现类似于React Context的功能：

```javascript
// contexts/ThemeContext.js
import { ref, readonly, provide, inject } from 'vue'

// 创建Symbol作为注入键，避免命名冲突
const ThemeSymbol = Symbol('
让我继续完成关于状态管理工具的内容：

## 轻量级状态管理

对于中小型应用或特定功能模块，完整的状态管理库可能过于复杂。Vue3提供了多种轻量级状态管理方案，可以在不引入额外依赖的情况下实现状态共享和管理。

### provide/inject模式

Vue3的provide/inject API是一种强大的依赖注入机制，可以用于跨多级组件传递数据，是实现轻量级状态管理的理想选择。

#### 基本使用

```vue
<!-- 父组件提供状态 -->
<script setup>
import { ref, provide } from 'vue'

// 创建响应式状态
const count = ref(0)
const increment = () => count.value++
const decrement = () => count.value--

// 提供给后代组件
provide('counter', {
  count,
  increment,
  decrement
})
</script>

<!-- 后代组件注入状态 -->
<script setup>
import { inject } from 'vue'

// 注入由祖先组件提供的状态
const { count, increment, decrement } = inject('counter')
</script>
```

#### 创建可响应的上下文

通过provide/inject可以创建一个响应式的上下文，实现类似于React Context的功能：

```javascript
// contexts/ThemeContext.js
import { ref, readonly, provide, inject } from 'vue'

// 创建Symbol作为注入键，避免命名冲突
const ThemeSymbol = Symbol('theme')

// 创建可复用的上下文提供者
export function provideTheme() {
  const theme = ref('light')
  
  const setTheme = (newTheme) => {
    theme.value = newTheme
  }
  
  // 提供只读状态和修改方法
  provide(ThemeSymbol, {
    theme: readonly(theme),
    setTheme
  })
  
  return { theme, setTheme }
}

// 创建可复用的上下文消费者
export function useTheme() {
  const theme = inject(ThemeSymbol)
  
  if (!theme) {
    throw new Error('useTheme() must be used within a component that calls provideTheme()')
  }
  
  return theme
}
```

使用上下文：

```vue
<!-- App.vue -->
<template>
  <div :class="['app', `theme-${theme.theme}`]">
    <button @click="toggleTheme">切换主题</button>
    <router-view />
  </div>
</template>

<script setup>
import { provideTheme } from './contexts/ThemeContext'

const { theme, setTheme } = provideTheme()

const toggleTheme = () => {
  setTheme(theme.value === 'light' ? 'dark' : 'light')
}
</script>

<!-- 子组件 -->
<template>
  <div class="card">
    <p>当前主题: {{ theme.theme }}</p>
  </div>
</template>

<script setup>
import { useTheme } from './contexts/ThemeContext'

const { theme } = useTheme()
</script>
```

#### 实现全局状态管理

通过在应用根组件中使用provide，可以实现全局状态管理：

```javascript
// store/index.js
import { reactive, readonly, provide, inject } from 'vue'

// 状态符号
const StateSymbol = Symbol('state')

// 创建初始状态
const createState = () => ({
  user: null,
  isAuthenticated: false,
  preferences: {
    theme: 'light',
    language: 'zh-CN'
  },
  notifications: []
})

// 创建actions
const createActions = (state) => ({
  login(userData) {
    state.user = userData
    state.isAuthenticated = true
  },
  logout() {
    state.user = null
    state.isAuthenticated = false
  },
  updatePreferences(newPrefs) {
    state.preferences = { ...state.preferences, ...newPrefs }
  },
  addNotification(notification) {
    state.notifications.push({
      id: Date.now(),
      read: false,
      ...notification
    })
  },
  markNotificationAsRead(id) {
    const notification = state.notifications.find(n => n.id === id)
    if (notification) {
      notification.read = true
    }
  },
  clearNotifications() {
    state.notifications = []
  }
})

// 提供状态和actions
export function provideStore() {
  const state = reactive(createState())
  const actions = createActions(state)
  
  provide(StateSymbol, {
    state: readonly(state),
    ...actions
  })
  
  return { state, ...actions }
}

// 使用状态和actions
export function useStore() {
  const store = inject(StateSymbol)
  
  if (!store) {
    throw new Error('useStore() must be used within a component that calls provideStore()')
  }
  
  return store
}
```

在应用中使用：

```vue
<!-- main.js -->
import { createApp } from 'vue'
import App from './App.vue'
import router from './router'

createApp(App)
  .use(router)
  .mount('#app')

<!-- App.vue -->
<template>
  <div id="app">
    <header>
      <template v-if="store.state.isAuthenticated">
        <span>欢迎, {{ store.state.user.name }}</span>
        <button @click="store.logout">退出</button>
      </template>
      <template v-else>
        <button @click="showLogin">登录</button>
      </template>
    </header>
    
    <main>
      <router-view />
    </main>
  </div>
</template>

<script setup>
import { provideStore } from './store'

// 提供全局状态
const store = provideStore()

// 模拟登录
const showLogin = () => {
  // 实际应用中这里会显示登录表单
  store.login({
    id: 1,
    name: '张三',
    email: 'zhangsan@example.com'
  })
}
</script>

<!-- 子组件 -->
<template>
  <div class="profile">
    <h2>用户资料</h2>
    <div v-if="store.state.isAuthenticated">
      <p>用户名: {{ store.state.user.name }}</p>
      <p>邮箱: {{ store.state.user.email }}</p>
      
      <h3>偏好设置</h3>
      <div class="preferences">
        <div>
          <label>主题:</label>
          <select 
            :value="store.state.preferences.theme"
            @change="updateTheme"
          >
            <option value="light">浅色</option>
            <option value="dark">深色</option>
            <option value="system">跟随系统</option>
          </select>
        </div>
        
        <div>
          <label>语言:</label>
          <select 
            :value="store.state.preferences.language"
            @change="updateLanguage"
          >
            <option value="zh-CN">简体中文</option>
            <option value="en-US">English</option>
          </select>
        </div>
      </div>
    </div>
    <div v-else>
      <p>请先登录</p>
    </div>
  </div>
</template>

<script setup>
import { useStore } from './store'

const store = useStore()

const updateTheme = (e) => {
  store.updatePreferences({ theme: e.target.value })
}

const updateLanguage = (e) => {
  store.updatePreferences({ language: e.target.value })
}
</script>
```

### 组合式函数封装

Vue3的组合式API为创建可复用的状态逻辑提供了强大的工具。通过封装组合式函数（Composables），可以实现模块化的状态管理。

#### 创建状态模块

```javascript
// composables/useCounter.js
import { ref, computed } from 'vue'

export function useCounter(initialValue = 0) {
  // 状态
  const count = ref(initialValue)
  
  // 计算属性
  const isPositive = computed(() => count.value > 0)
  const isNegative = computed(() => count.value < 0)
  const isZero = computed(() => count.value === 0)
  
  // 方法
  const increment = (amount = 1) => {
    count.value += amount
  }
  
  const decrement = (amount = 1) => {
    count.value -= amount
  }
  
  const reset = () => {
    count.value = initialValue
  }
  
  // 返回状态和方法
  return {
    count,
    isPositive,
    isNegative,
    isZero,
    increment,
    decrement,
    reset
  }
}
```

#### 创建共享状态

默认情况下，组合式函数在每个组件中创建独立的状态实例。要创建共享状态，可以将状态提升到组件外部：

```javascript
// composables/useSharedCounter.js
import { ref, computed } from 'vue'

// 在模块作用域创建状态，使其在所有组件间共享
const count = ref(0)
const isPositive = computed(() => count.value > 0)
const isNegative = computed(() => count.value < 0)
const isZero = computed(() => count.value === 0)

export function useSharedCounter() {
  // 方法
  const increment = (amount = 1) => {
    count.value += amount
  }
  
  const decrement = (amount = 1) => {
    count.value -= amount
  }
  
  const reset = () => {
    count.value = 0
  }
  
  // 返回共享状态和方法
  return {
    count,
    isPositive,
    isNegative,
    isZero,
    increment,
    decrement,
    reset
  }
}
```

#### 复杂状态管理示例

对于更复杂的状态管理需求，可以组合多个组合式函数：

```javascript
// composables/useAuth.js
import { ref, computed, watch } from 'vue'

// 创建共享状态
const user = ref(null)
const token = ref(localStorage.getItem('auth-token') || null)
const loading = ref(false)
const error = ref(null)

// 计算属性
const isAuthenticated = computed(() => !!token.value)
const isAdmin = computed(() => user.value?.role === 'admin')

// 持久化token
watch(token, (newToken) => {
  if (newToken) {
    localStorage.setItem('auth-token', newToken)
  } else {
    localStorage.removeItem('auth-token')
  }
})

export function useAuth() {
  // 登录方法
  const login = async (credentials) => {
    loading.value = true
    error.value = null
    
    try {
      // 实际应用中这里会调用API
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(credentials)
      })
      
      if (!response.ok) {
        throw new Error('登录失败')
      }
      
      const data = await response.json()
      
      user.value = data.user
      token.value = data.token
      
      return true
    } catch (e) {
      error.value = e.message
      return false
    } finally {
      loading.value = false
    }
  }
  
  // 注销方法
  const logout = () => {
    user.value = null
    token.value = null
  }
  
  // 获取用户信息
  const fetchUserInfo = async () => {
    if (!token.value) return
    
    loading.value = true
    error.value = null
    
    try {
      const response = await fetch('/api/me', {
        headers: {
          'Authorization': `Bearer ${token.value}`
        }
      })
      
      if (!response.ok) {
        throw new Error('获取用户信息失败')
      }
      
      const data = await response.json()
      user.value = data
    } catch (e) {
      error.value = e.message
      // 如果是认证错误，清除token
      if (e.message.includes('认证') || e.message.includes('授权')) {
        token.value = null
      }
    } finally {
      loading.value = false
    }
  }
  
  return {
    user,
    token,
    loading,
    error,
    isAuthenticated,
    isAdmin,
    login,
    logout,
    fetchUserInfo
  }
}

// composables/useCart.js
import { ref, computed, watch } from 'vue'
import { useAuth } from './useAuth'

// 创建共享状态
const items = ref([])
const loading = ref(false)
const error = ref(null)

// 从localStorage恢复购物车
try {
  const savedCart = localStorage.getItem('cart')
  if (savedCart) {
    items.value = JSON.parse(savedCart)
  }
} catch (e) {
  console.error('Failed to restore cart:', e)
}

// 持久化购物车
watch(items, (newItems) => {
  localStorage.setItem('cart', JSON.stringify(newItems))
}, { deep: true })

export function useCart() {
  const { isAuthenticated, token } = useAuth()
  
  // 计算属性
  const totalItems = computed(() => items.value.reduce((sum, item) => sum + item.quantity, 0))
  const totalPrice = computed(() => items.value.reduce((sum, item) => sum + item.price * item.quantity, 0))
  const isEmpty = computed(() => items.value.length === 0)
  
  // 添加商品
  const addItem = (product, quantity = 1) => {
    const existingItem = items.value.find(item => item.id === product.id)
    
    if (existingItem) {
      existingItem.quantity += quantity
    } else {
      items.value.push({
        id: product.id,
        name: product.name,
        price: product.price,
        quantity
      })
    }
  }
  
  // 移除商品
  const removeItem = (productId) => {
    const index = items.value.findIndex(item => item.id === productId)
    if (index !== -1) {
      items.value.splice(index, 1)
    }
  }
  
  // 更新数量
  const updateQuantity = (productId, quantity) => {
    const item = items.value.find(item => item.id === productId)
    if (item) {
      item.quantity = Math.max(1, quantity)
    }
  }
  
  // 清空购物车
  const clearCart = () => {
    items.value = []
  }
  
  // 同步购物车到服务器
  const syncCart = async () => {
    if (!isAuthenticated.value) return
    
    loading.value = true
    error.value = null
    
    try {
      const response = await fetch('/api/cart', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token.value}`
        },
        body: JSON.stringify({ items: items.value })
      })
      
      if (!response.ok) {
        throw new Error('同步购物车失败')
      }
    } catch (e) {
      error.value = e.message
    } finally {
      loading.value = false
    }
  }
  
  // 从服务器加载购物车
  const fetchCart = async () => {
    if (!isAuthenticated.value) return
    
    loading.value = true
    error.value = null
    
    try {
      const response = await fetch('/api/cart', {
        headers: {
          'Authorization': `Bearer ${token.value}`
        }
      })
      
      if (!response.ok) {
        throw new Error('获取购物车失败')
      }
      
      const data = await response.json()
      items.value = data.items
    } catch (e) {
      error.value = e.message
    } finally {
      loading.value = false
    }
  }
  
  return {
    items,
    loading,
    error,
    totalItems,
    totalPrice,
    isEmpty,
    addItem,
    removeItem,
    updateQuantity,
    clearCart,
    syncCart,
    fetchCart
  }
}
```

在组件中使用：

```vue
<template>
  <div class="cart-widget">
    <div v-if="loading">加载中...</div>
    <div v-else-if="error">错误: {{ error }}</div>
    <div v-else-if="isEmpty">购物车为空</div>
    <div v-else>
      <div class="cart-summary">
        <span>{{ totalItems }}件商品</span>
        <span>总计: ¥{{ totalPrice.toFixed(2) }}</span>
      </div>
      
      <ul class="cart-items">
        <li v-for="item in items" :key="item.id" class="cart-item">
          <div class="item-name">{{ item.name }}</div>
          <div class="item-price">¥{{ item.price.toFixed(2) }}</div>
          <div class="item-quantity">
            <button @click="updateQuantity(item.id, item.quantity - 1)" :disabled="item.quantity <= 1">-</button>
            <span>{{ item.quantity }}</span>
            <button @click="updateQuantity(item.id, item.quantity + 1)">+</button>
          </div>
          <div class="item-total">¥{{ (item.price * item.quantity).toFixed(2) }}</div>
          <button @click="removeItem(item.id)" class="remove-button">删除</button>
        </li>
      </ul>
      
      <div class="cart-actions">
        <button @click="clearCart">清空购物车</button>
        <button @click="checkout" :disabled="loading">结算</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { useCart } from '@/composables/useCart'
import { useAuth } from '@/composables/useAuth'
import { onMounted } from 'vue'

const { 
  items, 
  loading, 
  error, 
  totalItems, 
  totalPrice, 
  isEmpty,
  removeItem,
  updateQuantity,
  clearCart,
  fetchCart
} = useCart()

const { isAuthenticated } = useAuth()

// 组件挂载时加载购物车
onMounted(() => {
  if (isAuthenticated.value) {
    fetchCart()
  }
})

// 结算功能
const checkout = () => {
  // 实际应用中这里会跳转到结算页面
  alert(`结算成功，总金额: ¥${totalPrice.value.toFixed(2)}`)
  clearCart()
}
</script>
```

### 响应式API自定义状态

Vue3的响应式API（如`reactive`、`ref`、`computed`、`watch`等）提供了构建自定义状态管理解决方案的基础。通过这些API，可以创建适合特定需求的状态管理模式。

#### 创建简单的状态管理器

```javascript
// store/createStore.js
import { reactive, readonly, computed, watch } from 'vue'

export function createStore(options) {
  // 创建响应式状态
  const state = reactive(options.state())
  
  // 创建getters
  const getters = {}
  
  for (const key in options.getters) {
    getters[key] = computed(() => options.getters[key](state, getters))
  }
  
  // 创建actions
  const actions = {}
  
  for (const key in options.actions) {
    actions[key] = (...args) => options.actions[key](state, getters, actions, ...args)
  }
  
  // 添加持久化功能
  if (options.persist) {
    // 从localStorage恢复状态
    const savedState = localStorage.getItem(options.persist.key)
    if (savedState) {
      try {
        const parsed = JSON.parse(savedState)
        Object.assign(state, parsed)
      } catch (e) {
        console.error(`Failed to restore state from localStorage: ${e}`)
      }
    }
    
    // 监听状态变化并保存
    watch(
      () => state,
      (newState) => {
        localStorage.setItem(options.persist.key, JSON.stringify(newState))
      },
      { deep: true }
    )
  }
  
  // 返回只读状态、getters和actions
  return {
    state: readonly(state),
    getters,
    ...actions
  }
}
```

使用自定义状态管理器：

```javascript
// store/user.js
import { createStore } from './createStore'

export const userStore = createStore({
  state: () => ({
    user: null,
    isAuthenticated: false,
    loading: false,
    error: null
  }),
  
  getters: {
    isAdmin: (state) => state.user?.role === 'admin',
    username: (state) => state.user?.name || '游客'
  },
  
  actions: {
    async login(state, getters, actions, credentials) {
      state.loading = true
      state.error = null
      
      try {
        // 模拟API调用
        const response = await fetch('/api/login', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(credentials)
        })
        
        if (!response.ok) {
          throw new Error('登录失败')
        }
        
        const data = await response.json()
        
        state.user = data.user
        state.isAuthenticated = true
        
        return true
      } catch (e) {
        state.error = e.message
        return false
      } finally {
        state.loading = false
      }
    },
    
    logout(state) {
      state.user = null
      state.isAuthenticated = false
    }
  },
  
  // 持久化配置
  persist: {
    key: 'user-store'
  }
})

// store/cart.js
import { createStore } from './createStore'

export const cartStore = createStore({
  state: () => ({
    items: [],
    loading: false,
    error: null
  }),
  
  getters: {
    totalItems: (state) => state.items.reduce((sum, item) => sum + item.quantity, 0),
    totalPrice: (state) => state.items.reduce((sum, item) => sum + item.price * item.quantity, 0),
    isEmpty: (state) => state.items.length === 0
  },
  
  actions: {
    addItem(state, getters, actions, product, quantity = 1) {
      const existingItem = state.items.find(item => item.id === product.id)
      
      if (existingItem) {
        existingItem.quantity += quantity
      } else {
        state.items.push({
          id: product.id,
          name: product.name,
          price: product.price,
          quantity
        })
      }
    },
    
    removeItem(state, getters, actions, productId) {
      const index = state.items.findIndex(item => item.id === productId)
      if (index !== -1) {
        state.items.splice(index, 1)
      }
    },
    
    updateQuantity(state, getters, actions, productId, quantity) {
      const item = state.items.find(item => item.id === productId)
      if (item) {
        item.quantity = Math.max(1, quantity)
      }
    },
    
    clearCart(state) {
      state.items = []
    }
  },
  
  // 持久化配置
  persist: {
    key: 'cart-store'
  }
})
```

在组件中使用：

```vue
<template>
  <div>
    <!-- 用户信息 -->
    <div class="user-info">
      <div v-if="userStore.state.isAuthenticated">
        <p>欢迎, {{ userStore.getters.username }}</p>
        <button @click="userStore.logout">退出</button>
      </div>
      <div v-else>
        <button @click="showLoginForm">登录</button>
      </div>
    </div>
    
    <!-- 购物车 -->
    <div class="cart-summary">
      <p>购物车: {{ cartStore.getters.totalItems }}件商品</p>
      <p>总计: ¥{{ cartStore.getters.totalPrice.toFixed(2) }}</p>
      <button @click="showCart">查看购物车</button>
    </div>
    
    <!-- 商品列表 -->
    <div class="product-list">
      <div v-for="product in products" :key="product.id" class="product-card">
        <h3>{{ product.name }}</h3>
        <p>¥{{ product.price.toFixed(2) }}</p>
        <button @click="cartStore.addItem(product)">加入购物车</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { userStore } from '@/store/user'
import { cartStore } from '@/store/cart'

// 模拟商品数据
const products = ref([
  { id: 1, name: '商品1', price: 99.99 },
  { id: 2, name: '商品2', price: 199.99 },
  { id: 3, name: '商品3', price: 299.99 }
])

// 显示登录表单
const showLoginForm = () => {
  // 实际应用中这里会显示登录表单
  const credentials = {
    username: 'demo',
    password: 'demo123'
  }
  
  userStore.login(credentials)
}

// 显示购物车
const showCart = () => {
  // 实际应用中这里会显示购物车详情
  alert(`购物车中有${cartStore.getters.totalItems}件商品，总计¥${cartStore.getters.totalPrice.toFixed(2)}`)
}
</script>
```

#### 创建模块化状态管理系统

对于更复杂的应用，可以创建模块化的状态管理系统：

```javascript
// store/createModuleStore.js
import { reactive, readonly, computed, watch } from 'vue'

export function createModuleStore() {
  // 存储所有模块
  const modules = {}
  
  // 注册模块
  function registerModule(name, options) {
    // 创建模块状态
    const state = reactive(options.state())
    
    // 创建getters
    const getters = {}
    
    for (const key in options.getters) {
      getters[key] = computed(() => {
        // 为getter提供state和其他模块的访问
        return options.getters[key](state, {
          // 允许访问自身的getters
          getters,
          // 允许访问其他模块
          modules: Object.keys(modules).reduce((acc, moduleName) => {
            if (moduleName !== name) {
              acc[moduleName] = modules[moduleName]
            }
            return acc
          }, {})
        })
      })
    }
    
    // 创建actions
    const actions = {}
    
    for (const key in options.actions) {
      actions[key] = (...args) => {
        // 为action提供state、getters和其他模块的访问
        return options.actions[key](state, {
          getters,
          actions,
          modules: Object.keys(modules).reduce((acc, moduleName) => {
            if (moduleName !== name) {
              acc[moduleName] = modules[moduleName]
            }
            return acc
          }, {})
        }, ...args)
      }
    }
    
    // 添加持久化功能
    if (options.persist) {
      const storageKey = options.persist.key || `store-${name}`
      
      // 从localStorage恢复状态
      const savedState = localStorage.getItem(storageKey)
      if (savedState) {
        try {
          const parsed = JSON.parse(savedState)
          Object.assign(state, parsed)
        } catch (e) {
          console.error(`Failed to restore state for module ${name}: ${e}`)
        }
      }
      
      // 监听状态变化并保存
      watch(
        () => state,
        (newState) => {
          localStorage.setItem(storageKey, JSON.stringify(newState))
        },
        { deep: true }
      )
    }
    
    // 创建模块对象
    const module = {
      state: readonly(state),
      getters,
      ...actions
    }
    
    // 存储模块
    modules[name] = module
    
    return module
  }
  
  // 获取已注册的模块
  function getModule(name) {
    if (!modules[name]) {
      throw new Error(`Module "${name}" not registered`)
    }
    
    return modules[name]
  }
  
  // 返回store对象
  return {
    registerModule,
    getModule
  }
}
```

使用模块化状态管理系统：

```javascript
// store/index.js
import { createModuleStore } from './createModuleStore'

// 创建store
export const store = createModuleStore()

// 注册用户模块
export const userModule = store.registerModule('user', {
  state: () => ({
    user: null,
    isAuthenticated: false,
    loading: false,
    error: null
  }),
  
  getters: {
    isAdmin: (state) => state.user?.role === 'admin',
    username: (state) => state.user?.name || '游客'
  },
  
  actions: {
    async login(state, { modules }, credentials) {
让我继续完成关于模块化状态管理系统的内容：

```javascript
// store/index.js
import { createModuleStore } from './createModuleStore'

// 创建store
export const store = createModuleStore()

// 注册用户模块
export const userModule = store.registerModule('user', {
  state: () => ({
    user: null,
    isAuthenticated: false,
    loading: false,
    error: null
  }),
  
  getters: {
    isAdmin: (state) => state.user?.role === 'admin',
    username: (state) => state.user?.name || '游客'
  },
  
  actions: {
    async login(state, { modules }, credentials) {
      state.loading = true
      state.error = null
      
      try {
        // 模拟API调用
        const response = await fetch('/api/login', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify(credentials)
        })
        
        if (!response.ok) {
          throw new Error('登录失败')
        }
        
        const data = await response.json()
        
        state.user = data.user
        state.isAuthenticated = true
        
        // 登录成功后加载购物车
        if (modules.cart) {
          modules.cart.fetchCart()
        }
        
        return true
      } catch (e) {
        state.error = e.message
        return false
      } finally {
        state.loading = false
      }
    },
    
    logout(state, { modules }) {
      state.user = null
      state.isAuthenticated = false
      
      // 注销时清空购物车
      if (modules.cart) {
        modules.cart.clearCart()
      }
    }
  },
  
  persist: {
    key: 'user-module'
  }
})

// 注册购物车模块
export const cartModule = store.registerModule('cart', {
  state: () => ({
    items: [],
    loading: false,
    error: null
  }),
  
  getters: {
    totalItems: (state) => state.items.reduce((sum, item) => sum + item.quantity, 0),
    totalPrice: (state) => state.items.reduce((sum, item) => sum + item.price * item.quantity, 0),
    isEmpty: (state) => state.items.length === 0,
    
    // 使用其他模块的状态
    canCheckout: (state, { modules }) => {
      return state.items.length > 0 && modules.user.state.isAuthenticated
    }
  },
  
  actions: {
    addItem(state, _, product, quantity = 1) {
      const existingItem = state.items.find(item => item.id === product.id)
      
      if (existingItem) {
        existingItem.quantity += quantity
      } else {
        state.items.push({
          id: product.id,
          name: product.name,
          price: product.price,
          quantity
        })
      }
    },
    
    removeItem(state, _, productId) {
      const index = state.items.findIndex(item => item.id === productId)
      if (index !== -1) {
        state.items.splice(index, 1)
      }
    },
    
    updateQuantity(state, _, productId, quantity) {
      const item = state.items.find(item => item.id === productId)
      if (item) {
        item.quantity = Math.max(1, quantity)
      }
    },
    
    clearCart(state) {
      state.items = []
    },
    
    async fetchCart(state, { modules }) {
      // 只有登录用户才能获取购物车
      if (!modules.user.state.isAuthenticated) return
      
      state.loading = true
      state.error = null
      
      try {
        // 模拟API调用
        const response = await fetch('/api/cart', {
          headers: {
            'Authorization': `Bearer ${modules.user.state.user.token}`
          }
        })
        
        if (!response.ok) {
          throw new Error('获取购物车失败')
        }
        
        const data = await response.json()
        state.items = data.items
      } catch (e) {
        state.error = e.message
      } finally {
        state.loading = false
      }
    },
    
    async checkout(state, { modules, actions }) {
      // 检查用户是否登录
      if (!modules.user.state.isAuthenticated) {
        throw new Error('请先登录')
      }
      
      // 检查购物车是否为空
      if (state.items.length === 0) {
        throw new Error('购物车为空')
      }
      
      state.loading = true
      state.error = null
      
      try {
        // 模拟API调用
        const response = await fetch('/api/checkout', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${modules.user.state.user.token}`
          },
          body: JSON.stringify({
            items: state.items
          })
        })
        
        if (!response.ok) {
          throw new Error('结算失败')
        }
        
        // 结算成功后清空购物车
        actions.clearCart()
        
        return true
      } catch (e) {
        state.error = e.message
        return false
      } finally {
        state.loading = false
      }
    }
  },
  
  persist: {
    key: 'cart-module'
  }
})
```

在组件中使用模块化状态管理系统：

```vue
<template>
  <div>
    <header>
      <!-- 用户信息 -->
      <div class="user-info">
        <div v-if="user.state.loading">登录中...</div>
        <div v-else-if="user.state.error">错误: {{ user.state.error }}</div>
        <div v-else-if="user.state.isAuthenticated">
          <p>欢迎, {{ user.getters.username }}</p>
          <span v-if="user.getters.isAdmin" class="admin-badge">管理员</span>
          <button @click="user.logout">退出</button>
        </div>
        <div v-else>
          <button @click="showLoginForm">登录</button>
        </div>
      </div>
      
      <!-- 购物车摘要 -->
      <div class="cart-summary">
        <div v-if="cart.state.loading">加载中...</div>
        <div v-else-if="cart.state.error">错误: {{ cart.state.error }}</div>
        <div v-else>
          <p>购物车: {{ cart.getters.totalItems }}件商品</p>
          <p>总计: ¥{{ cart.getters.totalPrice.toFixed(2) }}</p>
          <button @click="showCart" :disabled="cart.getters.isEmpty">查看购物车</button>
          <button 
            @click="checkout" 
            :disabled="!cart.getters.canCheckout || cart.state.loading"
          >
            结算
          </button>
        </div>
      </div>
    </header>
    
    <main>
      <!-- 商品列表 -->
      <div class="product-list">
        <div v-for="product in products" :key="product.id" class="product-card">
          <h3>{{ product.name }}</h3>
          <p>¥{{ product.price.toFixed(2) }}</p>
          <button @click="cart.addItem(product)">加入购物车</button>
        </div>
      </div>
    </main>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { userModule as user, cartModule as cart } from '@/store'

// 模拟商品数据
const products = ref([
  { id: 1, name: '商品1', price: 99.99 },
  { id: 2, name: '商品2', price: 199.99 },
  { id: 3, name: '商品3', price: 299.99 }
])

// 显示登录表单
const showLoginForm = () => {
  // 实际应用中这里会显示登录表单
  const credentials = {
    username: 'demo',
    password: 'demo123'
  }
  
  user.login(credentials)
}

// 显示购物车
const showCart = () => {
  // 实际应用中这里会显示购物车详情或跳转到购物车页面
  alert(`购物车中有${cart.getters.totalItems}件商品，总计¥${cart.getters.totalPrice.toFixed(2)}`)
}

// 结算
const checkout = async () => {
  if (await cart.checkout()) {
    alert('结算成功！')
  } else {
    alert(`结算失败: ${cart.state.error}`)
  }
}
</script>
```

## 选择合适的状态管理方案

在Vue3生态中，有多种状态管理解决方案可供选择。如何为项目选择合适的状态管理工具，取决于项目的规模、复杂度和特定需求。

### 项目规模与复杂度

根据项目规模和复杂度，可以采用不同的状态管理策略：

1. **小型项目**：
   - 使用Vue3的响应式API（`ref`、`reactive`）
   - 使用`provide`/`inject`进行组件间通信
   - 使用简单的组合式函数封装状态逻辑

2. **中型项目**：
   - 使用VueUse的状态管理工具（`createGlobalState`、`createSharedComposable`）
   - 使用自定义的轻量级状态管理解决方案
   - 对特定功能模块使用Pinia

3. **大型项目**：
   - 使用Pinia作为主要状态管理库
   - 采用模块化的状态设计
   - 结合VueUse增强特定功能

### 功能需求考量

除了项目规模，还需要考虑特定的功能需求：

1. **持久化需求**：
   - 简单持久化：VueUse的`useStorage`系列函数
   - 复杂持久化：Pinia插件或自定义持久化逻辑

2. **服务器状态同步**：
   - 简单API调用：组合式函数封装
   - 复杂数据同步：Pinia + 自定义插件

3. **性能优化**：
   - 状态分片：Pinia的模块化设计
   - 按需加载：Pinia支持动态导入store

4. **开发体验**：
   - 调试需求：Pinia与Vue DevTools深度集成
   - 类型安全：Pinia提供完整的TypeScript支持

### 状态管理方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **Pinia** | - 官方推荐<br>- 完整的TypeScript支持<br>- 模块化设计<br>- DevTools集成<br>- 插件系统 | - 对小型项目可能过重<br>- 需要额外学习成本 | - 中大型应用<br>- 需要良好开发体验<br>- 团队协作项目 |
| **VueUse** | - 轻量级<br>- 组合式API风格<br>- 丰富的工具函数<br>- 可按需导入 | - 不是完整的状态管理解决方案<br>- 缺乏集中式的状态管理 | - 小型应用<br>- 特定功能模块<br>- 与其他方案配合使用 |
| **provide/inject** | - Vue内置功能<br>- 无需额外依赖<br>- 适合组件树状态共享 | - 不适合全局状态<br>- 调试困难<br>- 缺乏状态管理工具 | - 组件库开发<br>- 局部状态共享<br>- 简单应用 |
| **组合式函数** | - 高度定制化<br>- 与Vue3完美契合<br>- 可复用性强 | - 需要自行实现状态共享<br>- 缺乏标准化 | - 特定业务逻辑<br>- 需要高度定制<br>- 作为补充方案 |
| **自定义状态管理** | - 完全控制实现细节<br>- 可根据需求定制<br>- 无冗余功能 | - 开发成本高<br>- 维护负担重<br>- 缺乏社区支持 | - 特殊需求项目<br>- 有经验的团队<br>- 对尺寸有严格要求 |

### 最佳实践建议

无论选择哪种状态管理方案，以下最佳实践可以帮助提高代码质量和可维护性：

1. **状态分层**：
   - 将UI状态与业务状态分离
   - 将本地状态与共享状态分离
   - 将临时状态与持久状态分离

2. **模块化设计**：
   - 按功能域划分状态模块
   - 避免状态模块之间的循环依赖
   - 保持状态模块的单一职责

3. **类型安全**：
   - 为状态定义清晰的类型
   - 利用TypeScript提高代码质量
   - 避免使用`any`类型

4. **测试友好**：
   - 设计易于测试的状态逻辑
   - 避免状态管理中的副作用
   - 使用依赖注入简化测试

5. **性能优化**：
   - 避免过度响应式
   - 合理使用计算属性缓存
   - 考虑大型集合的性能影响

## 总结

Vue3生态提供了丰富多样的状态管理解决方案，从官方推荐的Pinia，到实用工具集VueUse，再到基于Vue3新特性的轻量级状态管理方案。这些工具各有优势，可以根据项目需求灵活选择。

Pinia作为Vue官方推荐的状态管理库，提供了简洁的API、完整的TypeScript支持和良好的开发体验，适合中大型应用。VueUse提供了丰富的响应式工具和状态管理相关函数，可以作为轻量级解决方案或与其他方案配合使用。而基于Vue3响应式API的自定义状态管理方案，则提供了最大的灵活性和定制化能力。

在实际开发中，可以根据项目规模、复杂度和特定需求，选择合适的状态管理方案，甚至在同一个项目中组合使用多种方案。无论选择哪种方案，遵循状态分层、模块化设计、类型安全、测试友好和性能优化的最佳实践，都能帮助构建高质量、可维护的Vue应用。
---
title: æŒä¹…åŒ–ä¸æ’ä»¶
icon: plugin
order: 5
---

# æŒä¹…åŒ–ä¸æ’ä»¶

## æ’ä»¶ç³»ç»ŸåŸºç¡€

### åŸºç¡€æ’ä»¶å®šä¹‰

```typescript:c:\project\kphub\src\stores\plugins\basicPlugin.ts
import { PiniaPluginContext } from 'pinia'

export function basicPlugin({ store, options }: PiniaPluginContext) {
  // æ‰©å±•storeå±æ€§
  store.$state.lastUpdated = new Date()

  // æ·»åŠ æ–°æ–¹æ³•
  store.$reset = function() {
    store.$patch((state) => {
      Object.assign(state, options.state())
    })
  }

  // è®¢é˜…çŠ¶æ€å˜æ›´
  store.$subscribe((mutation, state) => {
    console.log('çŠ¶æ€å˜æ›´:', {
      type: mutation.type,
      storeId: mutation.storeId,
      payload: mutation.payload
    })
  })

  return { someProperty: 'value' }
}

// æ³¨å†Œæ’ä»¶
import { createPinia } from 'pinia'
const pinia = createPinia()
pinia.use(basicPlugin)
```

## çŠ¶æ€æŒä¹…åŒ–

### LocalStorageæŒä¹…åŒ–å®ç°

```typescript:c:\project\kphub\src\stores\plugins\persistencePlugin.ts
import { PiniaPluginContext } from 'pinia'
import { watch } from 'vue'

interface PersistOptions {
  key?: string
  paths?: string[]
  storage?: Storage
}

export function createPersistPlugin(globalOptions: PersistOptions = {}) {
  return ({ store, options }: PiniaPluginContext) => {
    const {
      key = store.$id,
      paths = null,
      storage = localStorage
    } = globalOptions

    // æ¢å¤çŠ¶æ€
    const savedState = storage.getItem(key)
    if (savedState) {
      store.$patch(JSON.parse(savedState))
    }

    // ç›‘å¬çŠ¶æ€å˜åŒ–
    watch(
      () => store.$state,
      (state) => {
        const saveState = paths
          ? paths.reduce((obj, path) => {
              obj[path] = state[path]
              return obj
            }, {})
          : state

        storage.setItem(key, JSON.stringify(saveState))
      },
      { deep: true }
    )
  }
}

// IndexedDBé€‚é…å™¨
class IndexedDBStorage {
  private dbName: string
  private storeName: string

  constructor(dbName = 'piniaStore', storeName = 'states') {
    this.dbName = dbName
    this.storeName = storeName
  }

  async getItem(key: string): Promise<string | null> {
    const db = await this.openDB()
    const tx = db.transaction(this.storeName, 'readonly')
    const store = tx.objectStore(this.storeName)
    const result = await store.get(key)
    return result || null
  }

  async setItem(key: string, value: string): Promise<void> {
    const db = await this.openDB()
    const tx = db.transaction(this.storeName, 'readwrite')
    const store = tx.objectStore(this.storeName)
    await store.put(value, key)
  }

  private async openDB(): Promise<IDBDatabase> {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1)

      request.onerror = () => reject(request.error)
      request.onsuccess = () => resolve(request.result)

      request.onupgradeneeded = (event) => {
        const db = (event.target as IDBOpenDBRequest).result
        db.createObjectStore(this.storeName)
      }
    })
  }
}
```

## å¸¸ç”¨æ’ä»¶å¼€å‘

### æ—¥å¿—è®°å½•æ’ä»¶

```typescript:c:\project\kphub\src\stores\plugins\loggerPlugin.ts
import { PiniaPluginContext } from 'pinia'

interface LogOptions {
  enabled?: boolean
  filter?: (mutation: any) => boolean
  actionFilter?: (action: string) => boolean
  logger?: typeof console
}

export function createLogger(options: LogOptions = {}) {
  const {
    enabled = true,
    filter = () => true,
    actionFilter = () => true,
    logger = console
  } = options

  return ({ store }: PiniaPluginContext) => {
    if (!enabled) return

    // çŠ¶æ€å˜æ›´æ—¥å¿—
    store.$subscribe((mutation, state) => {
      if (!filter(mutation)) return

      logger.group(`ğŸª ${store.$id} - ${mutation.type}`)
      logger.log('prev state:', mutation.oldState)
      logger.log('payload:', mutation.payload)
      logger.log('next state:', state)
      logger.groupEnd()
    })

    // Actionæ‰§è¡Œæ—¥å¿—
    const originalActions = {} as Record<string, Function>

    for (const action in store) {
      if (typeof store[action] === 'function') {
        originalActions[action] = store[action]
        store[action] = async function(...args: any[]) {
          if (!actionFilter(action)) {
            return originalActions[action].apply(this, args)
          }

          logger.group(`ğŸ¬ ${store.$id} - ${action}`)
          logger.log('args:', args)
          logger.time(action)

          try {
            const result = await originalActions[action].apply(this, args)
            logger.log('result:', result)
            return result
          } catch (error) {
            logger.error('error:', error)
            throw error
          } finally {
            logger.timeEnd(action)
            logger.groupEnd()
          }
        }
      }
    }
  }
}
```

## é«˜çº§æ’ä»¶æŠ€å·§

### çŠ¶æ€åŒæ­¥æ’ä»¶

```typescript:c:\project\kphub\src\stores\plugins\syncPlugin.ts
import { PiniaPluginContext } from 'pinia'
import { ref, watch } from 'vue'

interface SyncOptions {
  syncKey?: string
  broadcastChannel?: string
  storage?: Storage
}

export function createSyncPlugin(options: SyncOptions = {}) {
  const {
    syncKey = 'pinia-sync',
    broadcastChannel = 'pinia-sync-channel',
    storage = sessionStorage
  } = options

  const channel = new BroadcastChannel(broadcastChannel)
  const syncInProgress = ref(false)

  return ({ store }: PiniaPluginContext) => {
    // ç›‘å¬å…¶ä»–æ ‡ç­¾é¡µçš„æ›´æ–°
    channel.onmessage = (event) => {
      if (event.data.storeId === store.$id) {
        syncInProgress.value = true
        store.$patch(event.data.state)
        syncInProgress.value = false
      }
    }

    // ç›‘å¬æœ¬åœ°æ›´æ–°å¹¶å¹¿æ’­
    watch(
      () => store.$state,
      (state) => {
        if (!syncInProgress.value) {
          channel.postMessage({
            storeId: store.$id,
            state
          })

          // åŒæ­¥åˆ°storage
          storage.setItem(
            `${syncKey}-${store.$id}`,
            JSON.stringify({
              timestamp: Date.now(),
              state
            })
          )
        }
      },
      { deep: true }
    )

    // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥storage
    const savedSync = storage.getItem(`${syncKey}-${store.$id}`)
    if (savedSync) {
      const { timestamp, state } = JSON.parse(savedSync)
      if (Date.now() - timestamp < 30000) { // 30ç§’å†…çš„æ•°æ®è§†ä¸ºæœ‰æ•ˆ
        store.$patch(state)
      }
    }

    // æ¸…ç†å‡½æ•°
    return () => {
      channel.close()
    }
  }
}
```

Piniaæ’ä»¶ç³»ç»Ÿçš„æ ¸å¿ƒæ¦‚å¿µåŒ…æ‹¬ï¼š

1. æ’ä»¶åŸºç¡€ï¼š
   - æ’ä»¶å®šä¹‰
   - çŠ¶æ€æ‰©å±•
   - åŠŸèƒ½æ³¨å…¥
   - ç”Ÿå‘½å‘¨æœŸ

2. æŒä¹…åŒ–ï¼š
   - æœ¬åœ°å­˜å‚¨
   - ä¼šè¯å­˜å‚¨
   - æ•°æ®åº“å­˜å‚¨
   - è‡ªå®šä¹‰å­˜å‚¨

3. å¸¸ç”¨æ’ä»¶ï¼š
   - æ—¥å¿—è®°å½•
   - çŠ¶æ€é‡ç½®
   - ç¼“å­˜ç®¡ç†
   - æ•°æ®åŒæ­¥

4. é«˜çº§ç‰¹æ€§ï¼š
   - å±æ€§æ‰©å±•
   - æ–¹æ³•åŒ…è£…
   - çŠ¶æ€è®¢é˜…
   - ç³»ç»Ÿé›†æˆ

```mermaid
graph TD
    A[Piniaæ’ä»¶] --> B[åŸºç¡€åŠŸèƒ½]
    A --> C[æŒä¹…åŒ–]
    A --> D[å¸¸ç”¨æ’ä»¶]
    A --> E[é«˜çº§ç‰¹æ€§]
    
    B --> F[æ’ä»¶å®šä¹‰]
    B --> G[åŠŸèƒ½æ³¨å…¥]
    
    C --> H[æœ¬åœ°å­˜å‚¨]
    C --> I[æ•°æ®åº“]
    
    D --> J[æ—¥å¿—]
    D --> K[åŒæ­¥]
    
    E --> L[æ‰©å±•]
    E --> M[é›†æˆ]
```

ä½¿ç”¨å»ºè®®ï¼š

1. åŸºç¡€ä½¿ç”¨ï¼š
   - ç†è§£æ’ä»¶æœºåˆ¶
   - é€‰æ‹©å­˜å‚¨æ–¹å¼
   - å®ç°åŸºæœ¬åŠŸèƒ½
   - å¤„ç†å¼‚å¸¸æƒ…å†µ

2. è¿›é˜¶æŠ€å·§ï¼š
   - ä¼˜åŒ–æ€§èƒ½
   - æ‰©å±•åŠŸèƒ½
   - çŠ¶æ€åŒæ­¥
   - è°ƒè¯•æ”¯æŒ

3. æœ€ä½³å®è·µï¼š
   - æ¨¡å—åŒ–è®¾è®¡
   - é”™è¯¯å¤„ç†
   - ç±»å‹æ”¯æŒ
   - æµ‹è¯•ç­–ç•¥

é€šè¿‡åˆç†ä½¿ç”¨Piniaçš„æ’ä»¶ç³»ç»Ÿï¼Œæˆ‘ä»¬å¯ä»¥æ‰©å±•çŠ¶æ€ç®¡ç†çš„èƒ½åŠ›ï¼Œå®ç°æ›´å¼ºå¤§çš„åŠŸèƒ½ã€‚
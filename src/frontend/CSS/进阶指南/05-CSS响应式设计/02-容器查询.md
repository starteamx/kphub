---
title: CSS容器查询
icon: code
order: 2
---

# CSS容器查询

## 概述

CSS 容器查询是响应式设计的革命性进步，它允许开发者基于父容器的尺寸而非视口尺寸来应用样式。本文将详细介绍容器查询的基本概念、语法、实际应用场景以及最佳实践，帮助您创建更加灵活和可复用的组件。

## 目录

- [基本概念](#基本概念)
- [容器查询语法](#容器查询语法)
- [实际应用](#实际应用)
- [高级技巧](#高级技巧)
- [浏览器兼容性](#浏览器兼容性)
- [最佳实践](#最佳实践)
- [参考资源](#参考资源)

## 基本概念

### 什么是容器查询

容器查询允许开发者根据父容器的尺寸（而非整个视口的尺寸）来应用 CSS 样式。这意味着同一组件可以根据其所在容器的大小自动调整其布局和样式，而不受页面整体布局的影响。

### 容器查询与媒体查询的区别

| 特性 | 容器查询 | 媒体查询 |
|------|---------|---------|
| 响应基准 | 父容器尺寸 | 视口尺寸 |
| 组件复用性 | 高（同一组件可在不同大小的容器中自适应） | 低（组件样式与视口绑定） |
| 上下文感知 | 是（组件知道其容器环境） | 否（组件只知道视口大小） |
| 嵌套组件 | 更适合处理 | 处理复杂 |

### 容器查询的优势

1. **提高组件复用性**：同一组件可以在不同大小的容器中自动调整布局
2. **简化响应式设计**：无需为每个视口尺寸编写媒体查询
3. **更精确的上下文响应**：组件可以根据其直接父容器做出响应
4. **减少级联影响**：组件样式更加独立，减少全局样式的影响

## 容器查询语法

### 定义容器

要使用容器查询，首先需要将元素定义为容器：

```css
/* 定义内联容器（仅考虑宽度） */
.card-container {
  container-type: inline-size;
}

/* 定义块级容器（考虑宽度和高度） */
.full-container {
  container-type: size;
}

/* 定义容器并命名 */
.sidebar {
  container-type: inline-size;
  container-name: sidebar;
}

/* 简写语法 */
.main-content {
  container: content-area / inline-size;
}
```

### 查询容器

一旦定义了容器，就可以使用 `@container` 规则来查询容器尺寸：

```css
/* 基于无名容器（最近的祖先容器）查询 */
@container (min-width: 400px) {
  .card {
    display: flex;
    flex-direction: row;
  }
}

/* 基于命名容器查询 */
@container sidebar (max-width: 300px) {
  .widget {
    font-size: 0.8rem;
  }
}

/* 使用逻辑操作符 */
@container (min-width: 400px) and (max-width: 700px) {
  .card-title {
    font-size: 1.2rem;
  }
}
```

### 容器查询单位

CSS 容器查询引入了新的相对单位，它们相对于查询容器的尺寸：

```css
.responsive-element {
  /* 相对于容器宽度的百分比 */
  font-size: 5cqw;
  
  /* 相对于容器高度的百分比 */
  margin-top: 2cqh;
  
  /* 相对于容器宽度或高度中较小值的百分比 */
  padding: 1cqi;
  
  /* 相对于容器宽度或高度中较大值的百分比 */
  border-radius: 0.5cqb;
  
  /* 相对于容器宽度和高度的几何平均值的百分比 */
  margin-bottom: 2cqmin;
  
  /* 相对于容器宽度和高度的算术平均值的百分比 */
  width: 10cqmax;
}
```

## 实际应用

### 1. 响应式卡片组件

```html
<div class="card-container">
  <div class="card">
    <img src="image.jpg" alt="Card image" class="card-image">
    <div class="card-content">
      <h3 class="card-title">卡片标题</h3>
      <p class="card-description">卡片描述文本...</p>
    </div>
  </div>
</div>
```

```css
.card-container {
  container-type: inline-size;
}

.card {
  display: flex;
  flex-direction: column;
  border: 1px solid #ddd;
  border-radius: 8px;
  overflow: hidden;
}

.card-image {
  width: 100%;
  height: auto;
  object-fit: cover;
}

/* 当容器宽度大于等于 500px 时 */
@container (min-width: 500px) {
  .card {
    flex-direction: row;
  }
  
  .card-image {
    width: 40%;
  }
  
  .card-content {
    width: 60%;
    padding: 20px;
  }
}

/* 当容器宽度小于 300px 时 */
@container (max-width: 300px) {
  .card-title {
    font-size: 1rem;
  }
  
  .card-description {
    font-size: 0.8rem;
  }
}
```

### 2. 自适应导航菜单

```html
<div class="nav-container">
  <nav class="navbar">
    <div class="logo">Logo</div>
    <ul class="nav-links">
      <li><a href="#">首页</a></li>
      <li><a href="#">关于</a></li>
      <li><a href="#">服务</a></li>
      <li><a href="#">联系</a></li>
    </ul>
  </nav>
</div>
```

```css
.nav-container {
  container-type: inline-size;
  container-name: navbar;
}

.navbar {
  display: flex;
  flex-direction: column;
  padding: 10px;
}

.nav-links {
  display: flex;
  flex-direction: column;
  list-style: none;
  padding: 0;
  margin: 0;
}

/* 当导航容器宽度大于等于 600px 时 */
@container navbar (min-width: 600px) {
  .navbar {
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
  }
  
  .nav-links {
    flex-direction: row;
  }
  
  .nav-links li {
    margin-left: 20px;
  }
}
```

### 3. 自适应网格布局

```html
<div class="grid-container">
  <div class="grid">
    <div class="grid-item">项目 1</div>
    <div class="grid-item">项目 2</div>
    <div class="grid-item">项目 3</div>
    <div class="grid-item">项目 4</div>
    <div class="grid-item">项目 5</div>
    <div class="grid-item">项目 6</div>
  </div>
</div>
```

```css
.grid-container {
  container-type: inline-size;
}

.grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 20px;
}

.grid-item {
  background-color: #f0f0f0;
  padding: 20px;
  border-radius: 8px;
}

/* 当容器宽度大于等于 400px 时 */
@container (min-width: 400px) {
  .grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

/* 当容器宽度大于等于 700px 时 */
@container (min-width: 700px) {
  .grid {
    grid-template-columns: repeat(3, 1fr);
  }
}
```

## 高级技巧

### 1. 嵌套容器查询

容器查询可以嵌套使用，创建多层次的响应式设计：

```html
<div class="outer-container">
  <div class="inner-container">
    <div class="component">内容</div>
  </div>
</div>
```

```css
.outer-container {
  container-type: inline-size;
  container-name: outer;
}

.inner-container {
  container-type: inline-size;
  container-name: inner;
}

/* 基于外层容器的查询 */
@container outer (min-width: 800px) {
  .inner-container {
    padding: 20px;
  }
}

/* 基于内层容器的查询 */
@container inner (min-width: 400px) {
  .component {
    display: flex;
  }
}
```

### 2. 结合媒体查询和容器查询

媒体查询和容器查询可以结合使用，创建更复杂的响应式设计：

```css
/* 首先基于视口设置基础布局 */
@media (min-width: 768px) {
  .layout {
    display: grid;
    grid-template-columns: 1fr 3fr;
  }
}

/* 然后基于容器调整组件样式 */
.component-container {
  container-type: inline-size;
}

@container (min-width: 300px) {
  .component {
    display: flex;
  }
}
```

### 3. 使用容器查询单位创建流体排版

```css
.container {
  container-type: inline-size;
}

.fluid-text {
  /* 基础字体大小 */
  font-size: 1rem;
  
  /* 流体字体大小，随容器宽度变化 */
  font-size: clamp(1rem, 0.5rem + 2cqw, 2rem);
}

.fluid-spacing {
  /* 流体间距 */
  padding: clamp(1rem, 0.5rem + 1cqi, 3rem);
}
```

## 浏览器兼容性

### 支持情况

| 浏览器 | 版本支持 |
|------|---------|
| Chrome | 105+ |
| Firefox | 110+ |
| Safari | 16+ |
| Edge | 105+ |
| Opera | 91+ |

### 兼容性处理

对于不支持容器查询的浏览器，可以采用以下策略：

1. **渐进增强**：先提供基础样式，然后使用 `@supports` 检测容器查询支持：

```css
/* 基础样式（所有浏览器） */
.card {
  display: flex;
  flex-direction: column;
}

/* 检测容器查询支持 */
@supports (container-type: inline-size) {
  .card-container {
    container-type: inline-size;
  }
  
  @container (min-width: 500px) {
    .card {
      flex-direction: row;
    }
  }
}
```

2. **使用 JavaScript 回退方案**：

```javascript
// 检测容器查询支持
if (!CSS.supports('container-type', 'inline-size')) {
  // 添加基于元素宽度的类
  const resizeObserver = new ResizeObserver(entries => {
    for (let entry of entries) {
      const width = entry.contentRect.width;
      entry.target.classList.remove('container-small', 'container-medium', 'container-large');
      
      if (width < 300) {
        entry.target.classList.add('container-small');
      } else if (width < 600) {
        entry.target.classList.add('container-medium');
      } else {
        entry.target.classList.add('container-large');
      }
    }
  });
  
  // 观察所有容器
  document.querySelectorAll('.card-container').forEach(container => {
    resizeObserver.observe(container);
  });
}
```

## 最佳实践

### 1. 组件优先设计

容器查询特别适合组件优先的设计方法：

```css
/* 定义组件容器 */
.component-wrapper {
  container-type: inline-size;
}

/* 组件基础样式 */
.component {
  /* 默认样式（小容器） */
}

/* 组件响应式变体 */
@container (min-width: 400px) {
  .component {
    /* 中等容器样式 */
  }
}

@container (min-width: 700px) {
  .component {
    /* 大容器样式 */
  }
}
```

### 2. 明智地选择容器类型

- 使用 `container-type: inline-size` 当只需要响应宽度变化时
- 使用 `container-type: size` 当需要响应宽度和高度变化时
- 注意 `size` 类型会影响性能，因为它需要监控两个维度的变化

### 3. 避免容器查询循环

容器查询可能导致布局循环，特别是当查询结果改变容器大小时：

```css
/* 可能导致循环的代码 */
.container {
  container-type: inline-size;
}

@container (min-width: 500px) {
  .container {
    width: 400px; /* 这会改变容器宽度，可能导致循环 */
  }
}
```

### 4. 结合使用容器查询和 CSS 网格

容器查询与 CSS 网格配合使用效果很
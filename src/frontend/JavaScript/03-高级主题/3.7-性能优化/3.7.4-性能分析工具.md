---
title: 性能分析工具
icon: javascript
order: 4
---

# 性能分析工具

性能分析工具帮助您识别和解决性能瓶颈。本文将介绍Chrome DevTools、Lighthouse、WebPageTest等性能分析工具的使用方法，以及如何解读性能指标，进行有针对性的优化。

## 1. Chrome DevTools

Chrome DevTools 是前端开发者最常用的性能分析工具之一，内置于Chrome浏览器中，提供了丰富的性能分析功能。

### 1.1 Performance 面板

Performance 面板可以记录和分析网页在运行时的所有活动。

#### 1.1.1 基本使用

1. 打开 Chrome DevTools (Mac: `Cmd + Option + I` 或 Windows: `F12`)
2. 切换到 Performance 面板
3. 点击 Record 按钮开始记录
4. 在页面上执行需要分析的操作
5. 点击 Stop 按钮停止记录

![Performance 面板](/assets/images/chrome-devtools-performance.png)

#### 1.1.2 分析性能记录

Performance 面板记录的内容包括：

- **FPS**：每秒帧数，用于评估动画流畅度
- **CPU**：CPU资源使用情况
- **NET**：网络请求
- **HEAP**：JavaScript堆内存使用情况
- **Main**：主线程活动
- **Frames**：每一帧的渲染情况

```javascript
// 使用Performance API手动标记性能记录点
// 在代码中添加性能标记
performance.mark('functionStart');

// 执行需要测量的代码
expensiveFunction();

// 添加结束标记
performance.mark('functionEnd');

// 创建性能测量
performance.measure(
  'functionDuration',
  'functionStart',
  'functionEnd'
);

// 获取测量结果
const measurements = performance.getEntriesByName('functionDuration');
console.log(`函数执行时间: ${measurements[0].duration}ms`);

// 清理标记
performance.clearMarks();
performance.clearMeasures();
```

### 1.2 Network 面板

Network 面板用于分析网络请求和响应。

#### 1.2.1 基本使用

1. 打开 Chrome DevTools
2. 切换到 Network 面板
3. 刷新页面或执行操作，观察网络请求

![Network 面板](/assets/images/chrome-devtools-network.png)

#### 1.2.2 分析网络请求

Network 面板提供的信息包括：

- **Waterfall**：请求时间线
- **Size**：资源大小和传输大小
- **Time**：请求总时间
- **Priority**：请求优先级
- **Initiator**：请求发起者

```javascript
// 使用Resource Timing API分析资源加载性能
function analyzeResourceTiming() {
  // 获取所有资源的性能数据
  const resources = performance.getEntriesByType('resource');
  
  // 按资源类型分组
  const resourcesByType = {};
  resources.forEach(resource => {
    const type = resource.initiatorType || 'other';
    if (!resourcesByType[type]) {
      resourcesByType[type] = [];
    }
    resourcesByType[type].push(resource);
  });
  
  // 分析每种资源类型
  for (const type in resourcesByType) {
    const items = resourcesByType[type];
    const totalSize = items.reduce((sum, item) => sum + (item.transferSize || 0), 0);
    const avgDuration = items.reduce((sum, item) => sum + item.duration, 0) / items.length;
    
    console.log(`${type} (${items.length}个):`);
    console.log(`- 总大小: ${(totalSize / 1024).toFixed(2)} KB`);
    console.log(`- 平均加载时间: ${avgDuration.toFixed(2)} ms`);
  }
}
```

### 1.3 Memory 面板

Memory 面板用于分析内存使用情况和检测内存泄漏。

#### 1.3.1 基本使用

1. 打开 Chrome DevTools
2. 切换到 Memory 面板
3. 选择分析类型（Heap Snapshot、Allocation Instrumentation on Timeline、Allocation Sampling）
4. 点击 "Take snapshot" 或 "Start" 按钮

![Memory 面板](/assets/images/chrome-devtools-memory.png)

#### 1.3.2 检测内存泄漏

```javascript
// 内存泄漏示例
function createMemoryLeak() {
  const leaks = [];
  
  // 创建一个定时器，不断向数组添加对象
  setInterval(() => {
    const obj = {
      largeString: new Array(1000000).join('x'),
      date: new Date(),
      data: new Array(1000).fill(Math.random())
    };
    leaks.push(obj);
    
    // 输出当前内存使用情况
    if (window.performance && window.performance.memory) {
      const memory = window.performance.memory;
      console.log(`已用堆大小: ${(memory.usedJSHeapSize / 1048576).toFixed(2)} MB`);
      console.log(`堆大小限制: ${(memory.jsHeapSizeLimit / 1048576).toFixed(2)} MB`);
    }
  }, 1000);
}

// 内存泄漏修复示例
function fixedFunction() {
  // 使用局部变量，函数执行完毕后会被垃圾回收
  const temporaryData = {
    largeString: new Array(1000000).join('x'),
    date: new Date(),
    data: new Array(1000).fill(Math.random())
  };
  
  // 处理数据...
  processData(temporaryData);
  
  // 函数结束后，temporaryData会被垃圾回收
}
```

### 1.4 Lighthouse 面板

Lighthouse 是 Chrome DevTools 中内置的性能审计工具。

#### 1.4.1 基本使用

1. 打开 Chrome DevTools
2. 切换到 Lighthouse 面板
3. 选择要分析的类别（Performance、Accessibility、Best Practices、SEO、PWA）
4. 点击 "Generate report" 按钮

![Lighthouse 面板](/assets/images/chrome-devtools-lighthouse.png)

## 2. Lighthouse

Lighthouse 是 Google 开发的开源自动化工具，用于改进网页质量。

### 2.1 使用方式

#### 2.1.1 通过 Chrome DevTools 使用

如上节所述，可以直接在 Chrome DevTools 中使用 Lighthouse。

#### 2.1.2 通过命令行使用

```bash
# 安装 Lighthouse
npm install -g lighthouse

# 运行 Lighthouse 分析
lighthouse https://example.com --view
```

#### 2.1.3 通过 Node.js API 使用

```javascript
const lighthouse = require('lighthouse');
const chromeLauncher = require('chrome-launcher');

async function runLighthouse(url) {
  // 启动 Chrome
  const chrome = await chromeLauncher.launch({
    chromeFlags: ['--headless']
  });
  
  // 运行 Lighthouse
  const options = {
    logLevel: 'info',
    output: 'html',
    port: chrome.port
  };
  
  const runnerResult = await lighthouse(url, options);
  
  // 关闭 Chrome
  await chrome.kill();
  
  // 处理结果
  const reportHtml = runnerResult.report;
  const lhr = runnerResult.lhr;
  
  console.log(`Performance score: ${lhr.categories.performance.score * 100}`);
  console.log(`First Contentful Paint: ${lhr.audits['first-contentful-paint'].displayValue}`);
  console.log(`Time to Interactive: ${lhr.audits['interactive'].displayValue}`);
  
  // 保存报告
  const fs = require('fs');
  fs.writeFileSync('lighthouse-report.html', reportHtml);
}

runLighthouse('https://example.com');
```

### 2.2 性能指标解读

Lighthouse 报告包含多个关键性能指标：

#### 2.2.1 Core Web Vitals

- **Largest Contentful Paint (LCP)**：最大内容绘制，衡量加载性能
  - 良好：≤ 2.5 秒
  - 需要改进：2.5 秒 - 4 秒
  - 较差：> 4 秒

- **First Input Delay (FID)**：首次输入延迟，衡量交互性能
  - 良好：≤ 100 毫秒
  - 需要改进：100 - 300 毫秒
  - 较差：> 300 毫秒

- **Cumulative Layout Shift (CLS)**：累积布局偏移，衡量视觉稳定性
  - 良好：≤ 0.1
  - 需要改进：0.1 - 0.25
  - 较差：> 0.25

#### 2.2.2 其他重要指标

- **First Contentful Paint (FCP)**：首次内容绘制
- **Speed Index**：速度指数
- **Time to Interactive (TTI)**：可交互时间
- **Total Blocking Time (TBT)**：总阻塞时间

### 2.3 优化建议

Lighthouse 报告会提供具体的优化建议，例如：

- 消除阻塞渲染的资源
- 适当大小的图片
- 延迟加载离屏图片
- 减少未使用的 JavaScript
- 减少主线程工作
- 使用高效的缓存策略

```javascript
// 根据 Lighthouse 建议优化图片
function optimizeImages() {
  // 使用 loading="lazy" 延迟加载离屏图片
  const images = document.querySelectorAll('img:not([loading])');
  images.forEach(img => {
    if (!isInViewport(img)) {
      img.setAttribute('loading', 'lazy');
    }
  });
  
  // 检查图片是否在视口内
  function isInViewport(element) {
    const rect = element.getBoundingClientRect();
    return (
      rect.top >= 0 &&
      rect.left >= 0 &&
      rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
      rect.right <= (window.innerWidth || document.documentElement.clientWidth)
    );
  }
}
```

## 3. WebPageTest

WebPageTest 是一个强大的第三方性能测试工具，可以从全球多个位置使用真实浏览器测试网页性能。

### 3.1 基本使用

1. 访问 [WebPageTest.org](https://www.webpagetest.org/)
2. 输入要测试的 URL
3. 选择测试位置和浏览器
4. 配置高级设置（如连接速度、重复测试次数等）
5. 点击 "Start Test" 按钮

![WebPageTest](/assets/images/webpagetest.png)

### 3.2 测试结果解读

WebPageTest 提供详细的测试结果，包括：

- **Waterfall Chart**：请求瀑布图
- **First View vs. Repeat View**：首次访问与重复访问对比
- **Content Breakdown**：内容类型分布
- **Request Details**：请求详情
- **Performance Metrics**：性能指标

### 3.3 使用 API 自动化测试

```javascript
const fetch = require('node-fetch');

async function runWebPageTest(url, apiKey) {
  // 发起测试请求
  const testUrl = `https://www.webpagetest.org/runtest.php?url=${encodeURIComponent(url)}&k=${apiKey}&f=json`;
  const response = await fetch(testUrl);
  const data = await response.json();
  
  if (data.statusCode !== 200) {
    throw new Error(`测试请求失败: ${data.statusText}`);
  }
  
  // 获取测试ID
  const testId = data.data.testId;
  console.log(`测试已提交，ID: ${testId}`);
  
  // 等待测试完成
  let results = null;
  let status = 'Running';
  
  while (status !== 'Complete') {
    // 等待10秒
    await new Promise(resolve => setTimeout(resolve, 10000));
    
    // 检查测试状态
    const statusUrl = `https://www.webpagetest.org/testStatus.php?test=${testId}&f=json`;
    const statusResponse = await fetch(statusUrl);
    const statusData = await statusResponse.json();
    
    status = statusData.data.statusText;
    console.log(`测试状态: ${status}`);
    
    if (status === 'Complete') {
      // 获取测试结果
      const resultsUrl = `https://www.webpagetest.org/jsonResult.php?test=${testId}`;
      const resultsResponse = await fetch(resultsUrl);
      results = await resultsResponse.json();
    }
  }
  
  // 分析结果
  const firstView = results.data.runs['1'].firstView;
  
  console.log('性能指标:');
  console.log(`- 首次内容绘制: ${firstView.firstContentfulPaint} ms`);
  console.log(`- 速度指数: ${firstView.SpeedIndex} ms`);
  console.log(`- 文档完成时间: ${firstView.docTime} ms`);
  console.log(`- 完全加载时间: ${firstView.loadTime} ms`);
  console.log(`- 总请求数: ${firstView.requests}`);
  console.log(`- 总字节数: ${(firstView.bytesIn / 1024).toFixed(2)} KB`);
  
  return results;
}

// 使用示例
// runWebPageTest('https://example.com', 'YOUR_API_KEY');
```

## 4. 性能监控工具

除了一次性的性能分析工具外，持续的性能监控也非常重要。

### 4.1 Google Analytics

Google Analytics 可以用来监控网站的性能指标，特别是通过其用户计时功能。

```javascript
// 使用 Google Analytics 监控性能指标
function sendPerformanceMetricsToGA() {
  // 确保 Google Analytics 已加载
  if (typeof ga === 'function') {
    // 获取导航计时数据
    const perfData = window.performance.timing;
    const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
    
    // 发送页面加载时间
    ga('send', 'timing', {
      'timingCategory': 'Performance',
      'timingVar': 'load',
      'timingValue': pageLoadTime
    });
    
    // 发送首次内容绘制时间
    const paintMetrics = performance.getEntriesByType('paint');
    const fcpEntry = paintMetrics.find(entry => entry.name === 'first-contentful-paint');
    
    if (fcpEntry) {
      ga('send', 'timing', {
        'timingCategory': 'Performance',
        'timingVar': 'first-contentful-paint',
        'timingValue': Math.round(fcpEntry.startTime)
      });
    }
  }
}

// 页面加载完成后发送性能指标
window.addEventListener('load', () => {
  // 延迟发送，确保所有指标都已计算完成
  setTimeout(sendPerformanceMetricsToGA, 0);
});
```

### 4.2 Web Vitals

Web Vitals 是 Google 提供的一个小型库，用于测量核心 Web 指标。

```javascript
// 安装 web-vitals
// npm install web-vitals

// 使用 web-vitals 监控核心指标
import {getCLS, getFID, getLCP} from 'web-vitals';

function sendToAnalytics(metric) {
  // 构造分析数据
  const body = {
    name: metric.name,
    value: metric.value,
    id: metric.id,
    delta: metric.delta,
    rating: metric.rating, // 'good', 'needs-improvement', 或 'poor'
    navigationType: performance.getEntriesByType('navigation')[0]?.type || 'navigate'
  };
  
  // 发送到分析服务器
  console.log('发送性能指标:', body);
  
  // 实际发送代码
  fetch('/analytics', {
    method: 'POST',
    body: JSON.stringify(body),
    headers: {'Content-Type': 'application/json'}
  });
}

// 监控 CLS
getCLS(sendToAnalytics);

// 监控 FID
getFID(sendToAnalytics);

// 监控 LCP
getLCP(sendToAnalytics);
```

### 4.3 自定义性能监控

创建自定义性能监控系统，以满足特定需求。

```javascript
// 自定义性能监控类
class PerformanceMonitor {
  constructor(options = {}) {
    this.options = {
      sampleRate: 0.1, // 采样率，默认10%
      endpoint: '/performance',
      ...options
    };
    
    this.metrics = {
      navigation: {},
      resources: [],
      userInteractions: [],
      jsErrors: [],
      vitals: {}
    };
    
    // 决定是否采样此会话
    this.shouldSample = Math.random() < this.options.sampleRate;
    
    if (this.shouldSample) {
      this.initMonitoring();
    }
  }
  
  initMonitoring() {
    // 监控页面加载性能
    window.addEventListener('load', this.captureNavigationTiming.bind(this));
    
    // 监控资源加载性能
    this.observeResourceTiming();
    
    // 监控用户交互
    this.observeUserInteractions();
    
    // 监控JavaScript错误
    this.observeJSErrors();
    
    // 监控核心Web指标
    this.observeWebVitals();
    
    // 定期发送数据
    setInterval(this.sendMetrics.bind(this), 10000); // 每10秒发送一次
    
    // 页面卸载前发送数据
    window.addEventListener('beforeunload', this.sendMetrics.bind(this));
  }
  
  captureNavigationTiming() {
    const perfData = performance.timing;
    const navStart = perfData.navigationStart;
    
    this.metrics.navigation = {
      dnsLookup: perfData.domainLookupEnd - perfData.domainLookupStart,
      tcpConnection: perfData.connectEnd - perfData.connectStart,
      serverResponse: perfData.responseEnd - perfData.requestStart,
      domParsing: perfData.domInteractive - perfData.responseEnd,
      resourceLoading: perfData.loadEventStart - perfData.domContentLoadedEventEnd,
      totalPageLoad: perfData.loadEventEnd - navStart
    };
    
    // 捕获绘制指标
    const paintEntries = performance.getEntriesByType('paint');
    paintEntries.forEach(entry => {
      this.metrics.navigation[entry.name] = entry.startTime;
    });
  }
  
  observeResourceTiming() {
    // 创建资源计时观察器
    const resourceObserver = new PerformanceObserver(list => {
      const entries = list.getEntries();
      
      entries.forEach(entry => {
        // 过滤掉分析请求本身
        if (!entry.name.includes(this.options.endpoint)) {
          this.metrics.resources.push({
            name: entry.name,
            type: entry.initiatorType,
            duration: entry.duration,
            size: entry.transferSize,
            startTime: entry.startTime
          });
        }
      });
    });
    
    resourceObserver.observe({ entryTypes: ['resource'] });
  }
  
  observeUserInteractions() {
    // 监听点击事件
    document.addEventListener('click', event => {
      const target = event.target;
      const tagName = target.tagName.toLowerCase();
      const id = target.id;
      const className = target.className;
      
      this.metrics.userInteractions.push({
        type: 'click',
        target: {
          tagName,
          id,
          className
        },
        timestamp: performance.now()
      });
    });
    
    // 监听表单提交
    document.addEventListener('submit', event => {
      const form = event.target;
      
      this.metrics.userInteractions.push({
        type: 'form_submit',
        target: {
          id: form.id,
          action: form.action
        },
        timestamp: performance.now()
      });
    });
  }
  
  observeJSErrors() {
    // 监听JavaScript错误
    window.addEventListener('error', event => {
      this.metrics.jsErrors.push({
        message: event.message,
        source: event.filename,
        line: event.lineno,
        column: event.colno,
        timestamp: performance.now()
      });
    });
    
    // 监听未捕获的Promise错误
    window.addEventListener('unhandledrejection', event => {
      this.metrics.jsErrors.push({
        message: event.reason?.message || 'Unhandled Promise Rejection',
        type: 'promise',
        timestamp: performance.now()
      });
    });
  }
  
  observeWebVitals() {
    // 如果web-vitals库可用，使用它来监控核心指标
    if (typeof getCLS === 'function') {
      getCLS(metric => {
        this.metrics.vitals.CLS = metric.value;
      });
      
      getFID(metric => {
        this.metrics.vitals.FID = metric.value;
      });
      
      getLCP(metric => {
        this.metrics.vitals.LCP = metric.value;
      });
    }
  }
  
  sendMetrics() {
    // 如果有数据要发送
    if (
      Object.keys(this.metrics.navigation).length > 0 ||
      this.metrics.resources.length > 0 ||
      this.metrics.userInteractions.length > 0 ||
      this.metrics.jsErrors.length > 0
    ) {
      // 添加用户和会话信息
      const payload = {
        ...this.metrics,
        timestamp: new Date().toISOString(),
        userAgent: navigator.userAgent,
        url: window.location.href,
        screenSize: {
          width: window.innerWidth,
          height: window.innerHeight
        }
      };
      
      // 使用Beacon API发送数据，不阻塞页面卸载
      if (navigator.sendBeacon) {
        navigator.sendBeacon(this.options.endpoint, JSON.stringify(payload));
      } else {
        // 回退到XHR
        const xhr = new XMLHttpRequest();
        xhr.open('POST', this.options.endpoint, true);
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.send(JSON.stringify(payload));
      }
      
      // 清空已发送的数据
      this.metrics.resources = [];
      this.metrics.userInteractions = [];
      this.metrics.jsErrors = [];
    }
  }
}

// 使用示例
const monitor = new PerformanceMonitor({
  sampleRate: 0.25, // 25%的用户会被监控
  endpoint: 'https://analytics.example.com/performance'
});
```

### 4.4 New Relic

New Relic 是一个全面的应用性能监控(APM)解决方案。

```javascript
// 安装 New Relic 浏览器代理
// 在HTML的<head>中添加以下脚本
/*
<script type="text/javascript">
window.NREUM||(NREUM={}),__nr_require=function(t,e,n){function r(n){if(!e[n]){var o=e[n]={exports:{}};t[n][0].call(o.exports,function(e){var o=t[n][1][e];return r(o||e)},o,o.exports)}return e[n].exports}if("function"==typeof __nr_require)return __nr_require;for(var o=0;o<n.length;o++)r(n[o]);return r}({...});
// New Relic 提供的初始化代码
</script>
*/

// 自定义性能指标
function sendCustomMetricsToNewRelic() {
  if (typeof newrelic !== 'undefined') {
    // 发送自定义计时
    newrelic.setCustomAttribute('customLoadTime', performance.now());
    
    // 记录自定义事件
    newrelic.addPageAction('userAction', {
      actionType: 'click',
      targetElement: 'submit-button',
      timestamp: new Date().getTime()
    });
    
    // 记录自定义指标
    newrelic.addToTrace({
      name: 'customOperation',
      start: performance.now(),
      end: performance.now() + 150,
      origin: 'customScript',
      type: 'customMetric'
    });
  }
}
```

## 5. 性能测试自动化

### 5.1 集成到CI/CD流程

将性能测试集成到持续集成/持续部署流程中。

```javascript
// package.json 示例
/*
{
  "scripts": {
    "test:performance": "lighthouse https://example.com --output json --output-path ./lighthouse-results.json --chrome-flags=\"--headless\" || true",
    "check:performance": "node ./scripts/check-performance.js"
  }
}
*/

// check-performance.js 示例
const fs = require('fs');

// 读取Lighthouse结果
const results = JSON.parse(fs.readFileSync('./lighthouse-results.json', 'utf8'));

// 性能预算
const budget = {
  performance: 0.8, // 80分以上
  'first-contentful-paint': 2000, // 2秒以内
  'largest-contentful-paint': 2500, // 2.5秒以内
  'cumulative-layout-shift': 0.1, // 0.1以内
  'total-blocking-time': 300 // 300ms以内
};

// 检查是否满足预算
let failed = false;

// 检查总体性能分数
if (results.categories.performance.score < budget.performance) {
  console.error(`❌ 性能分数 ${results.categories.performance.score * 100} 低于预算 ${budget.performance * 100}`);
  failed = true;
} else {
  console.log(`✅ 性能分数 ${results.categories.performance.score * 100} 满足预算`);
}

// 检查各项指标
for (const [metric, threshold] of Object.entries(budget)) {
  if (metric === 'performance') continue;
  
  const result = results.audits[metric];
  if (result && result.numericValue > threshold) {
    console.error(`❌ ${result.title} (${result.numericValue}ms) 超过预算 (${threshold}ms)`);
    failed = true;
  } else if (result) {
    console.log(`✅ ${result.title} (${result.numericValue}ms) 满足预算`);
  }
}

// 如果未满足预算，退出并返回错误码
if (failed) {
  process.exit(1);
}
```

### 5.2 使用 Puppeteer 进行性能测试

Puppeteer 是一个 Node.js 库，提供了高级 API 来控制 Chrome/Chromium。

```javascript
// 使用 Puppeteer 测量页面性能
const puppeteer = require('puppeteer');

async function measurePagePerformance(url) {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  
  // 启用性能指标收集
  await page.evaluateOnNewDocument(() => {
    window.performanceMetrics = [];
    
    // 记录FCP
    const fcpObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        window.performanceMetrics.push({
          name: entry.name,
          value: entry.startTime
        });
      });
    });
    fcpObserver.observe({ type: 'paint', buffered: true });
    
    // 记录LCP
    const lcpObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const lastEntry = entries[entries.length - 1];
      window.performanceMetrics.push({
        name: 'largest-contentful-paint',
        value: lastEntry.startTime
      });
    });
    lcpObserver.observe({ type: 'largest-contentful-paint', buffered: true });
    
    // 记录CLS
    let clsValue = 0;
    const clsObserver = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      entries.forEach(entry => {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      });
      
      window.performanceMetrics.push({
        name: 'cumulative-layout-shift',
        value: clsValue
      });
    });
    clsObserver.observe({ type: 'layout-shift', buffered: true });
  });
  
  // 导航到页面并等待加载完成
  await page.goto(url, { waitUntil: 'networkidle2' });
  
  // 收集性能指标
  const metrics = await page.evaluate(() => {
    return {
      // 从Performance API获取指标
      timing: performance.timing.toJSON(),
      // 从自定义收集的指标获取
      customMetrics: window.performanceMetrics,
      // 从Performance API获取资源计时
      resources: performance.getEntriesByType('resource').map(r => ({
        name: r.name,
        duration: r.duration,
        size: r.transferSize,
        type: r.initiatorType
      }))
    };
  });
  
  // 获取Lighthouse指标
  const lighthouseMetrics = await page.evaluate(() => {
    return {
      FCP: performance.getEntriesByName('first-contentful-paint')[0]?.startTime,
      LCP: window.performanceMetrics.find(m => m.name === 'largest-contentful-paint')?.value,
      CLS: window.performanceMetrics.find(m => m.name === 'cumulative-layout-shift')?.value,
      TTI: performance.timing.domInteractive - performance.timing.navigationStart
    };
  });
  
  await browser.close();
  
  // 分析和输出结果
  console.log('页面性能指标:');
  console.log('Lighthouse 指标:');
  console.log(`- 首次内容绘制 (FCP): ${lighthouseMetrics.FCP}ms`);
  console.log(`- 最大内容绘制 (LCP): ${lighthouseMetrics.LCP}ms`);
  console.log(`- 累积布局偏移 (CLS): ${lighthouseMetrics.CLS}`);
  console.log(`- 可交互时间 (TTI): ${lighthouseMetrics.TTI}ms`);
  
  // 分析资源加载
  const resourcesByType = {};
  metrics.resources.forEach(resource => {
    const type = resource.type || 'other';
    if (!resourcesByType[type]) {
      resourcesByType[type] = [];
    }
    resourcesByType[type].push(resource);
  });
  
  console.log('\n资源加载分析:');
  for (const type in resourcesByType) {
    const resources = resourcesByType[type];
    const totalSize = resources.reduce((sum, r) => sum + (r.size || 0), 0);
    const avgDuration = resources.reduce((sum, r) => sum + r.duration, 0) / resources.length;
    
    console.log(`${type} (${resources.length}个):`);
    console.log(`- 总大小: ${(totalSize / 1024).toFixed(2)} KB`);
    console.log(`- 平均加载时间: ${avgDuration.toFixed(2)} ms`);
  }
  
  return {
    metrics,
    lighthouseMetrics
  };
}

// 使用示例
// measurePagePerformance('https://example.com');
```

### 5.3 使用 Sitespeed.io

Sitespeed.io 是一个开源工具，用于监控和测量网站性能。

```bash
# 安装 sitespeed.io
npm install -g sitespeed.io

# 运行基本测试
sitespeed.io https://example.com

# 运行高级测试
sitespeed.io https://example.com --browsertime.iterations 3 --cpu --video --visualMetrics
```

```javascript
// 使用 Node.js API 运行 sitespeed.io
const sitespeed = require('sitespeed.io');

async function runSitespeedTest() {
  const options = {
    urls: ['https://example.com'],
    browsertime: {
      iterations: 3,
      browser: 'chrome',
      connectivity: {
        profile: '3g',
        downstreamKbps: 1600,
        upstreamKbps: 768,
        latency: 300
      }
    },
    plugins: {
      disable: ['html']
    },
    outputFolder: './sitespeed-result',
    json: true
  };
  
  try {
    const result = await sitespeed.run(options);
    console.log('Sitespeed.io 测试完成，结果保存在:', options.outputFolder);
    return result;
  } catch (error) {
    console.error('Sitespeed.io 测试失败:', error);
    throw error;
  }
}
```

## 6. 性能指标可视化

### 6.1 使用 Grafana 可视化性能数据

```javascript
// 将性能数据发送到 InfluxDB，然后用 Grafana 可视化
const { InfluxDB, Point } = require('@influxdata/influxdb-client');

// 创建 InfluxDB 客户端
const token = 'YOUR_INFLUXDB_TOKEN';
const url = 'http://localhost:8086';
const client = new InfluxDB({ url, token });

// 创建写入 API
const org = 'my-org';
const bucket = 'performance-metrics';
const writeApi = client.getWriteApi(org, bucket);

// 发送性能指标到 InfluxDB
function sendPerformanceMetricsToInfluxDB(metrics, tags = {}) {
  // 创建点
  const point = new Point('page_load')
    .tag('page', tags.page || window.location.pathname)
    .tag('browser', tags.browser || navigator.userAgent)
    .tag('device', tags.device || (window.innerWidth <= 768 ? 'mobile' : 'desktop'));
  
  // 添加性能指标
  if (metrics.FCP) point.floatField('fcp', metrics.FCP);
  if (metrics.LCP) point.floatField('lcp', metrics.LCP);
  if (metrics.CLS) point.floatField('cls', metrics.CLS);
  if (metrics.FID) point.floatField('fid', metrics.FID);
  if (metrics.TTI) point.floatField('tti', metrics.TTI);
  if (metrics.TBT) point.floatField('tbt', metrics.TBT);
  
  // 写入数据
  writeApi.writePoint(point);
  writeApi.flush();
}

// 使用示例
window.addEventListener('load', () => {
  setTimeout(() => {
    // 收集性能指标
    const paintEntries = performance.getEntriesByType('paint');
    const FCP = paintEntries.find(entry => entry.name === 'first-contentful-paint')?.startTime;
    
    // 发送到 InfluxDB
    sendPerformanceMetricsToInfluxDB({
      FCP,
      // 其他指标...
    });
  }, 0);
});
```

### 6.2 使用 SpeedCurve

SpeedCurve 是一个专业的性能监控服务，提供了丰富的可视化功能。

```html
<!-- SpeedCurve RUM 监控代码 -->
<script>
LUX=(function(){var a=("undefined"!==typeof(LUX)&&"undefined"!==typeof(LUX.gaMarks)?LUX.gaMarks:[]);var d=("undefined"!==typeof(LUX)&&"undefined"!==typeof(LUX.gaMeasures)?LUX.gaMeasures:[]);var j="LUX_start";var k=window.performance;var l=("undefined"!==typeof(LUX)&&LUX.ns?LUX.ns:(Date.now?Date.now():+(new Date())));if(k&&k.timing&&k.timing.navigationStart){l=k.timing.navigationStart}function f(){if(k&&k.now){return k.now()}var o=Date.now?Date.now():+(new Date());return o-l}function b(n){if(k){if(k.mark){return k.mark(n)}else{if(k.webkitMark){return k.webkitMark(n)}}}a.push({name:n,entryType:"mark",startTime:f(),duration:0});return}function m(p,t,n){if("undefined"===typeof(t)&&h(j)){t=j}if(k){if(k.measure){if(t){if(n){return k.measure(p,t,n)}else{return k.measure(p,t)}}else{return k.measure(p)}}else{if(k.webkitMeasure){return k.webkitMeasure(p,t,n)}}}var r=0,o=f();if(t&&h(t)){r=h(t).startTime}if(n&&h(n)){o=h(n).startTime}d.push({name:p,entryType:"measure",startTime:r,duration:(o-r)});return}function h(n){return c(n,g())}function c(p,o){for(i=o.length-1;i>=0;i--){var n=o[i];if(p===n.name){return n}}return undefined}function g(){if(k){if(k.getEntriesByType){return k.getEntriesByType("mark")}else{if(k.webkitGetEntriesByType){return k.webkitGetEntriesByType("mark")}}}return a}return{mark:b,measure:m,gaMarks:a,gaMeasures:d}})();LUX.ns=(Date.now?Date.now():+(new Date()));LUX.ac=[];LUX.cmd=function(a){LUX.ac.push(a)};LUX.init=function(){LUX.cmd(["init"])};LUX.send=function(){LUX.cmd(["send"])};LUX.addData=function(a,b){LUX.cmd(["addData",a,b])};LUX_ae=[];window.addEventListener("error",function(a){LUX_ae.push(a)});LUX_al=[];if("function"===typeof(PerformanceObserver)&&"function"===typeof(PerformanceLongTaskTiming)){var LongTaskObserver=new PerformanceObserver(function(c){var b=c.getEntries();for(var a=0;a<b.length;a++){var d=b[a];LUX_al.push(d)}});try{LongTaskObserver.observe({type:["longtask"]})}catch(e){}};
</script>
<script src="https://cdn.speedcurve.com/js/lux.js?id=YOUR_SPEEDCURVE_ID" async defer></script>
```

## 7. 性能分析最佳实践

### 7.1 建立性能预算

```javascript
// 性能预算示例
const performanceBudget = {
  // 时间预算
  timing: {
    FCP: 1800, // 首次内容绘制 <= 1.8秒
    LCP: 2500, // 最大内容绘制 <= 2.5秒
    TTI: 3800, // 可交互时间 <= 3.8秒
    TBT: 300,  // 总阻塞时间 <= 300毫秒
    CLS: 0.1   // 累积布局偏移 <= 0.1
  },
  
  // 资源大小预算
  size: {
    total: 1500000,    // 总大小 <= 1.5MB
    html: 100000,      // HTML <= 100KB
    css: 100000,       // CSS <= 100KB
    javascript: 300000, // JavaScript <= 300KB
    images: 1000000,   // 图片 <= 1MB
    fonts: 100000      // 字体 <= 100KB
  },
  
  // 请求数预算
  requests: {
    total: 50,        // 总请求数 <= 50
    critical: 15,     // 关键请求数 <= 15
    javascript: 10,   // JavaScript请求数 <= 10
    css: 4,           // CSS请求数 <= 4
    images: 20,       // 图片请求数 <= 20
    fonts: 4          // 字体请求数 <= 4
  }
};

// 检查是否满足性能预算
function checkPerformanceBudget(metrics) {
  const violations = [];
  
  // 检查时间预算
  if (metrics.FCP > performanceBudget.timing.FCP) {
    violations.push(`FCP ${metrics.FCP}ms 超出预算 ${performanceBudget.timing.FCP}ms`);
  }
  
  if (metrics.LCP > performanceBudget.timing.LCP) {
    violations.push(`LCP ${metrics.LCP}ms 超出预算 ${performanceBudget.timing.LCP}ms`);
  }
  
  // 检查资源大小预算
  if (metrics.totalSize > performanceBudget.size.total) {
    violations.push(`总资源大小 ${metrics.totalSize} 字节超出预算 ${performanceBudget.size.total} 字节`);
  }
  
  // 检查请求数预算
  if (metrics.totalRequests > performanceBudget.requests.total) {
    violations.push(`总请求数 ${metrics.totalRequests} 超出预算 ${performanceBudget.requests.total}`);
  }
  
  return {
    passed: violations.length === 0,
    violations
  };
}
```

### 7.2 性能分析工作流

```javascript
// 性能分析工作流示例
async function performanceAnalysisWorkflow(url) {
  console.log(`开始对 ${url} 进行性能分析...`);
  
  // 1. 运行 Lighthouse 分析
  console.log('运行 Lighthouse 分析...');
  const lighthouseResults = await runLighthouse(url);
  
  // 2. 运行 WebPageTest 分析
  console.log('运行 WebPageTest 分析...');
  const webPageTestResults = await runWebPageTest(url, 'YOUR_API_KEY');
  
  // 3. 使用 Puppeteer 进行自定义分析
  console.log('使用 Puppeteer 进行自定义分析...');
  const puppeteerResults = await measurePagePerformance(url);
  
  // 4. 检查是否满足性能预算
  console.log('检查性能预算...');
  const metrics = {
    FCP: lighthouseResults.audits['first-contentful-paint'].numericValue,
    LCP: lighthouseResults.audits['largest-contentful-paint'].numericValue,
    TTI: lighthouseResults.audits['interactive'].numericValue,
    TBT: lighthouseResults.audits['total-blocking-time'].numericValue,
    CLS: lighthouseResults.audits['cumulative-layout-shift'].numericValue,
    totalSize: webPageTestResults.data.runs['1'].firstView.bytesIn,
    totalRequests: webPageTestResults.data.runs['1'].firstView.requests
  };
  
  const budgetResult = checkPerformanceBudget(metrics);
  
  // 5. 生成报告
  console.log('生成性能分析报告...');
  generatePerformanceReport(url, {
    lighthouse: lighthouseResults,
    webPageTest: webPageTestResults,
    puppeteer: puppeteerResults,
    budget: budgetResult
  });
  
  // 6. 提供优化建议
  console.log('提供优化建议...');
  const optimizationSuggestions = generateOptimizationSuggestions({
    lighthouse: lighthouseResults,
    webPageTest: webPageTestResults,
    puppeteer: puppeteerResults
  });
  
  return {
    metrics,
    budgetResult,
    optimizationSuggestions,
    reports: {
      lighthouse: lighthouseResults,
      webPageTest: webPageTestResults,
      puppeteer: puppeteerResults
    }
  };
}

// 生成性能报告
function generatePerformanceReport(url, results) {
  const { lighthouse, webPageTest, puppeteer, budget } = results;
  
  // 创建报告HTML
  const reportHtml = `
    <!DOCTYPE html>
    <html>
    <head>
      <title>性能分析报告 - ${url}</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
        h1, h2, h3 { color: #333; }
        .summary { background: #f5f5f5; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .metric { margin-bottom: 10px; }
        .good { color: green; }
        .warning { color: orange; }
        .poor { color: red; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
        .chart { margin: 20px 0; height: 300px; }
      </style>
    </head>
    <body>
      <h1>性能分析报告</h1>
      <p>URL: ${url}</p>
      <p>分析时间: ${new Date().toLocaleString()}</p>
      
      <div class="summary">
        <h2>性能概览</h2>
        <div class="metric">
          <strong>性能得分:</strong> 
          <span class="${getScoreClass(lighthouse.categories.performance.score)}">
            ${(lighthouse.categories.performance.score * 100).toFixed(0)}
          </span>
        </div>
        <div class="metric">
          <strong>首次内容绘制 (FCP):</strong> 
          <span class="${getMetricClass(lighthouse.audits['first-contentful-paint'].score)}">
            ${lighthouse.audits['first-contentful-paint'].displayValue}
          </span>
        </div>
        <div class="metric">
          <strong>最大内容绘制 (LCP):</strong> 
          <span class="${getMetricClass(lighthouse.audits['largest-contentful-paint'].score)}">
            ${lighthouse.audits['largest-contentful-paint'].displayValue}
          </span>
        </div>
        <div class="metric">
          <strong>累积布局偏移 (CLS):</strong> 
          <span class="${getMetricClass(lighthouse.audits['cumulative-layout-shift'].score)}">
            ${lighthouse.audits['cumulative-layout-shift'].displayValue}
          </span>
        </div>
        <div class="metric">
          <strong>总阻塞时间 (TBT):</strong> 
          <span class="${getMetricClass(lighthouse.audits['total-blocking-time'].score)}">
            ${lighthouse.audits['total-blocking-time'].displayValue}
          </span>
        </div>
        <div class="metric">
          <strong>可交互时间 (TTI):</strong> 
          <span class="${getMetricClass(lighthouse.audits['interactive'].score)}">
            ${lighthouse.audits['interactive'].displayValue}
          </span>
        </div>
      </div>
      
      <h2>性能预算检查</h2>
      <div class="${budget.passed ? 'good' : 'poor'}">
        ${budget.passed ? '✅ 所有指标都满足性能预算' : '❌ 部分指标未满足性能预算'}
      </div>
      ${budget.violations.length > 0 ? `
        <h3>预算违规项</h3>
        <ul>
          ${budget.violations.map(v => `<li class="poor">${v}</li>`).join('')}
        </ul>
      ` : ''}
      
      <h2>资源分析</h2>
      <table>
        <tr>
          <th>资源类型</th>
          <th>请求数</th>
          <th>总大小</th>
          <th>平均加载时间</th>
        </tr>
        ${generateResourceTable(webPageTest, puppeteer)}
      </table>
      
      <h2>优化建议</h2>
      <ul>
        ${lighthouse.categories.performance.auditRefs
          .filter(ref => lighthouse.audits[ref.id].score < 0.9 && lighthouse.audits[ref.id].details)
          .map(ref => {
            const audit = lighthouse.audits[ref.id];
            return `<li>
              <strong>${audit.title}:</strong> ${audit.description}
              <br><span class="${getMetricClass(audit.score)}">得分: ${(audit.score * 100).toFixed(0)}</span>
            </li>`;
          })
          .join('')}
      </ul>
    </body>
    </html>
  `;
  
  // 保存报告
  const fs = require('fs');
  const reportPath = `./performance-report-${new Date().toISOString().replace(/:/g, '-')}.html`;
  fs.writeFileSync(reportPath, reportHtml);
  
  console.log(`性能报告已保存到: ${reportPath}`);
  
  // 辅助函数
  function getScoreClass(score) {
    if (score >= 0.9) return 'good';
    if (score >= 0.5) return 'warning';
    return 'poor';
  }
  
  function getMetricClass(score) {
    if (score >= 0.9) return 'good';
    if (score >= 0.5) return 'warning';
    return 'poor';
  }
  
  function generateResourceTable(webPageTest, puppeteer) {
    // 从WebPageTest和Puppeteer结果中提取资源信息
    const resourceTypes = {
      'js': { name: 'JavaScript', count: 0, size: 0, time: 0 },
      'css': { name: 'CSS', count: 0, size: 0, time: 0 },
      'image': { name: '图片', count: 0, size: 0, time: 0 },
      'font': { name: '字体', count: 0, size: 0, time: 0 },
      'html': { name: 'HTML', count: 0, size: 0, time: 0 },
      'other': { name: '其他', count: 0, size: 0, time: 0 }
    };
    
    // 处理WebPageTest数据
    const requests = webPageTest.data.runs['1'].firstView.requests;
    requests.forEach(req => {
      let type = 'other';
      const contentType = req.contentType || '';
      
      if (contentType.includes('javascript')) type = 'js';
      else if (contentType.includes('css')) type = 'css';
      else if (contentType.includes('image')) type = 'image';
      else if (contentType.includes('font')) type = 'font';
      else if (contentType.includes('html')) type = 'html';
      
      resourceTypes[type].count++;
      resourceTypes[type].size += req.bytesIn || 0;
      resourceTypes[type].time += req.ttfb || 0;
    });
    
    // 计算平均时间
    Object.keys(resourceTypes).forEach(type => {
      if (resourceTypes[type].count > 0) {
        resourceTypes[type].time = resourceTypes[type].time / resourceTypes[type].count;
      }
    });
    
    // 生成表格行
    return Object.values(resourceTypes)
      .filter(type => type.count > 0)
      .map(type => `
        <tr>
          <td>${type.name}</td>
          <td>${type.count}</td>
          <td>${(type.size / 1024).toFixed(2)} KB</td>
          <td>${type.time.toFixed(2)} ms</td>
        </tr>
      `)
      .join('');
  }
}

// 生成优化建议
function generateOptimizationSuggestions(results) {
  const { lighthouse } = results;
  const suggestions = [];
  
  // 从Lighthouse审计中提取建议
  const audits = lighthouse.audits;
  
  // 图片优化
  if (audits['uses-optimized-images'] && audits['uses-optimized-images'].score < 1) {
    suggestions.push({
      category: '图片优化',
      title: '优化图片',
      description: '压缩和优化图片可以减少页面大小并提高加载速度。',
      impact: 'high',
      implementation: `
        1. 使用WebP格式替代JPEG和PNG
        2. 使用适当的图片压缩工具
        3. 为不同屏幕尺寸提供响应式图片
        4. 考虑使用图片CDN服务
      `
    });
  }
  
  // JavaScript优化
  if (audits['unminified-javascript'] && audits['unminified-javascript'].score < 1) {
    suggestions.push({
      category: 'JavaScript优化',
      title: '压缩JavaScript',
      description: '压缩JavaScript可以减少文件大小，提高加载速度。',
      impact: 'medium',
      implementation: `
        1. 使用Terser、UglifyJS等工具压缩代码
        2. 在构建过程中集成压缩步骤
        3. 确保生产环境使用压缩版本
      `
    });
  }
  
  if (audits['unused-javascript'] && audits['unused-javascript'].score < 1) {
    suggestions.push({
      category: 'JavaScript优化',
      title: '移除未使用的JavaScript',
      description: '删除未使用的JavaScript代码可以减少下载、解析和执行时间。',
      impact: 'high',
      implementation: `
        1. 使用代码分割技术
        2. 实现懒加载
        3. 使用Tree Shaking移除未使用的代码
        4. 审查并移除不必要的第三方库
      `
    });
  }
  
  // CSS优化
  if (audits['unminified-css'] && audits['unminified-css'].score < 1) {
    suggestions.push({
      category: 'CSS优化',
      title: '压缩CSS',
      description: '压缩CSS可以减少文件大小，提高加载速度。',
      impact: 'medium',
      implementation: `
        1. 使用cssnano、clean-css等工具压缩CSS
        2. 在构建过程中集成压缩步骤
        3. 移除未使用的CSS规则
      `
    });
  }
  
  // 字体优化
  if (audits['uses-rel-preconnect'] && audits['uses-rel-preconnect'].score < 1) {
    suggestions.push({
      category: '资源加载优化',
      title: '使用preconnect预连接',
      description: '对关键第三方域名使用preconnect可以提前建立连接，减少加载时间。',
      impact: 'medium',
      implementation: `
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://cdn.example.com">
      `
    });
  }
  
  // 缓存优化
  if (audits['uses-long-cache-ttl'] && audits['uses-long-cache-ttl'].score < 1) {
    suggestions.push({
      category: '缓存优化',
      title: '实施有效的缓存策略',
      description: '为静态资源设置适当的缓存策略可以减少重复请求。',
      impact: 'high',
      implementation: `
        1. 为静态资源设置长期缓存
        2. 使用内容哈希实现缓存破坏
        3. 使用Service Worker缓存关键资源
      `
    });
  }
  
  // 服务器优化
  if (audits['server-response-time'] && audits['server-response-time'].score < 1) {
    suggestions.push({
      category: '服务器优化',
      title: '减少服务器响应时间',
      description: '优化服务器响应时间可以减少用户等待时间。',
      impact: 'high',
      implementation: `
        1. 优化数据库查询
        2. 实施服务器端缓存
        3. 使用CDN分发内容
        4. 考虑升级服务器硬件或优化配置
      `
    });
  }
  
  return suggestions;
}
```

### 7.3 持续性能监控
持续性能监控是确保网站长期保持良好性能的关键。通过定期收集和分析性能数据，可以及时发现并解决性能问题。

```javascript
// 持续性能监控系统示例
class PerformanceMonitoringSystem {
  constructor(options = {}) {
    this.options = {
      // 监控配置
      monitoringInterval: 24 * 60 * 60 * 1000, // 默认每24小时运行一次
      alertThresholds: {
        performance: 0.7, // 性能分数低于70分触发警报
        FCP: 2000,        // FCP超过2秒触发警报
        LCP: 2500,        // LCP超过2.5秒触发警报
        CLS: 0.25,        // CLS超过0.25触发警报
        TTI: 5000         // TTI超过5秒触发警报
      },
      notificationChannels: ['email', 'slack'],
      // 测试配置
      testUrls: ['https://example.com', 'https://example.com/products', 'https://example.com/contact'],
      ...options
    };
    
    this.monitoringResults = [];
    this.alerts = [];
  }
  
  // 启动监控系统
  start() {
    console.log('启动性能监控系统...');
    
    // 立即运行一次测试
    this.runTests();
    
    // 设置定期测试
    this.intervalId = setInterval(() => {
      this.runTests();
    }, this.options.monitoringInterval);
    
    return this;
  }
  
  // 停止监控系统
  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
      console.log('性能监控系统已停止');
    }
    return this;
  }
  
  // 运行性能测试
  async runTests() {
    console.log(`开始性能测试 - ${new Date().toLocaleString()}`);
    
    const testResults = [];
    
    for (const url of this.options.testUrls) {
      try {
        console.log(`测试URL: ${url}`);
        
        // 运行Lighthouse测试
        const lighthouseResult = await this.runLighthouseTest(url);
        
        // 提取关键指标
        const metrics = {
          url,
          timestamp: new Date().toISOString(),
          performance: lighthouseResult.categories.performance.score,
          FCP: lighthouseResult.audits['first-contentful-paint'].numericValue,
          LCP: lighthouseResult.audits['largest-contentful-paint'].numericValue,
          CLS: lighthouseResult.audits['cumulative-layout-shift'].numericValue,
          TTI: lighthouseResult.audits['interactive'].numericValue,
          TBT: lighthouseResult.audits['total-blocking-time'].numericValue
        };
        
        testResults.push(metrics);
        
        // 检查是否需要触发警报
        this.checkAlerts(metrics);
        
      } catch (error) {
        console.error(`测试URL ${url} 时出错:`, error);
        
        // 记录错误
        testResults.push({
          url,
          timestamp: new Date().toISOString(),
          error: error.message
        });
      }
    }
    
    // 保存测试结果
    this.monitoringResults.push({
      timestamp: new Date().toISOString(),
      results: testResults
    });
    
    // 保存到数据库或文件
    this.saveResults();
    
    // 生成报告
    this.generateReport();
    
    console.log(`性能测试完成 - ${new Date().toLocaleString()}`);
    
    return testResults;
  }
  
  // 运行Lighthouse测试
  async runLighthouseTest(url) {
    // 这里使用Lighthouse Node.js API
    const lighthouse = require('lighthouse');
    const chromeLauncher = require('chrome-launcher');
    
    const chrome = await chromeLauncher.launch({
      chromeFlags: ['--headless', '--disable-gpu', '--no-sandbox']
    });
    
    const options = {
      port: chrome.port,
      onlyCategories: ['performance'],
      output: 'json'
    };
    
    const result = await lighthouse(url, options);
    await chrome.kill();
    
    return result.lhr;
  }
  
  // 检查是否需要触发警报
  checkAlerts(metrics) {
    const { alertThresholds } = this.options;
    const alerts = [];
    
    // 检查各项指标是否超过阈值
    if (metrics.performance < alertThresholds.performance) {
      alerts.push({
        type: 'performance',
        message: `性能分数 (${(metrics.performance * 100).toFixed(0)}) 低于阈值 (${(alertThresholds.performance * 100).toFixed(0)})`,
        severity: 'high'
      });
    }
    
    if (metrics.FCP > alertThresholds.FCP) {
      alerts.push({
        type: 'FCP',
        message: `首次内容绘制 (${metrics.FCP.toFixed(0)}ms) 超过阈值 (${alertThresholds.FCP}ms)`,
        severity: 'medium'
      });
    }
    
    if (metrics.LCP > alertThresholds.LCP) {
      alerts.push({
        type: 'LCP',
        message: `最大内容绘制 (${metrics.LCP.toFixed(0)}ms) 超过阈值 (${alertThresholds.LCP}ms)`,
        severity: 'high'
      });
    }
    
    if (metrics.CLS > alertThresholds.CLS) {
      alerts.push({
        type: 'CLS',
        message: `累积布局偏移 (${metrics.CLS.toFixed(2)}) 超过阈值 (${alertThresholds.CLS})`,
        severity: 'high'
      });
    }
    
    if (metrics.TTI > alertThresholds.TTI) {
      alerts.push({
        type: 'TTI',
        message: `可交互时间 (${metrics.TTI.toFixed(0)}ms) 超过阈值 (${alertThresholds.TTI}ms)`,
        severity: 'medium'
      });
    }
    
    // 如果有警报，记录并发送通知
    if (alerts.length > 0) {
      const alertRecord = {
        url: metrics.url,
        timestamp: new Date().toISOString(),
        alerts
      };
      
      this.alerts.push(alertRecord);
      this.sendAlertNotifications(alertRecord);
    }
    
    return alerts;
  }
  
  // 发送警报通知
  sendAlertNotifications(alertRecord) {
    const { notificationChannels } = this.options;
    
    console.log('发送性能警报通知:');
    console.log(JSON.stringify(alertRecord, null, 2));
    
    // 根据配置的通知渠道发送通知
    if (notificationChannels.includes('email')) {
      this.sendEmailAlert(alertRecord);
    }
    
    if (notificationChannels.includes('slack')) {
      this.sendSlackAlert(alertRecord);
    }
  }
  
  // 发送邮件警报
  sendEmailAlert(alertRecord) {
    // 实际实现中，这里会使用邮件发送库，如nodemailer
    console.log('通过邮件发送警报');
    
    // 示例代码
    /*
    const nodemailer = require('nodemailer');
    
    const transporter = nodemailer.createTransport({
      host: 'smtp.example.com',
      port: 587,
      secure: false,
      auth: {
        user: 'alerts@example.com',
        pass: 'password'
      }
    });
    
    const mailOptions = {
      from: 'Performance Monitor <alerts@example.com>',
      to: 'team@example.com',
      subject: `性能警报: ${alertRecord.url}`,
      html: `
        <h1>性能警报</h1>
        <p><strong>URL:</strong> ${alertRecord.url}</p>
        <p><strong>时间:</strong> ${new Date(alertRecord.timestamp).toLocaleString()}</p>
        <h2>警报详情:</h2>
        <ul>
          ${alertRecord.alerts.map(alert => `
            <li>
              <strong>${alert.type}:</strong> ${alert.message}
              <span style="color: ${alert.severity === 'high' ? 'red' : 'orange'}">
                (${alert.severity})
              </span>
            </li>
          `).join('')}
        </ul>
        <p>请查看详细的性能报告以了解更多信息。</p>
      `
    };
    
    transporter.sendMail(mailOptions);
    */
  }
  
  // 发送Slack警报
  sendSlackAlert(alertRecord) {
    // 实际实现中，这里会使用Slack API
    console.log('通过Slack发送警报');
    
    // 示例代码
    /*
    const { WebClient } = require('@slack/web-api');
    const slack = new WebClient('YOUR_SLACK_TOKEN');
    
    const alertEmoji = {
      high: ':red_circle:',
      medium: ':large_orange_diamond:',
      low: ':large_blue_circle:'
    };
    
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `性能警报: ${alertRecord.url}`
        }
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*时间:* ${new Date(alertRecord.timestamp).toLocaleString()}`
        }
      },
      {
        type: 'divider'
      }
    ];
    
    // 添加每个警报的详情
    alertRecord.alerts.forEach(alert => {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `${alertEmoji[alert.severity]} *${alert.type}:* ${alert.message}`
        }
      });
    });
    
    slack.chat.postMessage({
      channel: 'performance-alerts',
      blocks
    });
    */
  }
  
  // 保存结果到数据库或文件
  saveResults() {
    // 实际实现中，这里会保存到数据库或文件
    console.log('保存监控结果');
    
    // 示例代码 - 保存到文件
    /*
    const fs = require('fs');
    const resultsPath = './performance-monitoring-results.json';
    
    fs.writeFileSync(
      resultsPath,
      JSON.stringify(this.monitoringResults, null, 2)
    );
    */
  }
  
  // 生成性能趋势报告
  generateReport() {
    // 如果没有足够的数据，跳过报告生成
    if (this.monitoringResults.length < 2) {
      console.log('数据不足，无法生成趋势报告');
      return;
    }
    
    console.log('生成性能趋势报告');
    
    // 提取最近的几次测试结果进行比较
    const recentResults = this.monitoringResults
      .slice(-5) // 最近5次
      .flatMap(record => record.results);
    
    // 按URL分组
    const resultsByUrl = {};
    recentResults.forEach(result => {
      if (result.error) return; // 跳过错误结果
      
      if (!resultsByUrl[result.url]) {
        resultsByUrl[result.url] = [];
      }
      resultsByUrl[result.url].push(result);
    });
    
    // 分析每个URL的趋势
    const trends = {};
    
    for (const [url, results] of Object.entries(resultsByUrl)) {
      if (results.length < 2) continue; // 需要至少两个数据点
      
      // 按时间排序
      results.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      
      // 计算关键指标的变化
      const firstResult = results[0];
      const lastResult = results[results.length - 1];
      
      trends[url] = {
        period: {
          start: firstResult.timestamp,
          end: lastResult.timestamp
        },
        changes: {
          performance: {
            value: lastResult.performance - firstResult.performance,
            percent: ((lastResult.performance - firstResult.performance) / firstResult.performance * 100).toFixed(2)
          },
          FCP: {
            value: lastResult.FCP - firstResult.FCP,
            percent: ((lastResult.FCP - firstResult.FCP) / firstResult.FCP * 100).toFixed(2)
          },
          LCP: {
            value: lastResult.LCP - firstResult.LCP,
            percent: ((lastResult.LCP - firstResult.LCP) / firstResult.LCP * 100).toFixed(2)
          },
          CLS: {
            value: lastResult.CLS - firstResult.CLS,
            percent: ((lastResult.CLS - firstResult.CLS) / firstResult.CLS * 100).toFixed(2)
          },
          TTI: {
            value: lastResult.TTI - firstResult.TTI,
            percent: ((lastResult.TTI - firstResult.TTI) / firstResult.TTI * 100).toFixed(2)
          }
        }
      };
    }
    
    // 输出趋势报告
    console.log('性能趋势分析:');
    for (const [url, trend] of Object.entries(trends)) {
      console.log(`\nURL: ${url}`);
      console.log(`分析周期: ${new Date(trend.period.start).toLocaleDateString()} - ${new Date(trend.period.end).toLocaleDateString()}`);
      
      console.log('指标变化:');
      for (const [metric, change] of Object.entries(trend.changes)) {
        const direction = change.value > 0 ? '增加' : '减少';
        const impact = metric === 'performance' ? 
          (change.value > 0 ? '改善' : '恶化') : 
          (change.value > 0 ? '恶化' : '改善');
        
        console.log(`- ${metric}: ${Math.abs(change.value).toFixed(2)} (${Math.abs(change.percent)}%) ${direction} - ${impact}`);
      }
    }
    
    // 生成HTML报告
    this.generateHTMLReport(trends);
    
    return trends;
  }
  
  // 生成HTML趋势报告
  generateHTMLReport(trends) {
    // 实际实现中，这里会生成HTML报告
    console.log('生成HTML趋势报告');
    
    // 示例代码
    /*
    const fs = require('fs');
    const reportPath = `./performance-trend-report-${new Date().toISOString().replace(/:/g, '-')}.html`;
    
    // 创建报告HTML
    let html = `
      <!DOCTYPE html>
      <html>
      <head>
        <title>性能趋势报告</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }
          h1, h2, h3 { color: #333; }
          .trend-card { background: #f5f5f5; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
          .metric { margin-bottom: 10px; }
          .improved { color: green; }
          .degraded { color: red; }
          .chart { margin: 20px 0; height: 300px; }
        </style>
        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
      </head>
      <body>
        <h1>性能趋势报告</h1>
        <p>生成时间: ${new Date().toLocaleString()}</p>
    `;
    
    // 为每个URL添加趋势卡片
    for (const [url, trend] of Object.entries(trends)) {
      html += `
        <div class="trend-card">
          <h2>URL: ${url}</h2>
          <p>分析周期: ${new Date(trend.period.start).toLocaleDateString()} - ${new Date(trend.period.end).toLocaleDateString()}</p>
          
          <h3>指标变化:</h3>
          <div class="metrics">
      `;
      
      // 添加每个指标的变化
      for (const [metric, change] of Object.entries(trend.changes)) {
        const direction = change.value > 0 ? '增加' : '减少';
        const impact = metric === 'performance' ? 
          (change.value > 0 ? 'improved' : 'degraded') : 
          (change.value > 0 ? 'degraded' : 'improved');
        
        html += `
          <div class="metric">
            <strong>${metric}:</strong> 
            <span class="${impact}">
              ${Math.abs(change.value).toFixed(2)} (${Math.abs(change.percent)}%) ${direction}
            </span>
          </div>
        `;
      }
      
      // 添加图表容器
      html += `
          </div>
          <div class="chart-container">
            <canvas id="chart-${url.replace(/[^\w]/g, '-')}"></canvas>
          </div>
        </div>
      `;
    }
    
    // 添加图表初始化脚本
    html += `
        <script>
          document.addEventListener('DOMContentLoaded', function() {
            // 为每个URL创建图表
            ${Object.entries(trends).map(([url, trend]) => `
              new Chart(
                document.getElementById('chart-${url.replace(/[^\w]/g, '-')}').getContext('2d'),
                {
                  type: 'bar',
                  data: {
                    labels: ['性能分数', 'FCP', 'LCP', 'CLS', 'TTI'],
                    datasets: [{
                      label: '变化百分比',
                      data: [
                        ${trend.changes.performance.percent},
                        ${trend.changes.FCP.percent},
                        ${trend.changes.LCP.percent},
                        ${trend.changes.CLS.percent},
                        ${trend.changes.TTI.percent}
                      ],
                      backgroundColor: [
                        ${trend.changes.performance.value > 0 ? "'rgba(75, 192, 192, 0.2)'" : "'rgba(255, 99, 132, 0.2)'"},
                        ${trend.changes.FCP.value < 0 ? "'rgba(75, 192, 192, 0.2)'" : "'rgba(255, 99, 132, 0.2)'"},
                        ${trend.changes.LCP.value < 0 ? "'rgba(75, 192, 192, 0.2)'" : "'rgba(255, 99, 132, 0.2)'"},
                        ${trend.changes.CLS.value < 0 ? "'rgba(75, 192, 192, 0.2)'" : "'rgba(255, 99, 132, 0.2)'"},
                        ${trend.changes.TTI.value < 0 ? "'rgba(75, 192, 192, 0.2)'" : "'rgba(255, 99, 132, 0.2)'"}
                      ],
                      borderColor: [
                        ${trend.changes.performance.value > 0 ? "'rgba(75, 192, 192, 1)'" : "'rgba(255, 99, 132, 1)'"},
                        ${trend.changes.FCP.value < 0 ? "'rgba(75, 192, 192, 1)'" : "'rgba(255, 99, 132, 1)'"},
                        ${trend.changes.LCP.value < 0 ? "'rgba(75, 192, 192, 1)'" : "'rgba(255, 99, 132, 1)'"},
                        ${trend.changes.CLS.value < 0 ? "'rgba(75, 192, 192, 1)'" : "'rgba(255, 99, 132, 1)'"},
                        ${trend.changes.TTI.value < 0 ? "'rgba(75, 192, 192, 1)'" : "'rgba(255, 99, 132, 1)'"}
                      ],
                      borderWidth: 1
                    }]
                  },
                  options: {
                    scales: {
                      y: {
                        beginAtZero: true,
                        title: {
                          display: true,
                          text: '变化百分比 (%)'
                        }
                      }
                    },
                    plugins: {
                      title: {
                        display: true,
                        text: '性能指标变化'
                      },
                      tooltip: {
                        callbacks: {
                          label: function(context) {
                            const value = context.raw;
                            return value > 0 ? 
                              \`增加 \${Math.abs(value).toFixed(2)}%\` : 
                              \`减少 \${Math.abs(value).toFixed(2)}%\`;
                          }
                        }
                      }
                    }
                  }
                }
              );
            `).join('\n')}
          });
        </script>
      </body>
      </html>
    `;
    
    fs.writeFileSync(reportPath, html);
    console.log(`趋势报告已保存到: ${reportPath}`);
    */
  }
}

// 使用示例
// const monitor = new PerformanceMonitoringSystem();
// monitor.start();
```

## 8. 常见性能问题及解决方案

以下是一些常见的性能问题及其解决方案：

### 8.1 JavaScript 性能问题

```javascript
// 问题: 过多的DOM操作导致重排和重绘
// 解决方案: 使用DocumentFragment批量操作DOM
function addItems(items) {
  // 不好的做法
  /*
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    document.getElementById('list').appendChild(li); // 每次都会触发重排
  });
  */
  
  // 好的做法
  const fragment = document.createDocumentFragment();
  items.forEach(item => {
    const li = document.createElement('li');
    li.textContent = item;
    fragment.appendChild(li);
  });
  document.getElementById('list').appendChild(fragment); // 只触发一次重排
}

// 问题: 频繁触发的事件导致性能问题
// 解决方案: 使用防抖和节流
function debounce(func, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}

function throttle(func, limit) {
  let inThrottle;
  return function(...args) {
    if (!inThrottle) {
      func.apply(this, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// 使用示例
window.addEventListener('resize', debounce(() => {
  // 处理窗口大小变化
  console.log('窗口大小已变化');
}, 200));

window.addEventListener('scroll', throttle(() => {
  // 处理滚动事件
  console.log('页面正在滚动');
}, 300));

// 问题: 大量计算导致主线程阻塞
// 解决方案: 使用Web Workers
function heavyCalculation() {
  // 创建Web Worker
  const worker = new Worker('worker.js');
  
  // 发送数据给Worker
  worker.postMessage({
    data: [1, 2, 3, 4, 5],
    operation: 'complex-calculation'
  });
  
  // 接收Worker的结果
  worker.onmessage = function(e) {
    console.log('计算结果:', e.data);
    // 使用结果更新UI
    document.getElementById('result').textContent = e.data.result;
  };
}

// worker.js 内容
/*
self.onmessage = function(e) {
  const { data, operation } = e.data;
  
  if (operation === 'complex-calculation') {
    // 执行复杂计算
    let result = 0;
    for (let i = 0; i < 1000000000; i++) {
      result += Math.sqrt(i);
    }
    
    // 返回结果
    self.postMessage({ result });
  }
};
*/
```

### 8.2 网络性能问题

```javascript
// 问题: 资源加载过慢
// 解决方案: 使用资源提示优化加载顺序

// 在HTML的<head>中添加
/*
<!-- 预连接到关键域名 -->
<link rel="preconnect" href="https://api.example.com">
<link rel="preconnect" href="https://fonts.googleapis.com">

<!-- 预加载关键资源 -->
<link rel="preload" href="/assets/critical.css" as="style">
<link rel="preload" href="/assets/hero-image.webp" as="image">

<!-- 预取可能需要的资源 -->
<link rel="prefetch" href="/assets/non-critical.js">
*/

// 问题: 大型第三方脚本阻塞渲染
// 解决方案: 使用async或defer属性
/*
<!-- 非关键脚本使用async -->
<script src="/analytics.js" async></script>

<!-- 需要按顺序执行但不阻塞解析的脚本使用defer -->
<script src="/vendor.js" defer></script>
<script src="/app.js" defer></script>
*/

// 问题: 大量小文件请求导致网络开销
// 解决方案: 合并请求，使用HTTP/2
/*
// 不好的做法: 多个小文件
<link rel="stylesheet" href="/css/reset.css">
<link rel="stylesheet" href="/css/typography.css">
<link rel="stylesheet" href="/css/buttons.css">
<link rel="stylesheet" href="/css/forms.css">

// 好的做法: 合并文件
<link rel="stylesheet" href="/css/main.min.css">

// 使用HTTP/2时，可以保持文件分离以便缓存，但通过单一连接传输
// 服务器配置HTTP/2
*/
```

### 8.3 渲染性能问题

```javascript
// 问题: 复杂动画导致掉帧
// 解决方案: 使用CSS硬件加速和requestAnimationFrame

// CSS硬件加速
/*
.animated-element {
  transform: translateZ(0); /* 启用GPU加速 */
  will-change: transform; /* 提示浏览器元素将改变 */
}
*/

// 使用requestAnimationFrame实现平滑动画
function animateElement() {
  const element = document.getElementById('animated');
  let position = 0;
  
  function step(timestamp) {
    position += 5;
    element.style.transform = `translateX(${position}px)`;
    
    if (position < 300) {
      requestAnimationFrame(step);
    }
  }
  
  requestAnimationFrame(step);
}

// 问题: 大型列表渲染导致页面卡顿
// 解决方案: 虚拟滚动
class VirtualScroller {
  constructor(options) {
    this.container = options.container;
    this.itemHeight = options.itemHeight;
    this.totalItems = options.totalItems;
    this.renderItem = options.renderItem;
    
    this.visibleItems = Math.ceil(this.container.clientHeight / this.itemHeight) + 3; // 额外缓冲
    this.scrollTop = 0;
    this.startIndex = 0;
    
    this.init();
  }
  
  init() {
    // 设置容器样式
    this.container.style.position = 'relative';
    this.container.style.overflow = 'auto';
    this.container.style.height = '100%';
    
    // 创建内容容器
    this.content = document.createElement('div');
    this.content.style.position = 'absolute';
    this.content.style.width = '100%';
    this.content.style.height = `${this.totalItems * this.itemHeight}px`;
    this.container.appendChild(this.content);
    
    // 监听滚动事件
    this.container.addEventListener('scroll', this.onScroll.bind(this));
    
    // 初始渲染
    this.render();
  }
  
  onScroll() {
    this.scrollTop = this.container.scrollTop;
    this.render();
  }
  
  render() {
    // 计算可见区域的起始索引
    this.startIndex = Math.floor(this.scrollTop / this.itemHeight);
    this.startIndex = Math.max(0, this.startIndex - 1); // 额外缓冲
    
    // 清空当前内容
    this.content.innerHTML = '';
    
    // 只渲染可见区域的项目
    const endIndex = Math.min(this.startIndex + this.visibleItems, this.totalItems);
    
    for (let i = this.startIndex; i < endIndex; i++) {
      const item = this.renderItem(i);
      item.style.position = 'absolute';
      item.style.top = `${i * this.itemHeight}px`;
      item.style.width = '100%';
      item.style.height = `${this.itemHeight}px`;
      this.content.appendChild(item);
    }
  }
}

// 使用示例
/*
const container = document.getElementById('list-container');
const data = Array.from({ length: 10000 }, (_, i) => `Item ${i + 1}`);

const virtualScroller = new VirtualScroller({
  container,
  itemHeight: 50,
  totalItems: data.length,
  renderItem: (index) => {
    const div = document.createElement('div');
    div.className = 'list-item';
    div.textContent = data[index];
    return div;
  }
});
*/
```

### 8.4 内存性能问题

```javascript
// 问题: 内存泄漏
// 解决方案: 正确管理事件监听器和引用

// 不好的做法 - 可能导致内存泄漏
/*
function setupEventHandlers() {
  const button = document.getElementById('button');
  const data = { /* 大量数据 */ };
  
  button.addEventListener('click', function() {
    // 这个闭包引用了外部的data变量
    console.log(data);
  });
}
*/

// 好的做法 - 移除不再需要的事件监听器
function setupEventHandlers() {
  const button = document.getElementById('button');
  const data = { /* 大量数据 */ };
  
  const handleClick = function() {
    console.log(data);
  };
  
  button.addEventListener('click', handleClick);
  
  // 当不再需要时移除事件监听器
  return function cleanup() {
    button.removeEventListener('click', handleClick);
  };
}

// 问题: 大量对象创建导致频繁垃圾回收
// 解决方案: 对象池模式
class ObjectPool {
  constructor(createFn, initialSize = 10) {
    this.createFn = createFn;
    this.pool = [];
    
    // 预先创建对象
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn());
    }
  }
  
  // 获取对象
  get() {
    if (this.pool.length === 0) {
      return this.createFn();
    }
    return this.pool.pop();
  }
  
  // 释放对象回池
  release(obj) {
    this.pool.push(obj);
  }
}

// 使用示例
/*
// 创建粒子对象池
const particlePool = new ObjectPool(() => {
  return {
    x: 0,
    y: 0,
    vx: 0,
    vy: 0,
    life: 0,
    reset: function(x, y, vx, vy, life) {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.life = life;
    }
  };
}, 100);

// 创建新粒子
function createParticle(x, y) {
  const particle = particlePool.get();
  particle.reset(
    x,
    y,
    Math.random() * 2 - 1,
    Math.random() * 2 - 1,
    100
  );
  return particle;
}

// 更新粒子
function updateParticles(particles) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.life--;
    
    if (p.life <= 0) {
      // 粒子生命周期结束，释放回对象池
      particlePool.release(p);
      particles.splice(i, 1);
      continue;
    }
    
    p.x += p.vx;
    p.y += p.vy;
  }
}
*/
```

## 9. 总结

性能分析工具是前端开发中不可或缺的一部分，它们帮助开发者识别和解决性能问题，提供更好的用户体验。本文介绍了多种性能分析工具和技术，包括浏览器开发者工具、Lighthouse、WebPageTest等，以及如何使用这些工具进行性能监控和优化。

关键要点：

1. 性能指标是衡量网站性能的重要标准，包括FCP、LCP、CLS等核心Web指标。
2. 浏览器开发者工具提供了丰富的性能分析功能，如性能面板、网络面板和内存面板。
3. Lighthouse和WebPageTest等工具可以提供更全面的性能评估和优化建议。
4. 持续性能监控对于保持网站长期良好性能至关重要。
5. 解决常见性能问题需要从JavaScript执行、网络请求、渲染和内存管理等多个方面入手。

通过合理使用这些工具和技术，开发者可以构建更快、更流畅的Web应用，提升用户体验和业务价值。

## 10. 参考资源

- [Web Vitals](https://web.dev/vitals/)
- [Chrome DevTools 文档](https://developer.chrome.com/docs/devtools/)
- [Lighthouse 文档](https://developer.chrome.com/docs/lighthouse/)
- [WebPageTest 文档](https://docs.webpagetest.org/)
- [Performance API 文档](https://developer.mozilla.org/en-US/docs/Web/API/Performance)
- [Web Performance Working Group](https://www.w3.org/webperf/)
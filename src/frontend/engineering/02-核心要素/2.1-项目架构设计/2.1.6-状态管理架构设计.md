---
title: 状态管理架构设计
icon: state
order: 6
---

# 状态管理架构设计

状态管理是前端应用中最复杂的部分之一，选择合适的状态管理方案对应用的可维护性和性能至关重要。本文将介绍不同的状态管理架构和适用场景。

## 1. 状态管理基础概念

### 1.1 什么是状态

在前端应用中，状态是指应用在特定时间点的数据快照，它可以包括：

- **UI 状态**：如模态框是否显示、表单输入值、加载状态等
- **应用状态**：如用户信息、权限数据等
- **服务器状态**：从服务器获取的数据，如产品列表、用户列表等

### 1.2 状态管理的挑战

随着应用规模的增长，状态管理面临以下挑战：

- **状态分散**：状态散布在不同组件中，难以追踪和管理
- **状态共享**：多个组件需要访问和修改同一状态
- **状态同步**：保持 UI 与状态的同步
- **状态持久化**：在页面刷新后恢复状态
- **状态变更追踪**：调试和追踪状态变化

### 1.3 状态分类

根据状态的作用范围，可以将状态分为以下几类：

- **本地状态**：仅在单个组件内使用的状态
- **共享状态**：在多个组件间共享的状态
- **全局状态**：影响整个应用的状态
- **服务器状态**：来自服务器的数据状态

## 2. 本地状态管理

### 2.1 React 中的 useState

适用于简单的组件内状态管理。

```jsx
import React, { useState } from 'react';

function Counter() {
  const [count, setCount] = useState(0);
  
  return (
    <div>
      <p>当前计数: {count}</p>
      <button onClick={() => setCount(count + 1)}>增加</button>
      <button onClick={() => setCount(count - 1)}>减少</button>
    </div>
  );
}
```

### 2.2 React 中的 useReducer

适用于复杂的组件内状态逻辑。

```jsx
import React, { useReducer } from 'react';

// 定义 reducer 函数
function counterReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    case 'RESET':
      return { count: 0 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });
  
  return (
    <div>
      <p>当前计数: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>增加</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>减少</button>
      <button onClick={() => dispatch({ type: 'RESET' })}>重置</button>
    </div>
  );
}
```

### 2.3 Vue 中的 reactive 和 ref

Vue 3 中使用 Composition API 管理本地状态。

```vue
<template>
  <div>
    <p>当前计数: {{ count }}</p>
    <button @click="increment">增加</button>
    <button @click="decrement">减少</button>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const count = ref(0);

function increment() {
  count.value++;
}

function decrement() {
  count.value--;
}
</script>
```

## 3. 共享状态管理

### 3.1 React 中的 Context API

适用于中小型应用的状态共享。

```jsx
// 创建 Context
import React, { createContext, useContext, useReducer } from 'react';

// 创建上下文
const CounterContext = createContext();

// 定义 reducer
function counterReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    default:
      return state;
  }
}

// 创建 Provider 组件
export function CounterProvider({ children }) {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });
  
  return (
    <CounterContext.Provider value={{ state, dispatch }}>
      {children}
    </CounterContext.Provider>
  );
}

// 自定义 Hook 简化使用
export function useCounter() {
  const context = useContext(CounterContext);
  if (!context) {
    throw new Error('useCounter must be used within a CounterProvider');
  }
  return context;
}

// 使用示例
function CounterDisplay() {
  const { state } = useCounter();
  return <div>计数: {state.count}</div>;
}

function CounterButtons() {
  const { dispatch } = useCounter();
  return (
    <div>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>增加</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>减少</button>
    </div>
  );
}

function App() {
  return (
    <CounterProvider>
      <CounterDisplay />
      <CounterButtons />
    </CounterProvider>
  );
}
```

### 3.2 Vue 中的 provide/inject

Vue 中使用 provide/inject 实现状态共享。

```vue
<!-- ParentComponent.vue -->
<template>
  <div>
    <h1>父组件</h1>
    <p>当前计数: {{ state.count }}</p>
    <button @click="increment">增加</button>
    <ChildComponent />
  </div>
</template>

<script setup>
import { reactive, provide } from 'vue';
import ChildComponent from './ChildComponent.vue';

const state = reactive({ count: 0 });

function increment() {
  state.count++;
}

// 提供状态和方法给子组件
provide('counter', {
  state,
  increment
});
</script>

<!-- ChildComponent.vue -->
<template>
  <div>
    <h2>子组件</h2>
    <p>从父组件获取的计数: {{ counter.state.count }}</p>
    <button @click="counter.increment">增加</button>
  </div>
</template>

<script setup>
import { inject } from 'vue';

// 注入父组件提供的状态和方法
const counter = inject('counter');
</script>
```

## 4. 全局状态管理

### 4.1 Redux

Redux 是 React 生态系统中最流行的状态管理库之一，适用于大型应用。

```jsx
// store.js
import { createStore } from 'redux';

// 定义初始状态
const initialState = {
  count: 0,
  user: null
};

// 定义 reducer
function rootReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    case 'SET_USER':
      return { ...state, user: action.payload };
    default:
      return state;
  }
}

// 创建 store
const store = createStore(rootReducer);

export default store;

// actions.js
export const increment = () => ({
  type: 'INCREMENT'
});

export const decrement = () => ({
  type: 'DECREMENT'
});

export const setUser = (user) => ({
  type: 'SET_USER',
  payload: user
});

// App.js
import React from 'react';
import { Provider } from 'react-redux';
import store from './store';
import Counter from './Counter';
import UserProfile from './UserProfile';

function App() {
  return (
    <Provider store={store}>
      <div>
        <h1>Redux 示例</h1>
        <Counter />
        <UserProfile />
      </div>
    </Provider>
  );
}

// Counter.js
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement } from './actions';

function Counter() {
  const count = useSelector(state => state.count);
  const dispatch = useDispatch();
  
  return (
    <div>
      <h2>计数器</h2>
      <p>当前计数: {count}</p>
      <button onClick={() => dispatch(increment())}>增加</button>
      <button onClick={() => dispatch(decrement())}>减少</button>
    </div>
  );
}
```

### 4.2 Redux Toolkit

Redux Toolkit 是 Redux 官方推荐的工具集，简化了 Redux 的使用。

```jsx
// store.js
import { configureStore, createSlice } from '@reduxjs/toolkit';

// 创建计数器切片
const counterSlice = createSlice({
  name: 'counter',
  initialState: { value: 0 },
  reducers: {
    increment: state => {
      state.value += 1;
    },
    decrement: state => {
      state.value -= 1;
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload;
    }
  }
});

// 创建用户切片
const userSlice = createSlice({
  name: 'user',
  initialState: { data: null, loading: false },
  reducers: {
    setUser: (state, action) => {
      state.data = action.payload;
    },
    setLoading: (state, action) => {
      state.loading = action.payload;
    }
  }
});

// 导出 actions
export const { increment, decrement, incrementByAmount } = counterSlice.actions;
export const { setUser, setLoading } = userSlice.actions;

// 配置 store
const store = configureStore({
  reducer: {
    counter: counterSlice.reducer,
    user: userSlice.reducer
  }
});

export default store;

// Counter.js
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { increment, decrement, incrementByAmount } from './store';

function Counter() {
  const count = useSelector(state => state.counter.value);
  const dispatch = useDispatch();
  
  return (
    <div>
      <h2>计数器</h2>
      <p>当前计数: {count}</p>
      <button onClick={() => dispatch(increment())}>增加</button>
      <button onClick={() => dispatch(decrement())}>减少</button>
      <button onClick={() => dispatch(incrementByAmount(5))}>增加 5</button>
    </div>
  );
}
```

### 4.3 MobX

MobX 是一个简单、可扩展的状态管理库，采用响应式编程模型。

```jsx
// store.js
import { makeAutoObservable } from 'mobx';

class CounterStore {
  count = 0;
  
  constructor() {
    makeAutoObservable(this);
  }
  
  increment() {
    this.count += 1;
  }
  
  decrement() {
    this.count -= 1;
  }
  
  reset() {
    this.count = 0;
  }
}

class UserStore {
  user = null;
  loading = false;
  
  constructor() {
    makeAutoObservable(this);
  }
  
  setUser(user) {
    this.user = user;
  }
  
  setLoading(loading) {
    this.loading = loading;
  }
  
  async fetchUser(id) {
    this.setLoading(true);
    try {
      const response = await fetch(`/api/users/${id}`);
      const data = await response.json();
      this.setUser(data);
    } catch (error) {
      console.error('Failed to fetch user:', error);
    } finally {
      this.setLoading(false);
    }
  }
}

// 创建 store 实例
const counterStore = new CounterStore();
const userStore = new UserStore();

export { counterStore, userStore };

// Counter.js
import React from 'react';
import { observer } from 'mobx-react-lite';
import { counterStore } from './store';

const Counter = observer(() => {
  return (
    <div>
      <h2>计数器</h2>
      <p>当前计数: {counterStore.count}</p>
      <button onClick={() => counterStore.increment()}>增加</button>
      <button onClick={() => counterStore.decrement()}>减少</button>
      <button onClick={() => counterStore.reset()}>重置</button>
    </div>
  );
});

export default Counter;
```

### 4.4 Vuex

Vuex 是 Vue.js 的状态管理库，适用于中大型 Vue 应用。

```javascript
// store.js
import { createStore } from 'vuex';

export default createStore({
  state: {
    count: 0,
    user: null,
    loading: false
  },
  mutations: {
    INCREMENT(state) {
      state.count++;
    },
    DECREMENT(state) {
      state.count--;
    },
    SET_USER(state, user) {
      state.user = user;
    },
    SET_LOADING(state, loading) {
      state.loading = loading;
    }
  },
  actions: {
    increment({ commit }) {
      commit('INCREMENT');
    },
    decrement({ commit }) {
      commit('DECREMENT');
    },
    async fetchUser({ commit }, id) {
      commit('SET_LOADING', true);
      try {
        const response = await fetch(`/api/users/${id}`);
        const data = await response.json();
        commit('SET_USER', data);
      } catch (error) {
        console.error('Failed to fetch user:', error);
      } finally {
        commit('SET_LOADING', false);
      }
    }
  },
  getters: {
    doubleCount: state => state.count * 2,
    isLoggedIn: state => !!state.user
  }
});

// Counter.vue
<template>
  <div>
    <h2>计数器</h2>
    <p>当前计数: {{ $store.state.count }}</p>
    <p>双倍计数: {{ $store.getters.doubleCount }}</p>
    <button @click="$store.dispatch('increment')">增加</button>
    <button @click="$store.dispatch('decrement')">减少</button>
  </div>
</template>
```

### 4.5 Pinia

Pinia 是 Vue 3 的官方状态管理库，是 Vuex 的替代品，提供更简单的 API 和更好的 TypeScript 支持。

```javascript
// stores/counter.js
import { defineStore } from 'pinia';

export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0
  }),
  getters: {
    doubleCount: (state) => state.count * 2
  },
  actions: {
    increment() {
      this.count++;
    },
    decrement() {
      this.count--;
    },
    reset() {
      this.count = 0;
    }
  }
});

// stores/user.js
import { defineStore } from 'pinia';

export const useUserStore = defineStore('user', {
  state: () => ({
    user: null,
    loading: false
  }),
  getters: {
    isLoggedIn: (state) => !!state.user
  },
  actions: {
    setUser(user) {
      this.user = user;
    },
    async fetchUser(id) {
      this.loading = true;
      try {
        const response = await fetch(`/api/users/${id}`);
        const data = await response.json();
        this.user = data;
      } catch (error) {
        console.error('Failed to fetch user:', error);
      } finally {
        this.loading = false;
      }
    }
  }
});

// Counter.vue
<template>
  <div>
    <h2>计数器</h2>
    <p>当前计数: {{ counter.count }}</p>
    <p>双倍计数: {{ counter.doubleCount }}</p>
    <button @click="counter.increment()">增加</button>
    <button @click="counter.decrement()">减少</button>
    <button @click="counter.reset()">重置</button>
  </div>
</template>

<script setup>
import { useCounterStore } from '../stores/counter';

const counter = useCounterStore();
</script>
```

## 5. 服务器状态管理

### 5.1 React Query

React Query 是一个用于管理服务器状态的库，提供缓存、自动重试、分页等功能。

```jsx
// 安装: npm install react-query

// App.js
import React from 'react';
import { QueryClient, QueryClientProvider } from 'react-query';
import { ReactQueryDevtools } from 'react-query/devtools';
import UserList from './UserList';

// 创建 QueryClient 实例
const queryClient = new QueryClient();

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <div>
        <h1>用户列表</h1>
        <UserList />
      </div>
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  );
}

// UserList.js
import React from 'react';
import { useQuery, useMutation, useQueryClient } from 'react-query';

// 获取用户列表
const fetchUsers = async () => {
  const response = await fetch('/api/users');
  if (!response.ok) {
    throw new Error('Failed to fetch users');
  }
  return response.json();
};

// 添加用户
const addUser = async (user) => {
  const response = await fetch('/api/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(user)
  });
  if (!response.ok) {
    throw new Error('Failed to add user');
  }
  return response.json();
};

function UserList() {
  const queryClient = useQueryClient();
  
  // 使用 useQuery 获取用户列表
  const { data: users, isLoading, error } = useQuery('users', fetchUsers, {
    staleTime: 5 * 60 * 1000, // 5分钟内不重新获取数据
    refetchOnWindowFocus: false // 窗口聚焦时不重新获取数据
  });
  
  // 使用 useMutation 添加用户
  const mutation = useMutation(addUser, {
    onSuccess: () => {
      // 添加成功后，使缓存失效并重新获取数据
      queryClient.invalidateQueries('users');
    }
  });
  
  const handleAddUser = () => {
    const newUser = {
      name: 'New User',
      email: 'newuser@example.com'
    };
    mutation.mutate(newUser);
  };
  
  if (isLoading) return <div>加载中...</div>;
  if (error) return <div>出错了: {error.message}</div>;
  
  return (
    <div>
      <button onClick={handleAddUser} disabled={mutation.isLoading}>
        {mutation.isLoading ? '添加中...' : '添加用户'}
      </button>
      
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name} ({user.email})</li>
        ))}
      </ul>
    </div>
  );
}
```

### 5.2 SWR

SWR 是一个用于数据获取的 React Hooks 库，名称来自 "stale-while-revalidate"。

```jsx
// 安装: npm install swr

// UserList.js
import React from 'react';
import useSWR, { mutate } from 'swr';

// 获取用户列表
const fetchUsers = async () => {
  const response = await fetch('/api/users');
  if (!response.ok) {
    throw new Error('Failed to fetch users');
  }
  return response.json();
};

// 添加用户
const addUser = async (user) => {
  const response = await fetch('/api/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(user)
  });
  if (!response.ok) {
    throw new Error('Failed to add user');
  }
  return response.json();
};

function UserList() {
  // 使用 SWR 获取用户列表
  const { data: users, error } = useSWR('/api/users', fetchUsers, {
    revalidateOnFocus: false,
    dedupingInterval: 5 * 60 * 1000 // 5分钟内不重复请求
  });
  
  const [isAdding, setIsAdding] = useState(false);
  
  const handleAddUser = async () => {
    setIsAdding(true);
    try {
      const newUser = {
        name: 'New User',
        email: 'newuser@example.com'
      };
      await addUser(newUser);
      // 重新获取数据
      mutate('/api/users');
    } catch (error) {
      console.error('Failed to add user:', error);
    } finally {
      setIsAdding(false);
    }
  };
  
  if (!users) return <div>加载中...</div>;
  if (error) return <div>出错了: {error.message}</div>;
  
  return (
    <div>
      <button onClick={handleAddUser} disabled={isAdding}>
        {isAdding ? '添加中...' : '添加用户'}
      </button>
      
      <ul>
        {users.map(user => (
          <li key={user.id}>{user.name} ({user.email})</li>
        ))}
      </ul>
    </div>
  );
}
```

### 5.3 Vue Query (VueUse)

VueUse 提供了一系列实用的 Composition API，包括用于数据获取的 `useFetch` 和 `useAsyncState`。

```vue
<!-- UserList.vue -->
<template>
  <div>
    <button @click="handleAddUser" :disabled="isAdding">
      {{ isAdding ? '添加中...' : '添加用户' }}
    </button>
    
    <div v-if="isLoading">加载中...</div>
    <div v-else-if="error">出错了: {{ error.message }}</div>
    <ul v-else>
      <li v-for="user in users" :key="user.id">
        {{ user.name }} ({{ user.email }})
      </li>
    </ul>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import { useAsyncState } from '@vueuse/core';

// 获取用户列表
const fetchUsers = async () => {
  const response = await fetch('/api/users');
  if (!response.ok) {
    throw new Error('Failed to fetch users');
  }
  return response.json();
};

// 添加用户
const addUser = async (user) => {
  const response = await fetch('/api/users', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify(user)
  });
  if (!response.ok) {
    throw new Error('Failed to add user');
  }
  return response.json();
};

const { state: users, isLoading, error, execute: refetch } = useAsyncState(
  fetchUsers,
  [],
  { immediate: true }
);

const isAdding = ref(false);

const handleAddUser = async () => {
  isAdding.value = true;
  try {
    const newUser = {
      name: 'New User',
      email: 'newuser@example.com'
    };
    await addUser(newUser);
    // 重新获取数据
    refetch();
  } catch (error) {
    console.error('Failed to add user:', error);
  } finally {
    isAdding.value = false;
  }
};
</script>
```

## 6. 状态持久化

### 6.1 Redux Persist

Redux Persist 用于将 Redux 状态持久化到本地存储。

```jsx
// store.js
import { createStore } from 'redux';
import { persistStore, persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage'; // 默认使用 localStorage

// 定义初始状态和 reducer
const initialState = {
  count: 0,
  user: null
};

function rootReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    case 'SET_USER':
      return { ...state, user: action.payload };
    default:
      return state;
  }
}

// 配置持久化
const persistConfig = {
  key: 'root', // 存储的键名
  storage, // 存储引擎
  whitelist: ['user'] // 只持久化 user 状态
};

// 创建持久化 reducer
const persistedReducer = persistReducer(persistConfig, rootReducer);

// 创建 store
export const store = createStore(persistedReducer);
export const persistor = persistStore(store);

// App.js
import React from 'react';
import { Provider } from 'react-redux';
import { PersistGate } from 'redux-persist/integration/react';
import { store, persistor } from './store';
import Counter from './Counter';

function App() {
  return (
    <Provider store={store}>
      <PersistGate loading={<div>加载中...</div>} persistor={persistor}>
        <div>
          <h1>Redux Persist 示例</h1>
          <Counter />
        </div>
      </PersistGate>
    </Provider>
  );
}
```

### 6.2 Vuex-Persist

Vuex-Persist 用于将 Vuex 状态持久化到本地存储。

```javascript
// store.js
import { createStore } from 'vuex';
import VuexPersistence from 'vuex-persist';

// 创建 vuex-persist 实例
const vuexLocal = new VuexPersistence({
  storage: window.localStorage,
  key: 'vuex-state',
  reducer: (state) => ({
    // 只持久化 user 状态
    user: state.user
  })
});

export default createStore({
  state: {
    count: 0,
    user: null
  },
  mutations: {
    INCREMENT(state) {
      state.count++;
    },
    DECREMENT(state) {
      state.count--;
    },
    SET_USER(state, user) {
      state.user = user;
    }
  },
  actions: {
    increment({ commit }) {
      commit('INCREMENT');
    },
    decrement({ commit }) {
      commit('DECREMENT');
    },
    setUser({ commit }, user) {
      commit('SET_USER', user);
    }
  },
  plugins: [vuexLocal.plugin]
});
```

### 6.3 自定义持久化方案

使用 localStorage 或 sessionStorage 实现自定义持久化方案。

```jsx
// usePersistedState.js
import { useState, useEffect } from 'react';

function usePersistedState(key, defaultValue) {
  // 从 localStorage 获取初始值
  const [state, setState] = useState(() => {
    const storedValue = localStorage.getItem(key);
    return storedValue !== null ? JSON.parse(storedValue) : defaultValue;
  });
  
  // 当状态变化时，更新 localStorage
  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(state));
  }, [key, state]);
  
  return [state, setState];
}

// 使用示例
function App() {
  const [user, setUser] = usePersistedState('user', null);
  const [theme, setTheme] = usePersistedState('theme', 'light');
  
  return (
    <div className={`app theme-${theme}`}>
      {user ? (
        <div>
          <h1>欢迎, {user.name}</h1>
          <button onClick={() => setUser(null)}>退出登录</button>
        </div>
      ) : (
        <button onClick={() => setUser({ id: 1, name: '张三' })}>登录</button>
      )}
      
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
      </button>
    </div>
  );
}
```

## 7. 状态管理最佳实践

### 7.1 选择合适的状态管理方案

根据应用的复杂度和需求选择合适的状态管理方案：

| 应用类型 | 推荐方案 |
| --- | --- |
| 简单应用 | React: useState/useReducer + Context<br>Vue: ref/reactive + provide/inject |
| 中型应用 | React: Context API 或 Zustand<br>Vue: Pinia |
| 大型应用 | React: Redux Toolkit 或 MobX<br>Vue: Pinia 或 Vuex |
| 服务器状态 | React: React Query 或 SWR<br>Vue: VueUse 或 vue-query |

### 7.2 状态分层

将应用状态分为不同的层次：

1. **UI 状态**：使用组件本地状态管理
2. **页面状态**：使用页面级别的状态管理
3. **领域状态**：使用全局状态管理
4. **服务器状态**：使用专门的服务器状态管理库

```jsx
// UI 状态示例
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false);
  
  return (
    <div>
      <button onClick={() => setIsOpen(!isOpen)}>
        {isOpen ? '关闭' : '打开'}
      </button>
      {isOpen && <div className="dropdown-menu">...</div>}
    </div>
  );
}

// 页面状态示例
function UserListPage() {
  const [filter, setFilter] = useState('');
  const [sortBy, setSortBy] = useState('name');
  
  // 使用 React Query 获取服务器状态
  const { data: users } = useQuery(['users', filter, sortBy], 
    () => fetchUsers({ filter, sortBy })
  );
  
  return (
    <div>
      <input 
        type="text" 
        value={filter} 
        onChange={e => setFilter(e.target.value)} 
        placeholder="搜索用户"
      />
      <select value={sortBy} onChange={e => setSortBy(e.target.value)}>
        <option value="name">按姓名排序</option>
        <option value="email">按邮箱排序</option>
      </select>
      <UserList users={users} />
    </div>
  );
}
```

### 7.3 状态规范化

对于复杂的数据结构，应该进行规范化处理，避免数据重复和不一致。

```jsx
// 不规范化的状态
const state = {
  users: [
    {
      id: 1,
      name: '张三',
      posts: [
        { id: 101, title: '文章1', content: '...' },
        { id: 102, title: '文章2', content: '...' }
      ]
    },
    {
      id: 2,
      name: '李四',
      posts: [
        { id: 103, title: '文章3', content: '...' }
      ]
    }
  ]
};

// 规范化的状态
const normalizedState = {
  users: {
    byId: {
      1: { id: 1, name: '张三', postIds: [101, 102] },
      2: { id: 2, name: '李四', postIds: [103] }
    },
    allIds: [1, 2]
  },
  posts: {
    byId: {
      101: { id: 101, title: '文章1', content: '...', authorId: 1 },
      102: { id: 102, title: '文章2', content: '...', authorId: 1 },
      103: { id: 103, title: '文章3', content: '...', authorId: 2 }
    },
    allIds: [101, 102, 103]
  }
};
```

### 7.4 不可变性

保持状态的不可变性，避免直接修改状态。

```jsx
// 不好的做法：直接修改状态
function updateUser(state, userId, updates) {
  const user = state.users.find(user => user.id === userId);
  user.name = updates.name; // 直接修改状态
  return state;
}

// 好的做法：创建新的状态
function updateUser(state, userId, updates) {
  return {
    ...state,
    users: state.users.map(user => 
      user.id === userId ? { ...user, ...updates } : user
    )
  };
}

// 使用 immer 简化不可变更新
import produce from 'immer';

function updateUser(state, userId, updates) {
  return produce(state, draft => {
    const user = draft.users.find(user => user.id === userId);
    if (user) {
      Object.assign(user, updates);
    }
  });
}
```

### 7.5 状态设计原则

1. **最小化状态**：只存储必要的状态，派生状态应通过计算获得
2. **单一数据源**：避免状态重复
3. **状态隔离**：将不相关的状态分开管理
4. **状态本地化**：尽可能将状态保持在最小的作用域内

```jsx
// 不好的做法：存储派生状态
const [items, setItems] = useState([]);
const [filteredItems, setFilteredItems] = useState([]);
const [totalCount, setTotalCount] = useState(0);

useEffect(() => {
  setFilteredItems(items.filter(item => item.active));
  setTotalCount(items.length);
}, [items]);

// 好的做法：计算派生状态
const [items, setItems] = useState([]);
const filteredItems = useMemo(() => 
  items.filter(item => item.active), 
  [items]
);
const totalCount = items.length;
```

## 8. 状态管理调试与测试

### 8.1 Redux DevTools

Redux DevTools 是一个强大的调试工具，可以查看状态变化历史、时间旅行调试等。

```jsx
// 配置 Redux DevTools
import { createStore, applyMiddleware, compose } from 'redux';
import thunk from 'redux-thunk';
import rootReducer from './reducers';

const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;

const store = createStore(
  rootReducer,
  composeEnhancers(applyMiddleware(thunk))
);

// 使用 Redux Toolkit 时自动配置 DevTools
import { configureStore } from '@reduxjs/toolkit';
import rootReducer from './reducers';

const store = configureStore({
  reducer: rootReducer,
  // DevTools 默认启用
});
```

### 8.2 Vue DevTools

Vue DevTools 可以查看 Vuex/Pinia 状态和变化历史。

```javascript
// Vue DevTools 自动检测 Vuex/Pinia
// 无需额外配置
```

### 8.3 测试状态管理

测试 Redux reducer 和 action creators。

```jsx
// reducer.test.js
import reducer from './reducer';

describe('counter reducer', () => {
  it('should return the initial state', () => {
    expect(reducer(undefined, {})).toEqual({ count: 0 });
  });
  
  it('should handle INCREMENT', () => {
    expect(
      reducer({ count: 0 }, { type: 'INCREMENT' })
    ).toEqual({ count: 1 });
  });
  
  it('should handle DECREMENT', () => {
    expect(
      reducer({ count: 1 }, { type: 'DECREMENT' })
    ).toEqual({ count: 0 });
  });
});

// actions.test.js
import configureMockStore from 'redux-mock-store';
import thunk from 'redux-thunk';
import * as actions from './actions';

const middlewares = [thunk];
const mockStore = configureMockStore(middlewares);

describe('async actions', () => {
  it('creates FETCH_USERS_SUCCESS when fetching users has been done', () => {
    // 模拟 fetch API
    global.fetch = jest.fn().mockImplementation(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve([{ id: 1, name: '张三' }])
      })
    );
    
    const expectedActions = [
      { type: 'FETCH_USERS_REQUEST' },
      { type: 'FETCH_USERS_SUCCESS', payload: [{ id: 1, name: '张三' }] }
    ];
    
    const store = mockStore({ users: [] });
    
    return store.dispatch(actions.fetchUsers()).then(() => {
      expect(store.getActions()).toEqual(expectedActions);
    });
  });
});
```

## 9. 状态管理架构案例

### 9.1 电商应用状态管理

```jsx
// 使用 Redux Toolkit 管理电商应用状态
import { configureStore, createSlice } from '@reduxjs/toolkit';

// 产品切片
const productsSlice = createSlice({
  name: 'products',
  initialState: {
    items: [],
    loading: false,
    error: null
  },
  reducers: {
    fetchProductsStart: (state) => {
      state.loading = true;
      state.error = null;
    },
    fetchProductsSuccess: (state, action) => {
      state.items = action.payload;
      state.loading = false;
    },
    fetchProductsFailure: (state, action) => {
      state.loading = false;
      state.error = action.payload;
    }
  }
});

// 购物车切片
const cartSlice = createSlice({
  name: 'cart',
  initialState: {
    items: [],
    total: 0
  },
  reducers: {
    addToCart: (state, action) => {
      const { id, name, price } = action.payload;
      const existingItem = state.items.find(item => item.id === id);
      
      if (existingItem) {
        existingItem.quantity += 1;
      } else {
        state.items.push({ id, name, price, quantity: 1 });
      }
      
      state.total = state.items.reduce(
        (total, item) => total + item.price * item.quantity, 
        0
      );
    },
    removeFromCart: (state, action) => {
      const id = action.payload;
      state.items = state.items.filter(item => item.id !== id);
      
      state.total = state.items.reduce(
        (total, item) => total + item.price * item.quantity, 
        0
      );
    },
    updateQuantity: (state, action) => {
      const { id, quantity } = action.payload;
      const item = state.items.find(item => item.id === id);
      
      if (item) {
        item.quantity = quantity;
      }
      
      state.total = state.items.reduce(
        (total, item) => total + item.price * item.quantity, 
        0
      );
    }
  }
});

// 用户切片
const userSlice = createSlice({
  name: 'user',
  initialState: {
    currentUser: null,
    loading: false,
    error: null
  },
  reducers: {
    loginStart: (state) => {
      state.loading = true;
      state.error = null;
    },
    loginSuccess: (state, action) => {
      state.currentUser = action.payload;
      state.loading = false;
    },
    loginFailure: (state, action) => {
      state.loading = false;
      state.error = action.payload;
    },
    logout: (state) => {
      state.currentUser = null;
    }
  }
});

// 导出 actions
export const { 
  fetchProductsStart, 
  fetchProductsSuccess, 
  fetchProductsFailure 
} = productsSlice.actions;

export const { 
  addToCart, 
  removeFromCart, 
  updateQuantity 
} = cartSlice.actions;

export const { 
  loginStart, 
  loginSuccess, 
  loginFailure, 
  logout 
} = userSlice.actions;

// 异步 action creator
export const fetchProducts = () => async (dispatch) => {
  try {
    dispatch(fetchProductsStart());
    const response = await fetch('/api/products');
    const data = await response.json();
    dispatch(fetchProductsSuccess(data));
  } catch (error) {
    dispatch(fetchProductsFailure(error.message));
  }
};

export const login = (credentials) => async (dispatch) => {
  try {
    dispatch(loginStart());
    const response = await fetch('/api/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(credentials)
    });
    
    if (!response.ok) {
      throw new Error('登录失败');
    }
    
    const user = await response.json();
    dispatch(loginSuccess(user));
  } catch (error) {
    dispatch(loginFailure(error.message));
  }
};

// 配置 store
const store = configureStore({
  reducer: {
    products: productsSlice.reducer,
    cart: cartSlice.reducer,
    user: userSlice.reducer
  }
});

export default store;
```

### 9.2 社交媒体应用状态管理

```jsx
// 使用 MobX 管理社交媒体应用状态
import { makeAutoObservable, runInAction } from 'mobx';

// 用户 Store
class UserStore {
  currentUser = null;
  loading = false;
  error = null;
  
  constructor() {
    makeAutoObservable(this);
  }
  
  async login(credentials) {
    this.loading = true;
    this.error = null;
    
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(credentials)
      });
      
      if (!response.ok) {
        throw new Error('登录失败');
      }
      
      const user = await response.json();
      
      runInAction(() => {
        this.currentUser = user;
        this.loading = false;
      });
    } catch (error) {
      runInAction(() => {
        this.error = error.message;
        this.loading = false;
      });
    }
  }
  
  logout() {
    this.currentUser = null;
  }
  
  get isLoggedIn() {
    return !!this.currentUser;
  }
}

// 帖子 Store
class PostStore {
  posts = [];
  userPosts = {};
  currentPost = null;
  loading = false;
  error = null;
  
  constructor(rootStore) {
    makeAutoObservable(this);
    this.rootStore = rootStore;
  }
  
  async fetchPosts() {
    this.loading = true;
    this.error = null;
    
    try {
      const response = await fetch('/api/posts');
      const data = await response.json();
      
      runInAction(() => {
        this.posts = data;
        this.loading = false;
      });
    } catch (error) {
      runInAction(() => {
        this.error = error.message;
        this.loading = false;
      });
    }
  }
  
  async fetchUserPosts(userId) {
    if (this.userPosts[userId]) {
      return; // 已经获取过该用户的帖子
    }
    
    this.loading = true;
    
    try {
      const response = await fetch(`/api/users/${userId}/posts`);
      const data = await response.json();
      
      runInAction(() => {
        this.userPosts[userId] = data;
        this.loading = false;
      });
    } catch (error) {
      runInAction(() => {
        this.error = error.message;
        this.loading = false;
      });
    }
  }
  
  async createPost(post) {
    this.loading = true;
    
    try {
      const response = await fetch('/api/posts', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(post)
      });
      
      const newPost = await response.json();
      
      runInAction(() => {
        this.posts.unshift(newPost);
        
        // 如果已经获取了该用户的帖子，也更新用户帖子列表
        const userId = this.rootStore.userStore.currentUser.id;
        if (this.userPosts[userId]) {
          this.userPosts[userId].unshift(newPost);
        }
        
        this.loading = false;
      });
    } catch (error) {
      runInAction(() => {
        this.error = error.message;
        this.loading = false;
      });
    }
  }
  
  async likePost(postId) {
    try {
      await fetch(`/api/posts/${postId}/like`, {
        method: 'POST'
      });
      
      runInAction(() => {
        // 更新帖子的点赞数
        const post = this.posts.find(p => p.id === postId);
        if (post) {
          post.likes += 1;
          post.isLiked = true;
        }
        
        // 更新用户帖子列表中的帖子
        Object.values(this.userPosts).forEach(posts => {
          const userPost = posts.find(p => p.id === postId);
          if (userPost) {
            userPost.likes += 1;
            userPost.isLiked = true;
          }
        });
      });
    } catch (error) {
      console.error('Failed to like post:', error);
    }
  }
}

// 评论 Store
class CommentStore {
  comments = {};
  loading = false;
  error = null;
  
  constructor() {
    makeAutoObservable(this);
  }
  
  async fetchComments(postId) {
    if (this.comments[postId]) {
      return; // 已经获取过该帖子的评论
    }
    
    this.loading = true;
    
    try {
      const response = await fetch(`/api/posts/${postId}/comments`);
      const data = await response.json();
      
      runInAction(() => {
        this.comments[postId] = data;
        this.loading = false;
      });
    } catch (error) {
      runInAction(() => {
        this.error = error.message;
        this.loading = false;
      });
    }
  }
  
  async addComment(postId, comment) {
    this.loading = true;
    
    try {
      const response = await fetch(`/api/posts/${postId}/comments`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(comment)
      });
      
      const newComment = await response.json();
      
      runInAction(() => {
        if (!this.comments[postId]) {
          this.comments[postId] = [];
        }
        
        this.comments[postId].push(newComment);
        this.loading = false;
      });
    } catch (error) {
      runInAction(() => {
        this.error = error.message;
        this.loading = false;
      });
    }
  }
}

// 根 Store
class RootStore {
  constructor() {
    this.userStore = new UserStore();
    this.postStore = new PostStore(this);
    this.commentStore = new CommentStore();
  }
}

// 创建 store 实例
const rootStore = new RootStore();

// 使用示例
import React from 'react';
import { observer } from 'mobx-react-lite';

// 帖子列表组件
const PostList = observer(({ store }) => {
  const { postStore, userStore } = store;
  
  React.useEffect(() => {
    postStore.fetchPosts();
  }, [postStore]);
  
  if (postStore.loading) {
    return <div>加载中...</div>;
  }
  
  if (postStore.error) {
    return <div>出错了: {postStore.error}</div>;
  }
  
  return (
    <div>
      {userStore.isLoggedIn && (
        <button onClick={() => /* 打开创建帖子表单 */}>
          创建帖子
        </button>
      )}
      
      <div className="post-list">
        {postStore.posts.map(post => (
          <div key={post.id} className="post-item">
            <h3>{post.title}</h3>
            <p>{post.content}</p>
            <div className="post-meta">
              <span>作者: {post.author.name}</span>
              <span>点赞: {post.likes}</span>
              <button onClick={() => postStore.likePost(post.id)}>
                {post.isLiked ? '已点赞' : '点赞'}
              </button>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
});

// 用户资料组件
const UserProfile = observer(({ store, userId }) => {
  const { userStore, postStore } = store;
  
  React.useEffect(() => {
    postStore.fetchUserPosts(userId);
  }, [postStore, userId]);
  
  const userPosts = postStore.userPosts[userId] || [];
  
  return (
    <div className="user-profile">
      <h2>用户资料</h2>
      {/* 用户信息 */}
      
      <h3>用户帖子</h3>
      {postStore.loading ? (
        <div>加载中...</div>
      ) : (
        <div className="user-posts">
          {userPosts.map(post => (
            <div key={post.id} className="post-item">
              <h4>{post.title}</h4>
              <p>{post.content}</p>
            </div>
          ))}
        </div>
      )}
    </div>
  );
});
```

## 10. 微前端架构中的状态管理

在微前端架构中，状态管理面临更多挑战，如跨应用状态共享、状态隔离等。

### 10.1 微前端状态管理策略

1. **应用内状态隔离**：每个微应用维护自己的状态
2. **共享状态**：通过全局状态或事件总线共享状态
3. **主应用状态管理**：主应用管理全局状态，微应用通过接口访问

```jsx
// 主应用中的全局状态管理
import { createContext, useContext, useState } from 'react';

// 创建全局状态上下文
const GlobalStateContext = createContext();

// 全局状态提供者
export function GlobalStateProvider({ children }) {
  const [user, setUser] = useState(null);
  const [theme, setTheme] = useState('light');
  
  // 提供给微应用的状态和方法
  const value = {
    user,
    theme,
    setUser,
    setTheme
  };
  
  return (
    <GlobalStateContext.Provider value={value}>
      {children}
    </GlobalStateContext.Provider>
  );
}

// 在主应用中使用
export function useGlobalState() {
  const context = useContext(GlobalStateContext);
  if (!context) {
    throw new Error('useGlobalState must be used within a GlobalStateProvider');
  }
  return context;
}

// 暴露给微应用的接口
window.microAppAPI = {
  getGlobalState: () => {
    const { user, theme } = window.__GLOBAL_STATE__;
    return { user, theme };
  },
  setGlobalState: (key, value) => {
    // 通过事件触发状态更新
    window.dispatchEvent(
      new CustomEvent('global-state-change', {
        detail: { key, value }
      })
    );
  }
};

// 在微应用中使用全局状态
function MicroApp() {
  const [globalState, setGlobalState] = useState(() => {
    return window.microAppAPI.getGlobalState();
  });
  
  useEffect(() => {
    const handleGlobalStateChange = (event) => {
      const { key, value } = event.detail;
      setGlobalState(prev => ({ ...prev, [key]: value }));
    };
    
    window.addEventListener('global-state-change', handleGlobalStateChange);
    
    return () => {
      window.removeEventListener('global-state-change', handleGlobalStateChange);
    };
  }, []);
  
  const updateGlobalTheme = (theme) => {
    window.microAppAPI.setGlobalState('theme', theme);
  };
  
  return (
    <div>
      <h2>微应用</h2>
      <p>当前主题: {globalState.theme}</p>
      <button onClick={() => updateGlobalTheme('dark')}>
        切换到暗色主题
      </button>
    </div>
  );
}
```

### 10.2 事件总线

使用事件总线实现微应用间的通信和状态同步。

```javascript
// 事件总线实现
class EventBus {
  constructor() {
    this.events = {};
  }
  
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(callback);
    
    return () => this.off(eventName, callback);
  }
  
  off(eventName, callback) {
    if (!this.events[eventName]) return;
    
    this.events[eventName] = this.events[eventName].filter(
      cb => cb !== callback
    );
  }
  
  emit(eventName, data) {
    if (!this.events[eventName]) return;
    
    this.events[eventName].forEach(callback => {
      callback(data);
    });
  }
}

// 创建全局事件总线
window.eventBus = new EventBus();

// 在微应用 A 中发布事件
function MicroAppA() {
  const updateUser = (user) => {
    // 更新本地状态
    setLocalUser(user);
    
    // 发布事件通知其他微应用
    window.eventBus.emit('user-updated', user);
  };
  
  return (
    <div>
      <h2>微应用 A</h2>
      <button onClick={() => updateUser({ id: 1, name: '张三' })}>
        更新用户
      </button>
    </div>
  );
}

// 在微应用 B 中订阅事件
function MicroAppB() {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    // 订阅用户更新事件
    const unsubscribe = window.eventBus.on('user-updated', (updatedUser) => {
      setUser(updatedUser);
    });
    
    return unsubscribe;
  }, []);
  
  return (
    <div>
      <h2>微应用 B</h2>
      {user ? (
        <p>当前用户: {user.name}</p>
      ) : (
        <p>未登录</p>
      )}
    </div>
  );
}
```

## 11. 总结

### 11.1 状态管理选型指南

选择合适的状态管理方案应考虑以下因素：

1. **应用规模和复杂度**：小型应用可以使用简单的状态管理，大型应用需要更强大的解决方案
2. **团队熟悉度**：选择团队熟悉的技术栈
3. **性能需求**：考虑状态更新的频率和数据量
4. **开发效率**：选择能提高开发效率的方案
5. **可维护性**：考虑长期维护的成本
6. **生态系统**：考虑工具和社区支持

### 11.2 状态管理最佳实践总结

1. **状态分层**：将状态按照作用范围分层管理
2. **最小化状态**：只存储必要的状态，派生状态通过计算获得
3. **状态规范化**：对复杂数据结构进行规范化处理
4. **不可变性**：保持状态的不可变性
5. **单一数据源**：避免状态重复
6. **状态隔离**：将不相关的状态分开管理
7. **状态持久化**：根据需要持久化关键状态
8. **性能优化**：避免不必要的状态更新和重新渲染
9. **调试工具**：使用专门的调试工具进行状态调试
10. **测试**：编写单元测试和集成测试验证状态逻辑

### 11.3 未来趋势

1. **原子化状态管理**：如 Recoil、Jotai 等
2. **服务器状态管理专门化**：React Query、SWR 等专门的服务器状态管理工具将更加普及
3. **状态与 UI 分离**：状态逻辑与 UI 渲染逻辑更加分离
4. **跨框架状态管理**：框架无关的状态管理解决方案
5. **实时状态同步**：基于 WebSocket 的实时状态同步方案
6. **AI 辅助状态管理**：使用 AI 辅助优化状态结构和更新逻辑

## 12. 参考资料

1. [Redux 官方文档](https://redux.js.org/)
2. [MobX 官方文档](https://mobx.js.org/)
3. [Vuex 官方文档](https://vuex.vuejs.org/)
4. [Pinia 官方文档](https://pinia.vuejs.org/)
5. [React Query 官方文档](https://tanstack.com/query/latest)
6. [SWR 官方文档](https://swr.vercel.app/)
7. [Recoil 官方文档](https://recoiljs.org/)
8. [Jotai 官方文档](https://jotai.org/)
9. [Zustand 官方文档](https://zustand-demo.pmnd.rs/)
10. [Immer 官方文档](https://immerjs.github.io/immer/)

## 13. 状态管理工具对比

### 13.1 React 状态管理工具对比

| 特性 | Redux | MobX | Zustand | Recoil | Jotai | React Query |
| --- | --- | --- | --- | --- | --- | --- |
| 学习曲线 | 高 | 中 | 低 | 中 | 低 | 低 |
| 样板代码 | 多 | 少 | 少 | 少 | 少 | 少 |
| 不可变性 | 强制 | 可选 | 强制 | 强制 | 强制 | 强制 |
| 性能 | 好 | 很好 | 很好 | 好 | 很好 | 很好 |
| TypeScript 支持 | 好 | 很好 | 很好 | 好 | 很好 | 很好 |
| 开发工具 | 很好 | 好 | 好 | 好 | 好 | 很好 |
| 社区支持 | 很好 | 好 | 中 | 中 | 中 | 很好 |
| 适用场景 | 大型应用 | 中大型应用 | 小中型应用 | 中型应用 | 小中型应用 | 服务器状态 |

### 13.2 Vue 状态管理工具对比

| 特性 | Vuex | Pinia | VueUse | Vue Query |
| --- | --- | --- | --- | --- |
| 学习曲线 | 中 | 低 | 低 | 低 |
| 样板代码 | 中 | 少 | 少 | 少 |
| TypeScript 支持 | 中 | 很好 | 很好 | 很好 |
| 性能 | 好 | 很好 | 很好 | 很好 |
| 开发工具 | 好 | 很好 | 好 | 好 |
| 社区支持 | 很好 | 好 | 好 | 中 |
| 适用场景 | 中大型应用 | 各种规模应用 | 小中型应用 | 服务器状态 |

## 14. 状态管理决策树

选择合适的状态管理方案可以遵循以下决策流程：

1. **是否需要共享状态？**
   - 否：使用组件本地状态（React: useState/useReducer, Vue: ref/reactive）
   - 是：继续下一步

2. **共享状态的范围是什么？**
   - 组件树的一部分：使用上下文（React: Context API, Vue: provide/inject）
   - 整个应用：继续下一步

3. **应用的复杂度如何？**
   - 简单应用：使用简单的全局状态（React: Context + useReducer, Vue: Pinia）
   - 中型应用：使用轻量级状态管理（React: Zustand/Jotai, Vue: Pinia）
   - 复杂应用：使用完整的状态管理方案（React: Redux Toolkit/MobX, Vue: Pinia/Vuex）

4. **是否主要管理服务器数据？**
   - 是：使用专门的服务器状态管理（React: React Query/SWR, Vue: VueUse/vue-query）
   - 否：使用客户端状态管理方案

5. **团队熟悉度如何？**
   - 选择团队最熟悉的技术栈

## 15. 状态管理反模式

在实践中应避免以下状态管理反模式：

### 15.1 状态重复

在多个地方存储相同的状态，导致状态不一致。

```jsx
// 反模式：状态重复
const [users, setUsers] = useState([]);
const [selectedUser, setSelectedUser] = useState(null);
const [userDetails, setUserDetails] = useState(null); // 与 selectedUser 重复

// 正确做法：避免状态重复
const [users, setUsers] = useState([]);
const [selectedUserId, setSelectedUserId] = useState(null);

// 通过计算获取选中的用户
const selectedUser = useMemo(() => 
  users.find(user => user.id === selectedUserId),
  [users, selectedUserId]
);
```

### 15.2 过度全局化

将所有状态都放在全局状态中，导致状态管理复杂化。

```jsx
// 反模式：过度全局化
// store.js
const store = {
  count: 0,
  isModalOpen: false, // 应该是本地状态
  formData: {}, // 应该是本地状态
  users: [],
  products: []
};

// 正确做法：状态分层
// 全局 store 只存储真正需要全局共享的状态
const globalStore = {
  users: [],
  products: []
};

// 组件中使用本地状态
function Modal() {
  const [isOpen, setIsOpen] = useState(false);
  // ...
}

function Form() {
  const [formData, setFormData] = useState({});
  // ...
}
```

### 15.3 过早优化

在应用初期就引入复杂的状态管理方案，增加不必要的复杂性。

```jsx
// 反模式：小应用使用复杂的状态管理
// 为一个只有几个组件的应用设置完整的 Redux 架构

// 正确做法：根据应用规模选择合适的方案
// 小应用使用简单的状态管理
function App() {
  const [count, setCount] = useState(0);
  const [user, setUser] = useState(null);
  
  // 通过 Context 共享状态
  return (
    <UserContext.Provider value={{ user, setUser }}>
      <CountContext.Provider value={{ count, setCount }}>
        <Main />
      </CountContext.Provider>
    </UserContext.Provider>
  );
}
```

### 15.4 忽视不可变性

直接修改状态对象，导致状态更新不可预测。

```jsx
// 反模式：直接修改状态
function updateUser(user) {
  user.name = 'New Name'; // 直接修改对象
  setUser(user); // 不会触发重新渲染，因为引用没变
}

// 正确做法：保持不可变性
function updateUser(user) {
  setUser({ ...user, name: 'New Name' }); // 创建新对象
}
```

### 15.5 过度规范化

过度拆分状态，导致状态管理复杂化。

```jsx
// 反模式：过度规范化
const normalizedState = {
  users: {
    byId: {
      1: { id: 1, name: '张三' }
    },
    allIds: [1]
  },
  posts: {
    byId: {
      101: { id: 101, title: '文章1', authorId: 1 }
    },
    allIds: [101]
  },
  comments: {
    byId: {
      201: { id: 201, content: '评论1', postId: 101, authorId: 1 }
    },
    allIds: [201]
  }
};

// 正确做法：根据实际需求选择合适的规范化程度
// 如果不需要频繁更新和查询评论，可以简化结构
const simplifiedState = {
  users: {
    byId: {
      1: { id: 1, name: '张三' }
    },
    allIds: [1]
  },
  posts: {
    byId: {
      101: { 
        id: 101, 
        title: '文章1', 
        authorId: 1,
        comments: [
          { id: 201, content: '评论1', authorId: 1 }
        ]
      }
    },
    allIds: [101]
  }
};
```

## 16. 总结

状态管理是前端应用开发中的核心挑战之一。选择合适的状态管理方案需要考虑应用的规模、复杂度、团队熟悉度等因素。本文介绍了从本地状态管理到全局状态管理、服务器状态管理的各种方案，以及最佳实践和常见反模式。

在实际开发中，应该根据应用的需求选择最简单且能满足需求的状态管理方案，避免过度设计和不必要的复杂性。随着应用的发展，可以逐步引入更复杂的状态管理方案，以满足不断增长的需求。
我将为您编写一份详细的Vue组件复用技巧指南，适合不同级别的开发者阅读。

```markdown:c:\project\kphub\src\frontend\vue\03-组件\3.4-组件复用技巧.md
---
title: 组件复用技巧
icon: reuse
order: 4
---

# 组件复用技巧

组件复用是提高开发效率的重要手段。本文将介绍Vue组件的复用技巧，包括组件抽象、组件组合、插槽使用、高阶组件、组合式函数等内容，帮助读者掌握组件复用的最佳实践，提高代码的可维护性和复用性。

## 为什么需要组件复用？

在开发中，我们经常会遇到这样的情况：多个页面或功能区域需要使用相似的UI元素或逻辑。如果每次都重新编写这些代码，不仅会浪费时间，还会导致代码冗余、难以维护，甚至可能引入不一致性。

组件复用的核心理念是：**将可重用的UI和逻辑封装成独立的组件，在需要的地方重复使用**。这带来了以下好处：

1. **提高开发效率**：一次编写，多处使用，减少重复劳动
2. **保持一致性**：确保相同功能在不同地方有相同的外观和行为
3. **简化维护**：修改一处代码，所有使用该组件的地方都会更新
4. **促进协作**：团队成员可以共享和重用彼此创建的组件
5. **提高代码质量**：组件经过多次使用和测试，更加稳定可靠

Vue作为一个组件化框架，提供了多种组件复用的方式和技巧。接下来，我们将详细介绍这些技巧，并通过实例展示如何在实际项目中应用它们。

## 基础组件抽象

基础组件抽象是组件复用的第一步，它指的是将常用的UI元素封装成独立的组件，以便在整个应用中重复使用。

### 设计原则

设计可复用的基础组件时，应遵循以下原则：

1. **单一职责**：每个组件应该只做一件事，并做好这件事
2. **高内聚低耦合**：组件内部功能紧密相关，与外部的依赖尽量减少
3. **接口清晰**：提供清晰的props、事件和插槽接口
4. **合理默认值**：为props提供合理的默认值，减少使用时的配置
5. **适当的扩展性**：预留扩展点，但不过度设计

### 实例：按钮组件

以一个按钮组件为例，展示如何抽象基础组件：

```vue
<!-- BaseButton.vue -->
<template>
  <button
    :class="[
      'base-button',
      `base-button--${type}`,
      `base-button--${size}`,
      { 'base-button--disabled': disabled }
    ]"
    :disabled="disabled"
    @click="handleClick"
  >
    <span v-if="loading" class="base-button__loading">
      <slot name="loading">
        <span class="loading-spinner"></span>
      </slot>
    </span>
    <span v-if="icon && !loading" class="base-button__icon">
      <slot name="icon">
        <i :class="icon"></i>
      </slot>
    </span>
    <span class="base-button__content">
      <slot></slot>
    </span>
  </button>
</template>

<script>
export default {
  name: 'BaseButton',
  props: {
    type: {
      type: String,
      default: 'default',
      validator: value => ['default', 'primary', 'success', 'warning', 'danger'].includes(value)
    },
    size: {
      type: String,
      default: 'medium',
      validator: value => ['small', 'medium', 'large'].includes(value)
    },
    icon: {
      type: String,
      default: ''
    },
    loading: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ['click'],
  methods: {
    handleClick(event) {
      if (this.disabled || this.loading) return;
      this.$emit('click', event);
    }
  }
}
</script>

<style scoped>
.base-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  border: 1px solid transparent;
  border-radius: 4px;
  padding: 0 15px;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.3s;
  outline: none;
}

.base-button--default {
  background-color: #f5f5f5;
  border-color: #dcdfe6;
  color: #606266;
}

.base-button--primary {
  background-color: #409eff;
  border-color: #409eff;
  color: #fff;
}

.base-button--success {
  background-color: #67c23a;
  border-color: #67c23a;
  color: #fff;
}

.base-button--warning {
  background-color: #e6a23c;
  border-color: #e6a23c;
  color: #fff;
}

.base-button--danger {
  background-color: #f56c6c;
  border-color: #f56c6c;
  color: #fff;
}

.base-button--small {
  height: 28px;
  font-size: 12px;
}

.base-button--medium {
  height: 36px;
  font-size: 14px;
}

.base-button--large {
  height: 44px;
  font-size: 16px;
}

.base-button--disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

.base-button__loading,
.base-button__icon {
  margin-right: 5px;
}

.loading-spinner {
  display: inline-block;
  width: 14px;
  height: 14px;
  border: 2px solid currentColor;
  border-radius: 50%;
  border-right-color: transparent;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
</style>
```

使用这个按钮组件：

```vue
<template>
  <div>
    <BaseButton>默认按钮</BaseButton>
    <BaseButton type="primary">主要按钮</BaseButton>
    <BaseButton type="success" size="small">成功按钮</BaseButton>
    <BaseButton type="warning" size="large">警告按钮</BaseButton>
    <BaseButton type="danger" disabled>危险按钮</BaseButton>
    <BaseButton type="primary" loading>加载中</BaseButton>
    <BaseButton type="primary" icon="icon-search">搜索</BaseButton>
    
    <!-- 自定义图标 -->
    <BaseButton type="primary">
      <template #icon>
        <svg>...</svg>
      </template>
      自定义图标
    </BaseButton>
  </div>
</template>

<script>
import BaseButton from '@/components/BaseButton.vue'

export default {
  components: {
    BaseButton
  }
}
</script>
```

### 全局注册基础组件

对于常用的基础组件，可以全局注册，避免在每个使用的地方都导入：

```javascript
// Vue 2
// main.js
import Vue from 'vue'
import BaseButton from '@/components/base/BaseButton.vue'
import BaseInput from '@/components/base/BaseInput.vue'
import BaseCard from '@/components/base/BaseCard.vue'

Vue.component('BaseButton', BaseButton)
Vue.component('BaseInput', BaseInput)
Vue.component('BaseCard', BaseCard)
```

```javascript
// Vue 3
// main.js
import { createApp } from 'vue'
import App from './App.vue'
import BaseButton from '@/components/base/BaseButton.vue'
import BaseInput from '@/components/base/BaseInput.vue'
import BaseCard from '@/components/base/BaseCard.vue'

const app = createApp(App)
app.component('BaseButton', BaseButton)
app.component('BaseInput', BaseInput)
app.component('BaseCard', BaseCard)
app.mount('#app')
```

更高效的方式是自动注册所有基础组件：

```javascript
// Vue 2
// main.js
import Vue from 'vue'

// 自动注册 components/base 目录下的所有组件
const requireComponent = require.context(
  './components/base',
  false,
  /Base[A-Z]\w+\.(vue|js)$/
)

requireComponent.keys().forEach(fileName => {
  const componentConfig = requireComponent(fileName)
  const componentName = fileName
    .split('/')
    .pop()
    .replace(/\.\w+$/, '')
  
  Vue.component(componentName, componentConfig.default || componentConfig)
})
```

```javascript
// Vue 3
// main.js
import { createApp } from 'vue'
import App from './App.vue'

const app = createApp(App)

// 自动注册 components/base 目录下的所有组件
const modules = import.meta.glob('./components/base/Base*.vue', { eager: true })

Object.entries(modules).forEach(([path, module]) => {
  const componentName = path
    .split('/')
    .pop()
    .replace(/\.\w+$/, '')
  
  app.component(componentName, module.default)
})

app.mount('#app')
```

## 组件组合模式

组件组合是Vue中一种强大的复用模式，它通过将多个小组件组合成一个更复杂的组件来实现功能复用。

### 组合优于继承

在Vue中，推荐使用组合而非继承来构建组件关系。组合模式更加灵活，能够更好地适应变化。

组合的核心思想是：**将复杂组件分解为多个小组件，然后通过组合这些小组件来构建功能**。

### 实例：表单组件

以一个表单组件为例，展示如何使用组合模式：

```vue
<!-- FormInput.vue -->
<template>
  <div class="form-input">
    <label v-if="label" :for="id" class="form-input__label">
      {{ label }}
      <span v-if="required" class="form-input__required">*</span>
    </label>
    <input
      :id="id"
      :type="type"
      :value="modelValue"
      :placeholder="placeholder"
      :disabled="disabled"
      class="form-input__field"
      @input="$emit('update:modelValue', $event.target.value)"
    />
    <div v-if="error" class="form-input__error">{{ error }}</div>
    <div v-else-if="hint" class="form-input__hint">{{ hint }}</div>
  </div>
</template>

<script>
export default {
  name: 'FormInput',
  props: {
    id: {
      type: String,
      default() {
        return `input-${Date.now()}-${Math.floor(Math.random() * 1000)}`
      }
    },
    label: {
      type: String,
      default: ''
    },
    modelValue: {
      type: [String, Number],
      default: ''
    },
    type: {
      type: String,
      default: 'text'
    },
    placeholder: {
      type: String,
      default: ''
    },
    required: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: String,
      default: ''
    },
    hint: {
      type: String,
      default: ''
    }
  },
  emits: ['update:modelValue']
}
</script>
```

```vue
<!-- FormSelect.vue -->
<template>
  <div class="form-select">
    <label v-if="label" :for="id" class="form-select__label">
      {{ label }}
      <span v-if="required" class="form-select__required">*</span>
    </label>
    <select
      :id="id"
      :value="modelValue"
      :disabled="disabled"
      class="form-select__field"
      @change="$emit('update:modelValue', $event.target.value)"
    >
      <option v-if="placeholder" value="" disabled>{{ placeholder }}</option>
      <option
        v-for="option in options"
        :key="option.value"
        :value="option.value"
      >
        {{ option.label }}
      </option>
    </select>
    <div v-if="error" class="form-select__error">{{ error }}</div>
    <div v-else-if="hint" class="form-select__hint">{{ hint }}</div>
  </div>
</template>

<script>
export default {
  name: 'FormSelect',
  props: {
    id: {
      type: String,
      default() {
        return `select-${Date.now()}-${Math.floor(Math.random() * 1000)}`
      }
    },
    label: {
      type: String,
      default: ''
    },
    modelValue: {
      type: [String, Number],
      default: ''
    },
    options: {
      type: Array,
      required: true
    },
    placeholder: {
      type: String,
      default: ''
    },
    required: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: String,
      default: ''
    },
    hint: {
      type: String,
      default: ''
    }
  },
  emits: ['update:modelValue']
}
</script>
```

```vue
<!-- UserForm.vue -->
<template>
  <form @submit.prevent="submitForm" class="user-form">
    <FormInput
      v-model="form.name"
      label="姓名"
      required
      :error="errors.name"
    />
    <FormInput
      v-model="form.email"
      label="邮箱"
      type="email"
      required
      :error="errors.email"
      hint="请输入有效的邮箱地址"
    />
    <FormSelect
      v-model="form.role"
      label="角色"
      :options="roleOptions"
      required
      :error="errors.role"
    />
    <div class="user-form__actions">
      <BaseButton type="primary" @click="submitForm">提交</BaseButton>
      <BaseButton @click="resetForm">重置</BaseButton>
    </div>
  </form>
</template>

<script>
import FormInput from '@/components/FormInput.vue'
import FormSelect from '@/components/FormSelect.vue'
import BaseButton from '@/components/BaseButton.vue'

export default {
  name: 'UserForm',
  components: {
    FormInput,
    FormSelect,
    BaseButton
  },
  props: {
    initialData: {
      type: Object,
      default: () => ({})
    }
  },
  data() {
    return {
      form: {
        name: this.initialData.name || '',
        email: this.initialData.email || '',
        role: this.initialData.role || ''
      },
      errors: {
        name: '',
        email: '',
        role: ''
      },
      roleOptions: [
        { value: 'admin', label: '管理员' },
        { value: 'editor', label: '编辑' },
        { value: 'user', label: '普通用户' }
      ]
    }
  },
  methods: {
    validateForm() {
      let isValid = true
      this.errors = {
        name: '',
        email: '',
        role: ''
      }
      
      if (!this.form.name) {
        this.errors.name = '请输入姓名'
        isValid = false
      }
      
      if (!this.form.email) {
        this.errors.email = '请输入邮箱'
        isValid = false
      } else if (!/\S+@\S+\.\S+/.test(this.form.email)) {
        this.errors.email = '请输入有效的邮箱地址'
        isValid = false
      }
      
      if (!this.form.role) {
        this.errors.role = '请选择角色'
        isValid = false
      }
      
      return isValid
    },
    submitForm() {
      if (this.validateForm()) {
        this.$emit('submit', { ...this.form })
      }
    },
    resetForm() {
      this.form = {
        name: this.initialData.name || '',
        email: this.initialData.email || '',
        role: this.initialData.role || ''
      }
      this.errors = {
        name: '',
        email: '',
        role: ''
      }
      this.$emit('reset')
    }
  }
}
</script>
```

使用这个表单组件：

```vue
<template>
  <div>
    <h1>用户管理</h1>
    <UserForm
      :initial-data="userData"
      @submit="handleSubmit"
      @reset="handleReset"
    />
  </div>
</template>

<script>
import UserForm from '@/components/UserForm.vue'

export default {
  components: {
    UserForm
  },
  data() {
    return {
      userData: {
        name: 'John Doe',
        email: 'john@example.com',
        role: 'editor'
      }
    }
  },
  methods: {
    handleSubmit(formData) {
      console.log('表单提交:', formData)
      // 处理表单提交
    },
    handleReset() {
      console.log('表单重置')
      // 处理表单重置
    }
  }
}
</script>
```

### 组合的优势

组件组合的优势在于：

1. **灵活性**：可以根据需要组合不同的组件
2. **可维护性**：每个组件负责特定的功能，易于理解和维护
3. **可测试性**：可以独立测试每个小组件
4. **可重用性**：小组件可以在不同的场景中重复使用

## 插槽（Slots）技巧

插槽是Vue中一种强大的内容分发机制，允许父组件向子组件传递内容。通过合理使用插槽，可以大大提高组件的复用性和灵活性。

### 插槽类型

Vue提供了三种类型的插槽：

1. **默认插槽**：没有名字的插槽，用于传递一般内容
2. **具名插槽**：有特定名称的插槽，用于在组件的特定位置分发内容
3. **作用域插槽**：可以访问子组件数据的插槽，用于自定义子组件的部分内容

### 实例：卡片组件

以一个卡片组件为例，展示如何使用不同类型的插槽：

```vue
<!-- BaseCard.vue -->
<template>
  <div class="card" :class="{ 'card--shadow': shadow }">
    <div v-if="$slots.header || title" class="card__header">
      <slot name="header">
        <div class="card__title">{{ title }}</div>
      </slot>
    </div>
    <div class="card__body">
      <slot></slot>
    </div>
    <div v-if="$slots.footer" class="card__footer">
      <slot name="footer"></slot>
    </div>
  </div>
</template>

<script>
export default {
  name: 'BaseCard',
  props: {
    title: {
      type: String,
      default: ''
    },
    shadow: {
      type: Boolean,
      default: true
    }
  }
}
</script>

<style scoped>
.card {
  border-radius: 4px;
  border: 1px solid #ebeef5;
  background-color: #fff;
  overflow: hidden;
  color: #303133;
  transition: 0.3s;
}

.card--shadow {
  box-shadow: 0 2px 12px 0 rgba(0, 0, 0, 0.1);
}

.card__header {
  padding: 18px 20px;
  border-bottom: 1px solid #ebeef5;
  box-sizing: border-box;
}

.card__title {
  font-size: 16px;
  font-weight: bold;
}

.card__body {
  padding: 20px;
}

.card__footer {
  padding: 10px 20px;
  border-top: 1px solid #ebeef5;
}
</style>
```

使用这个卡片组件：

```vue
<template>
  <div>
    <!-- 基本用法 -->
    <BaseCard title="基本卡片">
      <p>这是卡片的内容</p>
    </BaseCard>
    
    <!-- 使用具名插槽自定义头部 -->
    <BaseCard>
      <template #header>
        <div class="custom-header">
          <h3>自定义头部</h3>
          <BaseButton size="small">操作</BaseButton>
        </div>
      </template>
      <p>这是卡片的内容</p>
    </BaseCard>
    
    <!-- 使用具名插槽添加底部 -->
    <BaseCard title="带底部的卡片">
      <p>这是卡片的内容</p>
      <template #footer>
        <div class="card-footer">
          <BaseButton type="primary">确认</BaseButton>
          <BaseButton>取消</BaseButton>
        </div>
      </template>
    </BaseCard>
  </div>
</template>

<script>
import BaseCard from '@/components/BaseCard.vue'
import BaseButton from '@/components/BaseButton.vue'

export default {
  components: {
    BaseCard,
    BaseButton
  }
}
</script>

<style scoped>
.custom-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.card-footer {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
}
</style>
```

### 作用域插槽实例：数据表格

作用域插槽允许子组件向父组件传递数据，父组件可以决定如何渲染这些数据。以一个数据表格组件为例：

```vue
<!-- DataTable.vue -->
<template>
  <div class="data-table">
    <table>
      <thead>
        <tr>
          <th v-for="column in columns" :key="column.key">
            {{ column.title }}
          </th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="(row, rowIndex) in data" :key="rowIndex">
          <td v-for="column in columns" :key="column.key">
            <slot :name="column.key" :row="row" :index="rowIndex">
              {{ row[column.key] }}
            </slot>
          </td>
        </tr>
      </tbody>
    </table>
    <div v-if="data.length === 0" class="data-table__empty">
      <slot name="empty">
        暂无数据
      </slot>
    </div>
  </div>
</template>

<script>
export default {
  name: 'DataTable',
  props: {
    columns: {
      type: Array,
      required: true
    },
    data: {
      type: Array,
      default: () => []
    }
  }
}
</script>

<style scoped>
.data-table {
  width: 100%;
  border-collapse: collapse;
}

table {
  width: 100%;
  border-collapse: collapse;
}

th, td {
  padding: 12px 8px;
  text-align: left;
  border-bottom: 1px solid #ebeef5;
}

th {
  background-color: #f5f7fa;
  color: #606266;
  font-weight: 500;
}

.data-table__empty {
  padding: 30px 0;
  text-align: center;
  color: #909399;
}
</style>
```

使用这个数据表格组件：

```vue
<template>
  <div>
    <h1>用户列表</h1>
    <DataTable :columns="columns" :data="users">
      <!-- 自定义名字列 -->
      <template #name="{ row }">
        <div class="user-name">
          <img :src="row.avatar" class="user-avatar" />
          <span>{{ row.name }}</span>
        </div>
      </template>
      
      <!-- 自定义状态列 -->
      <template #status="{ row }">
        <span :class="['status-tag', `status-tag--${row.status}`]">
          {{ statusMap[row.status] }}
        </span>
      </template>
      
      <!-- 自定义操作列 -->
      <template #actions="{ row }">
        <div class="action-buttons">
          <BaseButton size="small" @click="editUser(row)">编辑</BaseButton>
          <BaseButton size="small" type="danger" @click="deleteUser(row)">删除</BaseButton>
        </div>
      </template>
      
      <!-- 自定义空状态 -->
      <template #empty>
        <div class="empty-state">
          <p>暂无用户数据</p>
          <BaseButton type="primary" @click="addUser">添加用户</BaseButton>
        </div>
      </template>
    </DataTable>
  </div>
</template>

<script>
import DataTable from '@/components/DataTable.vue'
import BaseButton from '@/components/BaseButton.vue'

export default {
  components: {
    DataTable,
    BaseButton
  },
  data() {
    return {
      columns: [
        { key: 'name', title: '姓名' },
        { key: 'email', title: '邮箱' },
        { key: 'role', title: '角色' },
        { key: 'status', title: '状态' },
        { key: 'actions', title: '操作' }
      ],
      users: [
        {
          id: 1,
          name: '张三',
          email: 'zhangsan@example.com',
          role: '管理员',
          status: 'active',
          avatar: '/avatars/1.jpg'
        },
        {
          id: 2,
          name: '李四',
          email: 'lisi@example.com',
          role: '编辑',
          status: 'inactive',
          avatar: '/avatars/2.jpg'
        }
      ],
      statusMap: {
        active: '活跃',
        inactive: '停用',
        pending: '待审核'
      }
    }
  },
  methods: {
    editUser(user) {
      console.log('编辑用户:', user)
    },
    deleteUser(user) {
      console.log('删除用户:', user)
    },
    addUser() {
      console.log('添加用户')
    }
  }
}
</script>

<style scoped>
.user-name {
  display: flex;
  align-items: center;
}

.user-avatar {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  margin-right: 8px;
}

.status-tag {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 12px;
}

.status-tag--active {
  background-color: #f0f9eb;
  color: #67c23a;
}

.status-tag--inactive {
  background-color: #f4f4f5;
  color: #909399;
}

.status-tag--pending {
  background-color: #fdf6ec;
  color: #e6a23c;
}

.action-buttons {
  display: flex;
  gap: 8px;
}

.empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 16px;
}
</style>
```

### 插槽的最佳实践

使用插槽时，应遵循以下最佳实践：

1. **提供默认内容**：为插槽提供默认内容，使组件在不传递内容时也能正常工作
2. **使用具名插槽**：当组件有多个插槽时，使用具名插槽明确指定内容的位置
3. **使用作用域插槽**：当需要访问子组件数据时，使用作用域插槽
4. **文档化插槽**：在组件文档中清晰说明每个插槽的用途和可用的作用域属性

## 高阶组件（HOC）

高阶组件（Higher-Order Component，HOC）是一种组件复用模式，它接收一个组件作为参数，并返回一个新的增强组件。这种模式源自React，但在Vue中也有应用。

### 高阶组件的实现

在Vue中，高阶组件通常通过工厂函数实现：

```javascript我将继续编写Vue组件复用技巧的内容，接着上次的高阶组件部分。

```markdown:c:\project\kphub\src\frontend\vue\03-组件\3.4-组件复用技巧.md
### 高阶组件的实现

在Vue中，高阶组件通常通过工厂函数实现：

```javascript
// withLoading.js
import LoadingSpinner from '@/components/LoadingSpinner.vue'

export default function withLoading(Component) {
  return {
    name: `WithLoading${Component.name || 'Component'}`,
    props: {
      isLoading: {
        type: Boolean,
        default: false
      },
      ...Component.props
    },
    render(h) {
      return this.isLoading
        ? h(LoadingSpinner)
        : h(Component, {
            props: this.$props,
            attrs: this.$attrs,
            on: this.$listeners,
            scopedSlots: this.$scopedSlots
          })
    }
  }
}
```

使用这个高阶组件：

```vue
<template>
  <div>
    <UserListWithLoading
      :is-loading="loading"
      :users="users"
      @user-click="handleUserClick"
    />
  </div>
</template>

<script>
import UserList from '@/components/UserList.vue'
import withLoading from '@/utils/withLoading'

const UserListWithLoading = withLoading(UserList)

export default {
  components: {
    UserListWithLoading
  },
  data() {
    return {
      loading: true,
      users: []
    }
  },
  created() {
    this.fetchUsers()
  },
  methods: {
    async fetchUsers() {
      this.loading = true
      try {
        // 模拟API请求
        await new Promise(resolve => setTimeout(resolve, 1500))
        this.users = [
          { id: 1, name: '张三' },
          { id: 2, name: '李四' },
          { id: 3, name: '王五' }
        ]
      } catch (error) {
        console.error('获取用户失败:', error)
      } finally {
        this.loading = false
      }
    },
    handleUserClick(user) {
      console.log('点击用户:', user)
    }
  }
}
</script>
```

### 高阶组件的应用场景

高阶组件适用于以下场景：

1. **添加加载状态**：如上例所示，为组件添加加载状态显示
2. **权限控制**：根据用户权限控制组件的显示或行为
3. **数据获取**：为组件注入数据获取逻辑
4. **日志记录**：记录组件的生命周期事件或用户交互
5. **性能监控**：监控组件的渲染性能

### 高阶组件的优缺点

**优点**：
- 逻辑复用：可以将通用逻辑抽取到高阶组件中
- 关注点分离：原始组件只关注自身的核心功能
- 无侵入性：不需要修改原始组件的代码

**缺点**：
- 组件层级嵌套：可能导致组件层级过深
- 命名冲突：props可能会发生冲突
- 调试困难：组件包装可能使调试变得复杂
- 静态类型支持有限：在TypeScript中使用可能不够友好

### 实例：权限控制高阶组件

以权限控制为例，展示高阶组件的实际应用：

```javascript
// withPermission.js
import { hasPermission } from '@/utils/auth'
import NoPermission from '@/components/NoPermission.vue'

export default function withPermission(Component, requiredPermission) {
  return {
    name: `WithPermission${Component.name || 'Component'}`,
    functional: true,
    render(h, context) {
      const { props, data, children } = context
      
      // 检查用户是否有所需权限
      if (!hasPermission(requiredPermission)) {
        return h(NoPermission, {
          props: {
            requiredPermission
          }
        })
      }
      
      // 如果有权限，渲染原始组件
      return h(Component, data, children)
    }
  }
}
```

使用这个权限控制高阶组件：

```vue
<template>
  <div>
    <h1>用户管理</h1>
    <UserManagement />
  </div>
</template>

<script>
import UserManagementBase from '@/components/UserManagementBase.vue'
import withPermission from '@/utils/withPermission'

// 创建需要"admin"权限的用户管理组件
const UserManagement = withPermission(UserManagementBase, 'admin')

export default {
  components: {
    UserManagement
  }
}
</script>
```

## 组合式函数（Composables）

组合式函数（Composables）是Vue 3引入的一种新的代码复用方式，它基于组合式API（Composition API），允许将逻辑封装为可重用的函数。

### 组合式函数的基本结构

组合式函数通常是一个以"use"开头的函数，它封装了特定的逻辑，并返回响应式状态和方法：

```javascript
// useCounter.js
import { ref, computed } from 'vue'

export function useCounter(initialValue = 0) {
  // 状态
  const count = ref(initialValue)
  
  // 计算属性
  const doubleCount = computed(() => count.value * 2)
  
  // 方法
  function increment() {
    count.value++
  }
  
  function decrement() {
    count.value--
  }
  
  function reset() {
    count.value = initialValue
  }
  
  // 返回状态和方法
  return {
    count,
    doubleCount,
    increment,
    decrement,
    reset
  }
}
```

使用这个组合式函数：

```vue
<template>
  <div>
    <h2>计数器: {{ count }}</h2>
    <p>双倍值: {{ doubleCount }}</p>
    <button @click="increment">增加</button>
    <button @click="decrement">减少</button>
    <button @click="reset">重置</button>
  </div>
</template>

<script setup>
import { useCounter } from '@/composables/useCounter'

// 使用组合式函数
const { count, doubleCount, increment, decrement, reset } = useCounter(10)
</script>
```

### 实例：数据获取组合式函数

以数据获取为例，展示组合式函数的实际应用：

```javascript
// useFetch.js
import { ref, computed, watchEffect } from 'vue'

export function useFetch(getUrl, options = {}) {
  const data = ref(null)
  const error = ref(null)
  const loading = ref(false)
  
  // 计算属性
  const isLoading = computed(() => loading.value)
  const hasError = computed(() => error.value !== null)
  const hasData = computed(() => data.value !== null)
  
  // 获取数据的方法
  async function fetchData() {
    loading.value = true
    error.value = null
    
    try {
      const url = typeof getUrl === 'function' ? getUrl() : getUrl
      const response = await fetch(url, options)
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      
      data.value = await response.json()
    } catch (e) {
      error.value = e
      console.error('获取数据失败:', e)
    } finally {
      loading.value = false
    }
  }
  
  // 刷新数据
  function refresh() {
    return fetchData()
  }
  
  // 初始获取数据
  if (options.immediate !== false) {
    fetchData()
  }
  
  // 如果URL是响应式的，当URL变化时重新获取数据
  if (typeof getUrl === 'function') {
    watchEffect(() => {
      fetchData()
    })
  }
  
  return {
    data,
    error,
    loading,
    isLoading,
    hasError,
    hasData,
    refresh
  }
}
```

使用这个数据获取组合式函数：

```vue
<template>
  <div>
    <h1>用户列表</h1>
    <div v-if="isLoading">加载中...</div>
    <div v-else-if="hasError">加载失败: {{ error.message }}</div>
    <ul v-else-if="hasData">
      <li v-for="user in data" :key="user.id">
        {{ user.name }} ({{ user.email }})
      </li>
    </ul>
    <button @click="refresh">刷新</button>
  </div>
</template>

<script setup>
import { useFetch } from '@/composables/useFetch'

const {
  data,
  error,
  isLoading,
  hasError,
  hasData,
  refresh
} = useFetch('https://jsonplaceholder.typicode.com/users')
</script>
```

### 组合多个组合式函数

组合式函数的一个强大特性是可以组合使用多个函数，构建更复杂的逻辑：

```vue
<template>
  <div>
    <h1>用户管理</h1>
    <div v-if="isLoading">加载中...</div>
    <div v-else-if="hasError">加载失败: {{ error.message }}</div>
    <div v-else>
      <input v-model="searchQuery" placeholder="搜索用户..." />
      <ul>
        <li v-for="user in filteredUsers" :key="user.id">
          {{ user.name }} ({{ user.email }})
          <button @click="selectUser(user)">选择</button>
        </li>
      </ul>
      <div v-if="selectedUser">
        <h2>已选择用户: {{ selectedUser.name }}</h2>
        <button @click="increment">点击次数: {{ count }}</button>
      </div>
    </div>
  </div>
</template>

<script setup>
import { computed, ref } from 'vue'
import { useFetch } from '@/composables/useFetch'
import { useCounter } from '@/composables/useCounter'
import { useSelection } from '@/composables/useSelection'
import { useSearch } from '@/composables/useSearch'

// 获取用户数据
const {
  data: users,
  error,
  isLoading,
  hasError,
  refresh
} = useFetch('https://jsonplaceholder.typicode.com/users')

// 用户选择逻辑
const { selectedItem: selectedUser, selectItem: selectUser } = useSelection()

// 计数器逻辑
const { count, increment } = useCounter()

// 搜索逻辑
const searchQuery = ref('')
const filteredUsers = computed(() => {
  if (!users.value) return []
  
  const query = searchQuery.value.toLowerCase()
  if (!query) return users.value
  
  return users.value.filter(user => 
    user.name.toLowerCase().includes(query) || 
    user.email.toLowerCase().includes(query)
  )
})
</script>
```

### 组合式函数的最佳实践

使用组合式函数时，应遵循以下最佳实践：

1. **命名规范**：使用"use"前缀命名组合式函数，如`useCounter`、`useFetch`
2. **返回对象**：返回一个包含状态和方法的对象，便于解构使用
3. **参数设计**：设计合理的参数，提供默认值和选项对象
4. **错误处理**：妥善处理可能的错误，并提供错误状态
5. **清理资源**：如果在组合式函数中设置了副作用（如事件监听器），提供清理方法
6. **文档化**：为组合式函数提供清晰的文档，说明参数、返回值和用法

### 组合式函数与高阶组件的比较

组合式函数和高阶组件都是代码复用的方式，但有以下区别：

| 特性 | 组合式函数 | 高阶组件 |
| --- | --- | --- |
| 适用版本 | Vue 3（也可在Vue 2.7+使用） | Vue 2和Vue 3 |
| 实现方式 | 基于组合式API的函数 | 包装组件的工厂函数 |
| 组件层级 | 不增加组件层级 | 增加组件层级 |
| 代码组织 | 在setup函数内组合 | 在组件外部包装 |
| 类型支持 | 良好的TypeScript支持 | TypeScript支持有限 |
| 调试难度 | 相对简单 | 相对复杂 |
| 性能影响 | 较小 | 可能较大 |

在Vue 3中，推荐使用组合式函数而非高阶组件进行逻辑复用。

## 混入（Mixins）

混入（Mixins）是Vue 2中常用的一种代码复用方式，它允许将组件选项混合到组件中。虽然在Vue 3中不再推荐使用混入（推荐使用组合式函数），但在许多Vue 2项目中仍然广泛使用。

### 混入的基本用法

定义一个混入对象：

```javascript
// dateFomatMixin.js
export default {
  data() {
    return {
      dateFormatOptions: {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      }
    }
  },
  methods: {
    formatDate(date) {
      if (!date) return ''
      
      const dateObj = new Date(date)
      return dateObj.toLocaleDateString(undefined, this.dateFormatOptions)
    }
  }
}
```

在组件中使用混入：

```vue
<template>
  <div>
    <h1>文章列表</h1>
    <ul>
      <li v-for="article in articles" :key="article.id">
        <h3>{{ article.title }}</h3>
        <p>发布日期: {{ formatDate(article.publishDate) }}</p>
      </li>
    </ul>
  </div>
</template>

<script>
import dateFormatMixin from '@/mixins/dateFormatMixin'

export default {
  mixins: [dateFormatMixin],
  data() {
    return {
      articles: [
        { id: 1, title: '文章1', publishDate: '2023-01-15' },
        { id: 2, title: '文章2', publishDate: '2023-02-20' },
        { id: 3, title: '文章3', publishDate: '2023-03-10' }
      ]
    }
  }
}
</script>
```

### 全局混入

可以注册全局混入，它将影响所有组件：

```javascript
// main.js
import Vue from 'vue'
import App from './App.vue'
import globalMixin from './mixins/globalMixin'

Vue.mixin(globalMixin)

new Vue({
  render: h => h(App)
}).$mount('#app')
```

**注意**：全局混入应谨慎使用，因为它会影响每个组件实例。

### 混入的合并策略

当组件和混入对象含有同名选项时，这些选项将按照一定的策略进行合并：

1. **data对象**：递归合并，组件数据优先
2. **钩子函数**：合并为数组，混入对象的钩子先调用
3. **methods、components、directives等对象**：合并为同一个对象，组件选项优先

### 混入的优缺点

**优点**：
- 代码复用：可以在多个组件之间共享代码
- 简单易用：使用简单，无需额外的设置
- 适合Vue 2：在Vue 2中是主要的代码复用方式

**缺点**：
- 命名冲突：可能导致属性和方法的命名冲突
- 来源不明确：难以追踪属性和方法的来源
- 隐式依赖：组件与混入之间创建了隐式依赖
- 可维护性差：随着混入数量增加，维护变得困难

### 从混入迁移到组合式函数

在Vue 3中，推荐使用组合式函数替代混入。以下是将上面的日期格式化混入转换为组合式函数的示例：

```javascript
// useDateFormat.js
import { reactive, computed } from 'vue'

export function useDateFormat(options = {}) {
  const dateFormatOptions = reactive({
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    ...options
  })
  
  function formatDate(date) {
    if (!date) return ''
    
    const dateObj = new Date(date)
    return dateObj.toLocaleDateString(undefined, dateFormatOptions)
  }
  
  return {
    dateFormatOptions,
    formatDate
  }
}
```

使用组合式函数：

```vue
<template>
  <div>
    <h1>文章列表</h1>
    <ul>
      <li v-for="article in articles" :key="article.id">
        <h3>{{ article.title }}</h3>
        <p>发布日期: {{ formatDate(article.publishDate) }}</p>
      </li>
    </ul>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { useDateFormat } from '@/composables/useDateFormat'

const { formatDate } = useDateFormat()

const articles = ref([
  { id: 1, title: '文章1', publishDate: '2023-01-15' },
  { id: 2, title: '文章2', publishDate: '2023-02-20' },
  { id: 3, title: '文章3', publishDate: '2023-03-10' }
])
</script>
```

## 渲染函数与JSX

对于一些复杂的组件复用场景，使用模板可能不够灵活。Vue提供了渲染函数和JSX支持，允许更灵活地创建和复用组件。

### 渲染函数基础

渲染函数是一个返回虚拟DOM的函数，它提供了比模板更底层的控制：

```javascript
// Vue 2
export default {
  props: ['level', 'title'],
  render(h) {
    return h(
      'h' + this.level,
      {
        attrs: {
          class: 'title'
        },
        on: {
          click: this.onClick
        }
      },
      this.title
    )
  },
  methods: {
    onClick() {
      this.$emit('click')
    }
  }
}
```

```javascript
// Vue 3
import { h } from 'vue'

export default {
  props: ['level', 'title'],
  setup(props, { emit }) {
    const onClick = () => {
      emit('click')
    }
    
    return () => h(
      'h' + props.level,
      {
        class: 'title',
        onClick
      },
      props.title
    )
  }
}
```

### 使用JSX

JSX提供了一种更接近HTML的语法来编写渲染函数：

```jsx
// Vue 2 with JSX
export default {
  props: ['level', 'title'],
  render() {
    const Tag = `h${this.level}`
    return (
      <Tag class="title" onClick={this.onClick}>
        {this.title}
      </Tag>
    )
  },
  methods: {
    onClick() {
      this.$emit('click')
    }
  }
}
```

```jsx
// Vue 3 with JSX
import { defineComponent } from 'vue'

export default defineComponent({
  props: ['level', 'title'],
  setup(props, { emit }) {
    const onClick = () => {
      emit('click')
    }
    
    return () => {
      const Tag = `h${props.level}`
      return (
        <Tag class="title" onClick={onClick}>
          {props.title}
        </Tag>
      )
    }
  }
})
```

### 实例：可复用的表单控件包装器

使用渲染函数创建一个可复用的表单控件包装器：

```jsx
// FormField.jsx
import { defineComponent, h } from 'vue'

export default defineComponent({
  name: 'FormField',
  props: {
    label: {
      type: String,
      required: true
    },
    error: {
      type: String,
      default: ''
    },
    hint: {
      type: String,
      default: ''
    },
    required: {
      type: Boolean,
      default: false
    }
  },
  setup(props, { slots }) {
    return () => (
      <div class="form-field">
        <label class="form-field__label">
          {props.label}
          {props.required && <span class="form-field__required">*</span>}
        </label>
        <div class="form-field__control">
          {slots.default && slots.default()}
        </div>
        {props.error ? (
          <div class="form-field__error">{props.error}</div>
        ) : props.hint ? (
          <div class="form-field__hint">{props.hint}</div>
        ) : null}
      </div>
    )
  }
})
```

使用这个表单控件包装器：

```vue
<template>
  <div>
    <form @submit.prevent="submitForm">
      <FormField
        label="用户名"
        required
        :error="errors.username"
        hint="请输入您的用户名"
      >
        <input v-model="form.username" />
      </FormField>
      
      <FormField
        label="邮箱"
        required
        :error="errors.email"
      >
        <input v-model="form.email" type="email" />
      </FormField>
      
      <FormField
        label="密码"
        required
        :error="errors.password"
        hint="至少8个字符"
      >
        <input v-model="form.password" type="password" />
      </FormField>
      
      <button type="submit">注册</button>
    </form>
  </div>
</template>

<script>
import FormField from '@/components/FormField.jsx'

export default {
  components: {
    FormField
  },
  data() {
    return {
      form: {
        username: '',
        email: '',
        password: ''
      },
      errors: {
        username: '',
        email: '',
        password: ''
      }
    }
  },
  methods: {
    submitForm() {
      // 表单验证和提交逻辑
    }
  }
}
</script>
```

### 渲染函数与JSX的优缺点

**优点**：
- 灵活性：提供比模板更高的灵活性
- 动态性：可以根据条件动态创建元素
- 编程能力：可以使用完整的JavaScript能力
- 适合复杂场景：适合需要高度定制的组件

**缺点**：
- 学习曲线：相比模板有更陡的学习曲线
- 可读性：对于简单组件，可读性不如模板
- 工具支持：IDE和工具的支持可能不如模板完善
- 配置复杂：需要额外的配置支持JSX

## 组件库设计

在大型项目或团队中，可能需要构建自己的组件库。以下是设计组件库的一些最佳实践：

### 组件分类

将组件按功能和复杂度分类：

1. **基础组件**：按钮、输入框、选择器等基本UI元素
2. **表单组件**：表单、表单项、验证等
3. **数据展示组件**：表格、列表、卡片等
4. **反馈组件**：对话框、通知、加载器等
5. **导航组件**：菜单、标签页、面包屑等
6. **布局组件**：栅格、分割面板、容器等

### 组件设计原则

设计组件库时，应遵循以下原则：

1. **一致性**：保持API和行为的一致性
2. **可组合性**：组件可以相互组合
3. **可扩展性**：预留扩展点，支持自定义
4. **可访问性**：符合WCAG等可访问性标准
5. **性能优化**：注重组件的性能表现
6. **文档完善**：提供详细的文档和示例

### 组件库结构示例

```
components/
  ├── base/                # 基础组件
  │   ├── Button.vue
  │   ├── Input.vue
  │   └── ...
  ├── form/                # 表单组件
  │   ├── Form.vue
  │   ├── FormItem.vue
  │   └── ...
  ├── data/                # 数据展示组件
  │   ├── Table.vue
  │   ├── Pagination.vue
  │   └── ...
  ├── feedback/            # 反馈组件
  │   ├── Modal.vue
  │   ├── Notification.vue
  │   └── ...
  └── ...
```

### 组件文档化

为组件提供详细的文档，包括：

1. **组件描述**：组件的功能和用途
2. **Props**：组件接受的属性及其类型、默认值和说明
3. **事件**：组件触发的事件及其参数
4. **插槽**：组件提供的插槽及其用途
5. **示例**：组件的使用示例
6. **最佳实践**：使用组件的最佳实践和注意事项

可以使用工具如Storybook、VuePress或VitePress构建组件文档。

## 总结与最佳实践

Vue提供了多种组件复用的方式，每种方式都有其适用场景和优缺点。以下是选择合适复用方式的指南：

### 复用方式选择指南

1. **基础组件抽象**：适用于UI元素的复用，如按钮、输入框等
2. **组件组合**：适用于将多个小组件组合成更复杂的组件
3. **插槽**：适用于需要自定义组件内部内容的场景
4. **高阶组件**：适用于需要增强现有组件功能的场景（Vue 2）
5. **组合式函数**：适用于逻辑复用，特别是在Vue 3中（推荐）
6. **混入**：适用于在Vue 2中共享组件选项（不推荐在Vue 3中使用）
7. **渲染函数与JSX**：适用于需要高度动态和灵活的组件

### Vue 2与Vue 3的复用方式对比

| 复用方式 | Vue 2 | Vue 3 | 推荐度 |
| --- | --- | --- | --- |
| 基础组件抽象 | ✅ | ✅ | 高 |
| 组件组合 | ✅ | ✅ | 高 |
| 插槽 | ✅ | ✅ | 高 |
| 高阶组件 | ✅ | ✅ | 中（Vue 2）/ 低（Vue 3） |
| 组合式函数 | ❌（2.7+支持） | ✅ | 高（Vue 3） |
| 混入 | ✅ | ✅（不推荐） | 中（Vue 2）/ 低（Vue 3） |
| 渲染函数与JSX | ✅ | ✅ | 中（特定场景） |

### 最佳实践总结

1. **从简单开始**：先尝试使用基础组件和组件组合
2. **合理使用插槽**：利用插槽提高组件的灵活性
3. **在Vue 3中优先使用组合式函数**：组合式函数是Vue 3中推荐的逻辑复用方式
4. **避免过度抽象**：只有当多处需要相同功能时才进行抽象
5. **保持一致性**：在整个项目中保持一致的组件设计和API
6. **文档化**：为可复用组件和函数提供详细的文档
7. **测试**：为可复用组件和函数编写测试，确保其质量和稳定性

通过合理运用这些组件复用技巧，可以显著提高开发效率，减少代码冗余，提升代码质量和可维护性。在实际项目中，应根据具我将继续编写Vue组件复用技巧的内容，接着上次的总结部分。

```markdown:c:\project\kphub\src\frontend\vue\03-组件\3.4-组件复用技巧.md
通过合理运用这些组件复用技巧，可以显著提高开发效率，减少代码冗余，提升代码质量和可维护性。在实际项目中，应根据具体需求和场景选择合适的复用方式。

## 实战案例：构建可复用的表单系统

为了更好地理解组件复用技巧的应用，我们将通过一个实战案例来展示如何构建一个可复用的表单系统。这个系统将综合运用前面介绍的多种复用技巧。

### 需求分析

我们需要构建一个表单系统，满足以下需求：

1. 支持常见的表单控件（输入框、选择器、单选框、复选框等）
2. 支持表单验证
3. 支持自定义布局
4. 支持表单数据的收集和提交
5. 可以方便地在不同页面复用

### 系统设计

我们将采用以下复用技巧构建这个系统：

1. **基础组件抽象**：创建基础表单控件
2. **组件组合**：将基础控件组合成表单
3. **插槽**：提供自定义内容的能力
4. **组合式函数**：封装表单验证和数据处理逻辑

### 实现步骤

#### 1. 创建基础表单控件

首先，我们创建一些基础的表单控件：

```vue
<!-- FormInput.vue -->
<template>
  <div class="form-control">
    <input
      :type="type"
      :value="modelValue"
      :placeholder="placeholder"
      :disabled="disabled"
      @input="$emit('update:modelValue', $event.target.value)"
      @blur="handleBlur"
    />
  </div>
</template>

<script>
export default {
  name: 'FormInput',
  props: {
    modelValue: {
      type: [String, Number],
      default: ''
    },
    type: {
      type: String,
      default: 'text'
    },
    placeholder: {
      type: String,
      default: ''
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ['update:modelValue', 'blur'],
  methods: {
    handleBlur(event) {
      this.$emit('blur', event.target.value)
    }
  }
}
</script>
```

```vue
<!-- FormSelect.vue -->
<template>
  <div class="form-control">
    <select
      :value="modelValue"
      :disabled="disabled"
      @change="$emit('update:modelValue', $event.target.value)"
      @blur="$emit('blur', $event.target.value)"
    >
      <option v-if="placeholder" value="" disabled>{{ placeholder }}</option>
      <option
        v-for="option in options"
        :key="option.value"
        :value="option.value"
      >
        {{ option.label }}
      </option>
    </select>
  </div>
</template>

<script>
export default {
  name: 'FormSelect',
  props: {
    modelValue: {
      type: [String, Number],
      default: ''
    },
    options: {
      type: Array,
      required: true
    },
    placeholder: {
      type: String,
      default: ''
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ['update:modelValue', 'blur']
}
</script>
```

#### 2. 创建表单项组件

接下来，创建一个表单项组件，用于包装表单控件：

```vue
<!-- FormItem.vue -->
<template>
  <div class="form-item" :class="{ 'form-item--error': error }">
    <label v-if="label" class="form-item__label">
      {{ label }}
      <span v-if="required" class="form-item__required">*</span>
    </label>
    <div class="form-item__content">
      <slot></slot>
      <div v-if="error" class="form-item__error">{{ error }}</div>
      <div v-else-if="hint" class="form-item__hint">{{ hint }}</div>
    </div>
  </div>
</template>

<script>
export default {
  name: 'FormItem',
  props: {
    label: {
      type: String,
      default: ''
    },
    required: {
      type: Boolean,
      default: false
    },
    error: {
      type: String,
      default: ''
    },
    hint: {
      type: String,
      default: ''
    }
  }
}
</script>

<style scoped>
.form-item {
  margin-bottom: 20px;
}

.form-item__label {
  display: block;
  margin-bottom: 8px;
  font-weight: 500;
}

.form-item__required {
  color: #f56c6c;
  margin-left: 4px;
}

.form-item__error {
  color: #f56c6c;
  font-size: 12px;
  margin-top: 4px;
}

.form-item__hint {
  color: #909399;
  font-size: 12px;
  margin-top: 4px;
}

.form-item--error .form-control {
  border-color: #f56c6c;
}
</style>
```

#### 3. 创建表单组件

然后，创建一个表单组件，用于管理表单项：

```vue
<!-- Form.vue -->
<template>
  <form class="form" @submit.prevent="handleSubmit">
    <slot></slot>
  </form>
</template>

<script>
export default {
  name: 'Form',
  props: {
    model: {
      type: Object,
      required: true
    },
    rules: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ['submit', 'validate'],
  provide() {
    return {
      form: this
    }
  },
  data() {
    return {
      fields: []
    }
  },
  methods: {
    addField(field) {
      this.fields.push(field)
    },
    removeField(field) {
      this.fields = this.fields.filter(item => item !== field)
    },
    async validate() {
      const promises = this.fields.map(field => field.validate())
      const results = await Promise.all(promises)
      const valid = results.every(result => result)
      this.$emit('validate', valid)
      return valid
    },
    async handleSubmit() {
      const valid = await this.validate()
      if (valid) {
        this.$emit('submit', this.model)
      }
    }
  }
}
</script>
```

#### 4. 创建表单项容器组件

创建一个表单项容器组件，用于连接表单和表单项：

```vue
<!-- FormItemContainer.vue -->
<template>
  <FormItem
    :label="label"
    :required="isRequired"
    :error="errorMessage"
    :hint="hint"
  >
    <slot></slot>
  </FormItem>
</template>

<script>
import FormItem from './FormItem.vue'
import { inject, ref, computed, onMounted, onBeforeUnmount } from 'vue'

export default {
  name: 'FormItemContainer',
  components: {
    FormItem
  },
  props: {
    prop: {
      type: String,
      required: true
    },
    label: {
      type: String,
      default: ''
    },
    required: {
      type: Boolean,
      default: false
    },
    rules: {
      type: [Object, Array],
      default: () => ({})
    },
    hint: {
      type: String,
      default: ''
    }
  },
  setup(props) {
    const form = inject('form')
    const errorMessage = ref('')
    
    const isRequired = computed(() => {
      if (props.required) return true
      
      if (Array.isArray(props.rules)) {
        return props.rules.some(rule => rule.required)
      }
      
      return props.rules.required
    })
    
    const fieldValue = computed(() => {
      return form.model[props.prop]
    })
    
    const getRules = () => {
      let formRules = form.rules[props.prop]
      let selfRules = props.rules
      
      if (formRules && selfRules) {
        return [].concat(selfRules, formRules)
      }
      
      return formRules || selfRules || []
    }
    
    const validate = async () => {
      const rules = getRules()
      if (!rules || rules.length === 0) return true
      
      const value = fieldValue.value
      let valid = true
      
      if (Array.isArray(rules)) {
        for (const rule of rules) {
          if (rule.required && (value === undefined || value === null || value === '')) {
            errorMessage.value = rule.message || `${props.label}不能为空`
            valid = false
            break
          }
          
          if (rule.pattern && !rule.pattern.test(value)) {
            errorMessage.value = rule.message || `${props.label}格式不正确`
            valid = false
            break
          }
          
          if (rule.validator && typeof rule.validator === 'function') {
            try {
              await rule.validator(value)
            } catch (error) {
              errorMessage.value = error.message || `${props.label}验证失败`
              valid = false
              break
            }
          }
        }
      }
      
      if (valid) {
        errorMessage.value = ''
      }
      
      return valid
    }
    
    const clearValidate = () => {
      errorMessage.value = ''
    }
    
    onMounted(() => {
      form.addField({
        prop: props.prop,
        validate
      })
    })
    
    onBeforeUnmount(() => {
      form.removeField({
        prop: props.prop
      })
    })
    
    return {
      errorMessage,
      isRequired,
      validate,
      clearValidate
    }
  }
}
</script>
```

#### 5. 创建表单验证组合式函数

创建一个表单验证的组合式函数：

```javascript
// useFormValidation.js
import { ref, reactive } from 'vue'

export function useFormValidation(initialForm = {}, validationRules = {}) {
  const form = reactive({ ...initialForm })
  const errors = reactive({})
  const isSubmitting = ref(false)
  
  // 初始化错误对象
  Object.keys(form).forEach(key => {
    errors[key] = ''
  })
  
  // 验证单个字段
  const validateField = (field) => {
    const rules = validationRules[field]
    const value = form[field]
    
    if (!rules) return true
    
    // 清除之前的错误
    errors[field] = ''
    
    for (const rule of rules) {
      // 必填验证
      if (rule.required && (value === undefined || value === null || value === '')) {
        errors[field] = rule.message || '此字段不能为空'
        return false
      }
      
      // 正则验证
      if (rule.pattern && !rule.pattern.test(value)) {
        errors[field] = rule.message || '格式不正确'
        return false
      }
      
      // 自定义验证函数
      if (rule.validator && typeof rule.validator === 'function') {
        try {
          const result = rule.validator(value)
          if (result === false) {
            errors[field] = rule.message || '验证失败'
            return false
          }
        } catch (error) {
          errors[field] = error.message || '验证失败'
          return false
        }
      }
    }
    
    return true
  }
  
  // 验证所有字段
  const validate = () => {
    let isValid = true
    
    Object.keys(validationRules).forEach(field => {
      if (!validateField(field)) {
        isValid = false
      }
    })
    
    return isValid
  }
  
  // 重置表单
  const resetForm = () => {
    Object.keys(form).forEach(key => {
      form[key] = initialForm[key] || ''
      errors[key] = ''
    })
  }
  
  // 提交表单
  const submitForm = async (submitFn) => {
    if (!validate()) {
      return false
    }
    
    isSubmitting.value = true
    
    try {
      if (typeof submitFn === 'function') {
        await submitFn(form)
      }
      return true
    } catch (error) {
      console.error('表单提交失败:', error)
      return false
    } finally {
      isSubmitting.value = false
    }
  }
  
  return {
    form,
    errors,
    isSubmitting,
    validateField,
    validate,
    resetForm,
    submitForm
  }
}
```

#### 6. 使用这个表单系统

现在，我们可以使用这个表单系统创建一个用户注册表单：

```vue
<!-- UserRegistrationForm.vue -->
<template>
  <div class="user-registration">
    <h2>用户注册</h2>
    <Form :model="form" :rules="rules" @submit="handleSubmit">
      <FormItemContainer
        prop="username"
        label="用户名"
        required
        :rules="[
          { required: true, message: '请输入用户名' },
          { pattern: /^[a-zA-Z0-9_]{4,16}$/, message: '用户名必须是4-16位字母、数字或下划线' }
        ]"
        hint="4-16位字母、数字或下划线"
      >
        <FormInput v-model="form.username" placeholder="请输入用户名" />
      </FormItemContainer>
      
      <FormItemContainer
        prop="email"
        label="邮箱"
        required
        :rules="[
          { required: true, message: '请输入邮箱' },
          { pattern: /\S+@\S+\.\S+/, message: '请输入有效的邮箱地址' }
        ]"
      >
        <FormInput v-model="form.email" type="email" placeholder="请输入邮箱" />
      </FormItemContainer>
      
      <FormItemContainer
        prop="password"
        label="密码"
        required
        :rules="[
          { required: true, message: '请输入密码' },
          { pattern: /^.{6,20}$/, message: '密码长度必须在6-20位之间' }
        ]"
        hint="6-20位字符"
      >
        <FormInput v-model="form.password" type="password" placeholder="请输入密码" />
      </FormItemContainer>
      
      <FormItemContainer
        prop="confirmPassword"
        label="确认密码"
        required
        :rules="[
          { required: true, message: '请确认密码' },
          { validator: validateConfirmPassword, message: '两次输入的密码不一致' }
        ]"
      >
        <FormInput v-model="form.confirmPassword" type="password" placeholder="请确认密码" />
      </FormItemContainer>
      
      <FormItemContainer
        prop="role"
        label="角色"
        required
        :rules="[{ required: true, message: '请选择角色' }]"
      >
        <FormSelect
          v-model="form.role"
          :options="roleOptions"
          placeholder="请选择角色"
        />
      </FormItemContainer>
      
      <div class="form-actions">
        <button type="submit" class="btn btn-primary" :disabled="isSubmitting">
          {{ isSubmitting ? '提交中...' : '注册' }}
        </button>
        <button type="button" class="btn" @click="resetForm">重置</button>
      </div>
    </Form>
  </div>
</template>

<script>
import Form from '@/components/form/Form.vue'
import FormItemContainer from '@/components/form/FormItemContainer.vue'
import FormInput from '@/components/form/FormInput.vue'
import FormSelect from '@/components/form/FormSelect.vue'
import { useFormValidation } from '@/composables/useFormValidation'

export default {
  name: 'UserRegistrationForm',
  components: {
    Form,
    FormItemContainer,
    FormInput,
    FormSelect
  },
  setup() {
    const initialForm = {
      username: '',
      email: '',
      password: '',
      confirmPassword: '',
      role: ''
    }
    
    const roleOptions = [
      { value: 'user', label: '普通用户' },
      { value: 'admin', label: '管理员' },
      { value: 'editor', label: '编辑' }
    ]
    
    const validateConfirmPassword = (value) => {
      return value === form.password
    }
    
    const {
      form,
      errors,
      isSubmitting,
      validate,
      resetForm,
      submitForm
    } = useFormValidation(initialForm)
    
    const rules = {
      username: [
        { required: true, message: '请输入用户名' },
        { pattern: /^[a-zA-Z0-9_]{4,16}$/, message: '用户名必须是4-16位字母、数字或下划线' }
      ],
      email: [
        { required: true, message: '请输入邮箱' },
        { pattern: /\S+@\S+\.\S+/, message: '请输入有效的邮箱地址' }
      ],
      password: [
        { required: true, message: '请输入密码' },
        { pattern: /^.{6,20}$/, message: '密码长度必须在6-20位之间' }
      ],
      confirmPassword: [
        { required: true, message: '请确认密码' },
        { validator: validateConfirmPassword, message: '两次输入的密码不一致' }
      ],
      role: [
        { required: true, message: '请选择角色' }
      ]
    }
    
    const handleSubmit = async () => {
      const success = await submitForm(async (formData) => {
        // 模拟API请求
        console.log('提交的表单数据:', formData)
        await new Promise(resolve => setTimeout(resolve, 1000))
        // 实际项目中这里会调用API
      })
      
      if (success) {
        alert('注册成功！')
        resetForm()
      }
    }
    
    return {
      form,
      rules,
      roleOptions,
      isSubmitting,
      validateConfirmPassword,
      handleSubmit,
      resetForm
    }
  }
}
</script>

<style scoped>
.user-registration {
  max-width: 500px;
  margin: 0 auto;
  padding: 20px;
}

.form-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 20px;
}

.btn {
  padding: 8px 16px;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  background-color: #fff;
  cursor: pointer;
}

.btn-primary {
  background-color: #409eff;
  border-color: #409eff;
  color: #fff;
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
</style>
```

### 复用这个表单系统

现在，我们可以在其他地方复用这个表单系统，例如创建一个登录表单：

```vue
<!-- LoginForm.vue -->
<template>
  <div class="login-form">
    <h2>用户登录</h2>
    <Form :model="form" :rules="rules" @submit="handleSubmit">
      <FormItemContainer
        prop="username"
        label="用户名"
        required
        :rules="[{ required: true, message: '请输入用户名' }]"
      >
        <FormInput v-model="form.username" placeholder="请输入用户名" />
      </FormItemContainer>
      
      <FormItemContainer
        prop="password"
        label="密码"
        required
        :rules="[{ required: true, message: '请输入密码' }]"
      >
        <FormInput v-model="form.password" type="password" placeholder="请输入密码" />
      </FormItemContainer>
      
      <FormItemContainer prop="remember" :label="false">
        <div class="remember-me">
          <input type="checkbox" id="remember" v-model="form.remember" />
          <label for="remember">记住我</label>
        </div>
      </FormItemContainer>
      
      <div class="form-actions">
        <button type="submit" class="btn btn-primary" :disabled="isSubmitting">
          {{ isSubmitting ? '登录中...' : '登录' }}
        </button>
      </div>
    </Form>
  </div>
</template>

<script>
import Form from '@/components/form/Form.vue'
import FormItemContainer from '@/components/form/FormItemContainer.vue'
import FormInput from '@/components/form/FormInput.vue'
import { useFormValidation } from '@/composables/useFormValidation'

export default {
  name: 'LoginForm',
  components: {
    Form,
    FormItemContainer,
    FormInput
  },
  setup() {
    const initialForm = {
      username: '',
      password: '',
      remember: false
    }
    
    const rules = {
      username: [
        { required: true, message: '请输入用户名' }
      ],
      password: [
        { required: true, message: '请输入密码' }
      ]
    }
    
    const {
      form,
      isSubmitting,
      submitForm
    } = useFormValidation(initialForm)
    
    const handleSubmit = async () => {
      const success = await submitForm(async (formData) => {
        // 模拟API请求
        console.log('登录表单数据:', formData)
        await new Promise(resolve => setTimeout(resolve, 1000))
        // 实际项目中这里会调用登录API
      })
      
      if (success) {
        alert('登录成功！')
        // 实际项目中这里会进行路由跳转或其他操作
      }
    }
    
    return {
      form,
      rules,
      isSubmitting,
      handleSubmit
    }
  }
}
</script>

<style scoped>
.login-form {
  max-width: 400px;
  margin: 0 auto;
  padding: 20px;
}

.remember-me {
  display: flex;
  align-items: center;
  gap: 8px;
}

.form-actions {
  margin-top: 20px;
}

.btn {
  padding: 8px 16px;
  border: 1px solid #dcdfe6;
  border-radius: 4px;
  background-color: #fff;
  cursor: pointer;
}

.btn-primary {
  background-color: #409eff;
  border-color: #409eff;
  color: #fff;
}

.btn:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}
</style>
```

### 表单系统的扩展

这个表单系统可以进一步扩展，例如：

1. **添加更多表单控件**：如单选框、复选框、日期选择器等
2. **支持动态表单**：根据配置动态生成表单
3. **支持表单分步**：将复杂表单分成多个步骤
4. **支持表单状态持久化**：保存表单状态到本地存储
5. **支持表单联动**：表单项之间的联动逻辑

## 结语

组件复用是Vue开发中的重要技巧，它可以帮助我们提高开发效率，减少代码冗余，提升代码质量和可维护性。本文介绍了多种组件复用技巧，包括基础组件抽象、组件组合、插槽使用、高阶组件、组合式函数等，并通过实战案例展示了如何综合运用这些技巧构建可复用的表单系统。

在实际项目中，应根据具体需求和场景选择合适的复用方式。对于Vue 3项目，推荐优先使用组合式函数进行逻辑复用；对于UI组件，推荐使用组件组合和插槽提高灵活性和可定制性。

通过合理运用这些组件复用技巧，我们可以构建出更加模块化、可维护和可扩展的Vue应用。
```

这部分内容完成了Vue组件复用技巧的实战案例部分，展示了如何构建一个可复用的表单系统，并通过实例说明了如何在不同场景下复用这个系统。最后总结了组件复用的重要性和选择合适复用方式的建议。
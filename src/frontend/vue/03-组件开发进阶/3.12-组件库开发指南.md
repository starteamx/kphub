我将为您编写一份关于Vue组件库开发指南的详细文档，适合不同级别的开发者阅读。

```markdown:c:\project\kphub\src\frontend\vue\03-组件设计\3.12-组件库开发指南.md
---
title: 组件库开发指南
icon: library
order: 12
---

# 组件库开发指南

组件库是提高开发效率和统一UI风格的重要工具。本文将详细介绍Vue组件库的开发方法和最佳实践，包括架构设计、API设计、主题系统、文档生成、测试策略等内容，帮助读者构建高质量的Vue组件库。

## 为什么需要开发组件库？

在深入组件库开发之前，我们需要理解为什么要开发自己的组件库，而不是直接使用现有的开源组件库。

### 组件库的价值

1. **统一设计语言**：组件库能够确保整个产品线的UI风格一致，提升品牌识别度
2. **提高开发效率**：预先封装好的组件可以大幅减少重复开发工作
3. **降低维护成本**：集中维护组件，而不是在多个项目中维护类似的代码
4. **提升代码质量**：组件库通常有更严格的测试和文档要求，提高整体代码质量
5. **促进团队协作**：提供统一的组件接口，使前端团队和设计团队能更好地协作

### 自研组件库的场景

虽然有很多优秀的开源组件库（如Element Plus、Ant Design Vue等），但在以下场景中，开发自己的组件库可能更为合适：

1. **特殊的设计需求**：公司有独特的设计系统和品牌标识
2. **行业特定组件**：需要开发特定行业的专用组件，如金融图表、医疗表单等
3. **性能优化需求**：针对特定应用场景优化组件性能
4. **定制化程度高**：现有组件库无法满足高度定制化的需求
5. **技术栈限制**：需要支持特定的技术栈或框架版本

## 组件库开发前的准备工作

在开始开发组件库之前，需要做一些准备工作，确保开发过程顺利进行。

### 需求分析

首先，需要明确组件库的目标用户和使用场景：

1. **目标用户**：内部团队还是外部开发者？初级开发者还是高级开发者？
2. **使用场景**：管理系统、电商网站、移动应用还是多端适配？
3. **技术限制**：需要支持哪些浏览器版本？是否需要考虑服务端渲染？
4. **性能要求**：是否有特殊的性能要求，如首屏加载时间、动画流畅度等？

### 设计系统规范

在开发组件库之前，应该先建立完整的设计系统规范：

1. **色彩系统**：主色、辅助色、功能色（成功、警告、错误等）
2. **排版系统**：字体、字号、行高、段落间距等
3. **间距系统**：内边距、外边距、栅格系统等
4. **阴影系统**：不同层级的阴影效果
5. **圆角系统**：不同组件的圆角大小
6. **动效系统**：过渡时间、缓动函数等
7. **图标系统**：统一的图标设计风格和尺寸

### 技术选型

根据需求和团队情况，选择合适的技术栈：

1. **Vue版本**：Vue 2还是Vue 3？是否需要兼容两个版本？
2. **TypeScript**：是否使用TypeScript提供更好的类型支持？
3. **CSS方案**：原生CSS、SCSS/LESS、CSS Modules还是CSS-in-JS？
4. **构建工具**：Vite、Rollup还是Webpack？
5. **包管理器**：npm、yarn还是pnpm？
6. **代码规范**：ESLint、Prettier、StyleLint等
7. **测试框架**：Jest、Vitest、Testing Library等
8. **文档工具**：VitePress、Storybook等

## 组件库架构设计

良好的架构设计是组件库可维护性和可扩展性的基础。

### 目录结构

一个典型的组件库目录结构可能如下：

```
component-library/
├── .github/                 # GitHub相关配置（CI/CD、Issue模板等）
├── build/                   # 构建脚本
├── docs/                    # 文档网站
├── packages/                # 组件包
│   ├── components/          # 所有组件
│   │   ├── button/          # 按钮组件
│   │   │   ├── __tests__/   # 测试文件
│   │   │   ├── src/         # 组件源码
│   │   │   ├── style/       # 组件样式
│   │   │   └── index.ts     # 组件入口
│   │   ├── input/           # 输入框组件
│   │   └── ...              # 其他组件
│   ├── theme/               # 主题相关
│   │   ├── src/             # 主题源码
│   │   └── index.ts         # 主题入口
│   ├── utils/               # 工具函数
│   │   ├── src/             # 工具源码
│   │   └── index.ts         # 工具入口
│   ├── hooks/               # 组合式函数
│   │   ├── src/             # 钩子源码
│   │   └── index.ts         # 钩子入口
│   └── index.ts             # 库入口文件
├── play/                    # 开发调试环境
├── scripts/                 # 脚本工具
├── typings/                 # 类型定义
├── .eslintrc.js             # ESLint配置
├── .prettierrc.js           # Prettier配置
├── tsconfig.json            # TypeScript配置
├── vite.config.ts           # Vite配置
├── package.json             # 包信息
└── README.md                # 项目说明
```

### Monorepo管理

对于大型组件库，可以考虑使用Monorepo方式管理，将不同组件拆分为独立的包：

```
component-library/
├── packages/
│   ├── button/              # 按钮组件包
│   ├── input/               # 输入框组件包
│   ├── theme/               # 主题包
│   ├── utils/               # 工具包
│   └── ...                  # 其他包
└── ...
```

可以使用以下工具实现Monorepo管理：

1. **Lerna**：传统的JavaScript Monorepo管理工具
2. **pnpm workspaces**：基于pnpm的工作区功能
3. **Turborepo**：高性能的构建系统，专为Monorepo设计
4. **Nx**：可扩展的构建框架，支持多种前端框架

### 组件分类

根据功能和复杂度，可以将组件分为以下几类：

1. **基础组件**：按钮、输入框、选择器等基本UI元素
2. **表单组件**：表单、表单项、验证等
3. **数据展示组件**：表格、列表、树形控件等
4. **反馈组件**：对话框、通知、加载指示器等
5. **导航组件**：菜单、标签页、面包屑等
6. **布局组件**：栅格、分割面板、响应式容器等

### 依赖管理

组件库的依赖管理需要特别注意：

1. **对等依赖（peerDependencies）**：将Vue等核心框架设为对等依赖，避免重复安装
2. **内部依赖**：组件之间的依赖关系应该清晰，避免循环依赖
3. **外部依赖**：尽量减少外部依赖，必要时考虑内部实现或fork
4. **版本控制**：明确依赖的版本范围，避免兼容性问题

## 组件设计原则

设计高质量的组件需要遵循一些基本原则。

### 单一职责原则

每个组件应该只负责一个功能，这样组件更容易理解、测试和维护：

```vue
<!-- 不好的设计：一个组件负责多个功能 -->
<template>
  <div>
    <input v-model="value" />
    <div class="validation-error">{{ error }}</div>
    <div class="character-count">{{ value.length }}/100</div>
  </div>
</template>

<!-- 好的设计：拆分为多个组件 -->
<template>
  <div>
    <my-input v-model="value" />
    <validation-error :message="error" />
    <character-counter :value="value" :max="100" />
  </div>
</template>
```

### 可组合性

组件应该设计为可以轻松组合使用，形成更复杂的UI：

```vue
<!-- 可组合的表单组件 -->
<my-form>
  <my-form-item label="用户名">
    <my-input v-model="username" />
  </my-form-item>
  <my-form-item label="密码">
    <my-input type="password" v-model="password" />
  </my-form-item>
  <my-form-item>
    <my-button type="primary">提交</my-button>
  </my-form-item>
</my-form>
```

### 可扩展性

组件应该设计为可以轻松扩展，以适应不同的使用场景：

```vue
<!-- 基础按钮组件 -->
<template>
  <button
    :class="[
      'my-button',
      `my-button--${type}`,
      { 'is-disabled': disabled }
    ]"
    :disabled="disabled"
    @click="handleClick"
  >
    <slot name="icon"></slot>
    <span v-if="$slots.default"><slot></slot></span>
  </button>
</template>

<script>
export default {
  name: 'MyButton',
  props: {
    type: {
      type: String,
      default: 'default',
      validator: value => ['default', 'primary', 'success', 'warning', 'danger'].includes(value)
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  methods: {
    handleClick(event) {
      if (this.disabled) return;
      this.$emit('click', event);
    }
  }
}
</script>
```

### 一致性

组件库中的所有组件应该遵循一致的设计模式和API风格：

1. **命名一致性**：组件名称、属性名称、事件名称等应该遵循统一的命名规范
2. **行为一致性**：类似的组件应该有类似的行为
3. **视觉一致性**：组件的视觉风格应该一致
4. **文档一致性**：所有组件的文档应该遵循统一的格式

### 可访问性（A11y）

组件应该设计为对所有用户都可访问，包括使用辅助技术的用户：

1. **语义化HTML**：使用正确的HTML元素表达组件的语义
2. **键盘可访问性**：确保组件可以通过键盘操作
3. **ARIA属性**：使用适当的ARIA属性增强可访问性
4. **颜色对比度**：确保文本和背景之间有足够的对比度
5. **屏幕阅读器支持**：提供适当的文本替代和标签

```vue
<!-- 可访问的按钮组件 -->
<template>
  <button
    :class="buttonClasses"
    :disabled="disabled"
    :aria-disabled="disabled"
    :aria-label="ariaLabel"
    :aria-pressed="toggleable ? pressed : undefined"
    @click="handleClick"
    @keydown="handleKeydown"
  >
    <span class="sr-only" v-if="srOnly">{{ srOnly }}</span>
    <slot></slot>
  </button>
</template>
```

## API设计

良好的API设计是组件库易用性的关键。

### Props设计

Props是组件的主要配置接口，设计时应考虑以下几点：

1. **类型定义**：明确定义每个prop的类型，并提供类型验证
2. **默认值**：为可选的props提供合理的默认值
3. **验证函数**：为复杂的props提供验证函数
4. **必要性**：明确哪些props是必需的，哪些是可选的
5. **命名规范**：使用一致的命名规范，如camelCase

```ts
// 按钮组件的Props设计
export interface ButtonProps {
  // 按钮类型
  type?: 'default' | 'primary' | 'success' | 'warning' | 'danger';
  // 按钮尺寸
  size?: 'small' | 'medium' | 'large';
  // 是否禁用
  disabled?: boolean;
  // 是否显示加载状态
  loading?: boolean;
  // 按钮图标
  icon?: string;
  // 按钮形状
  shape?: 'circle' | 'round' | 'square';
  // 自定义类名
  className?: string;
  // 自定义样式
  style?: Record<string, any>;
}

// Vue 3组件定义
import { defineComponent, PropType } from 'vue';

export default defineComponent({
  name: 'MyButton',
  props: {
    type: {
      type: String as PropType<ButtonProps['type']>,
      default: 'default',
      validator: (value: string) => {
        return ['default', 'primary', 'success', 'warning', 'danger'].includes(value);
      }
    },
    size: {
      type: String as PropType<ButtonProps['size']>,
      default: 'medium',
      validator: (value: string) => {
        return ['small', 'medium', 'large'].includes(value);
      }
    },
    disabled: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    icon: {
      type: String,
      default: ''
    },
    shape: {
      type: String as PropType<ButtonProps['shape']>,
      default: 'square',
      validator: (value: string) => {
        return ['circle', 'round', 'square'].includes(value);
      }
    },
    className: {
      type: String,
      default: ''
    },
    style: {
      type: Object,
      default: () => ({})
    }
  },
  // ...
});
```

### 事件设计

组件应该通过事件（Events）与外部通信：

1. **命名规范**：使用一致的命名规范，如kebab-case（Vue推荐）
2. **事件参数**：明确定义每个事件的参数类型和含义
3. **事件文档**：详细记录每个事件的触发条件和用途

```vue
<template>
  <button
    :class="buttonClasses"
    :disabled="disabled || loading"
    @click="handleClick"
    @mouseenter="handleMouseEnter"
    @mouseleave="handleMouseLeave"
  >
    <span v-if="loading" class="loading-icon"></span>
    <span v-else-if="icon" class="icon" :class="icon"></span>
    <span v-if="$slots.default" class="content"><slot></slot></span>
  </button>
</template>

<script>
export default {
  // ...
  emits: ['click', 'hover-change'],
  setup(props, { emit }) {
    const handleClick = (event) => {
      if (props.disabled || props.loading) return;
      emit('click', event);
    };
    
    const handleMouseEnter = () => {
      if (props.disabled) return;
      emit('hover-change', true);
    };
    
    const handleMouseLeave = () => {
      if (props.disabled) return;
      emit('hover-change', false);
    };
    
    return {
      handleClick,
      handleMouseEnter,
      handleMouseLeave
    };
  }
};
</script>
```

### 插槽设计

插槽（Slots）允许用户自定义组件的内容和布局：

1. **默认插槽**：提供基本的内容定制能力
2. **命名插槽**：提供更精细的内容定制能力
3. **作用域插槽**：提供数据传递能力

```vue
<!-- 卡片组件的插槽设计 -->
<template>
  <div class="my-card">
    <div v-if="$slots.header || title" class="my-card__header">
      <slot name="header">
        <div class="my-card__title">{{ title }}</div>
      </slot>
    </div>
    
    <div class="my-card__body">
      <slot></slot>
    </div>
    
    <div v-if="$slots.footer" class="my-card__footer">
      <slot name="footer"></slot>
    </div>
    
    <slot name="overlay" :visible="overlayVisible">
      <div v-if="overlayVisible" class="my-card__overlay">
        <div class="my-card__overlay-content">
          {{ overlayContent }}
        </div>
      </div>
    </slot>
  </div>
</template>
```

### 组合式API设计

对于Vue 3组件库，可以使用组合式API（Composition API）设计更灵活的组件：

1. **提取可复用逻辑**：将通用逻辑提取为组合式函数（Composables）
2. **状态管理**：使用`ref`、`reactive`等API管理组件状态
3. **生命周期**：使用`onMounted`、`onUnmounted`等钩子处理生命周期
4. **计算属性**：使用`computed`创建响应式计算属性
5. **侦听器**：使用`watch`和`watchEffect`响应数据变化

```ts
// 按钮组件的组合式API设计
import { computed, ref, CSSProperties } from 'vue';
import type { ButtonProps } from './types';

export function useButton(props: ButtonProps) {
  // 状态
  const isHovered = ref(false);
  const isFocused = ref(false);
  const isPressed = ref(false);
  
  // 计算属性
  const buttonClasses = computed(() => [
    'my-button',
    `my-button--${props.type}`,
    `my-button--${props.size}`,
    {
      'is-disabled': props.disabled,
      'is-loading': props.loading,
      'is-hovered': isHovered.value,
      'is-focused': isFocused.value,
      'is-pressed': isPressed.value,
      [`my-button--${props.shape}`]: props.shape
    },
    props.className
  ]);
  
  const buttonStyle = computed(() => {
    const style: CSSProperties = { ...props.style };
    
    // 添加自定义样式逻辑
    if (props.customColor) {
      style.backgroundColor = props.customColor;
      style.borderColor = props.customColor;
    }
    
    return style;
  });
  
  // 事件处理
  const handleMouseEnter = () => {
    if (props.disabled) return;
    isHovered.value = true;
  };
  
  const handleMouseLeave = () => {
    isHovered.value = false;
  };
  
  const handleFocus = () => {
    if (props.disabled) return;
    isFocused.value = true;
  };
  
  const handleBlur = () => {
    isFocused.value = false;
  };
  
  const handleMouseDown = () => {
    if (props.disabled) return;
    isPressed.value = true;
  };
  
  const handleMouseUp = () => {
    isPressed.value = false;
  };
  
  return {
    buttonClasses,
    buttonStyle,
    isHovered,
    isFocused,
    isPressed,
    handleMouseEnter,
    handleMouseLeave,
    handleFocus,
    handleBlur,
    handleMouseDown,
    handleMouseUp
  };
}
```

### 指令设计

自定义指令可以扩展组件的功能：

```ts
// 点击外部指令
import type { Directive, DirectiveBinding } from 'vue';

interface ClickOutsideElement extends HTMLElement {
  _clickOutsideHandler?: (event: MouseEvent) => void;
}

export const clickOutside: Directive = {
  mounted(el: ClickOutsideElement, binding: DirectiveBinding) {
    const handler = (event: MouseEvent) => {
      if (!el.contains(event.target as Node) && el !== event.target) {
        binding.value(event);
      }
    };
    
    el._clickOutsideHandler = handler;
    document.addEventListener('click', handler);
  },
  
  beforeUnmount(el: ClickOutsideElement) {
    if (el._clickOutsideHandler) {
      document.removeEventListener('click', el._clickOutsideHandler);
      delete el._clickOutsideHandler;
    }
  }
};
```

## 样式系统设计

组件库的样式系统需要考虑可定制性、一致性和性能。

### CSS架构

选择合适的CSS架构可以提高样式的可维护性：

1. **BEM（Block Element Modifier）**：一种命名规范，有助于创建可重用的组件
2. **ITCSS（Inverted Triangle CSS）**：一种CSS组织方法，从通用到具体
3. **Atomic CSS**：基于单一用途的小类
4. **CSS Modules**：局部作用域的CSS
5. **CSS-in-JS**：在JavaScript中编写CSS

```scss
// 使用BEM命名规范
.my-button {
  // 块（Block）
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 8px 16px;
  border-radius: 4px;
  font-size: 14px;
  transition: all 0.3s;
  
  // 元素（Element）
  &__icon {
    margin-right: 8px;
  }
  
  &__text {
    line-height: 1;
  }
  
  // 修饰符（Modifier）
  &--primary {
    background-color: var(--primary-color);
    color: white;
    border: 1px solid var(--primary-color);
    
    &:hover {
      background-color: var(--primary-color-hover);
      border-color: var(--primary-color-hover);
    }
  }
  
  &--small {
    padding: 4px 8px;
    font-size: 12px;
  }
  
  &--large {
    padding: 12px 24px;
    font-size: 16px;
  }
  
  // 状态
  &.is-disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  &.is-loading {
    position: relative;
    pointer-events: none;
    
    .loading-icon {
      margin-right: 8px;
      animation: spin 1s infinite linear;
    }
  }
}
```

### 主题系统

设计灵活的主题系统，支持定制和切换主题：

1. **CSS变量**：使用CSS变量定义主题颜色和样式
2. **预处理器变量**：使用SCSS/LESS变量定义主题
3. **运行时主题切换**：支持在运行时切换主题

```scss
// 定义CSS变量
:root {
  // 主题色
  --primary-color: #1890ff;
  --primary-color-hover: #40a9ff;
  --primary-color-active: #096dd9;
  --success-color: #52c41a;
  --warning-color: #faad14;
  --error-color: #f5222d;
  
  // 文本色
  --text-color-primary: rgba(0, 0, 0, 0.85);
  --text-color-secondary: rgba(0, 0, 0, 0.65);
  --text-color-disabled: rgba(0, 0, 0, 0.25);
  
  // 背景色
  --background-color-base: #f5f5f5;
  --background-color-light: #fafafa;
  
  // 边框色
  --border-color-base: #d9d9d9;
  --border-color-split: #f0f0f0;
  
  // 字体
  --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
  --font-size-base: 14px;
  --font-size-sm: 12px;
  --font-size-lg: 16px;
  
  // 圆角
  --border-radius-base: 4px;
  --border-radius-sm: 2px;
  --border-radius-lg: 8px;
  
  // 阴影
  --box-shadow-base: 0 2px 8px rgba(0, 0, 0, 0.15);
  
  // 动画
  --animation-duration-base: 0.2s;
  --animation-duration-slow: 0.3s;
  --animation-duration-fast: 0.1s;
}

// 暗色主题
.dark-theme {
  --primary-color: #177ddc;
  --primary-color-hover: #1890ff;
  --primary-color-active: #0050b3;
  --success-color: #49aa19;
  --warning-color: #d89614;
  --error-color: #d32029;
  
  --text-color-primary: rgba(255, 255, 255, 0.85);
  --text-color-secondary: rgba(255, 255, 255, 0.65);
  --text-color-disabled: rgba(255, 255, 255, 0.25);
  
  --background-color-base: #141414;
  --background-color-light: #1f1f1f;
  
  --border-color-base: #434343;
  --border-color-split: #303030;
  
  --box-shadow-base: 0 2px 8px rgba(0, 0, 0, 0.45);
}
```

### 响应式设计

确保组件在不同设备和屏幕尺寸上都能正常工作：

1. **媒体查询**：使用媒体查询适配不同屏幕尺寸
2. **弹性布局**：使用Flexbox和Grid创建灵活的布局
3. **相对单位**：使用rem、em、vw、vh等相对单位
4. **断点系统**：定义一组标准断点

```scss
// 定义断点
$breakpoints: (
  'xs': 0,
  'sm': 576px,
  'md': 768px,
  'lg': 992px,
  'xl': 1200px,
  'xxl': 1600px
);

// 媒体查询混合宏
@mixin media-up($breakpoint) {
  $min-width: map-get($breakpoints, $breakpoint);
  @media (min-width: $min-width) {
    @content;
  }
}

@mixin media-down($breakpoint) {
  $max-width: map-get($breakpoints, $breakpoint) - 1px;
  @media (max-width: $max-width) {
    @content;
  }
}

// 使用示例
.my-component {
  padding: 16px;
  
  @include media-up('md') {
    padding: 24px;
  }
  
  @include media-up('lg') {
    padding: 32px;
  }
}
```

### CSS-in-JS解决方案

对于需要更动态样式控制的场景，可以考虑CSS-in-JS解决方案：

1. **Emotion**：高性能、灵活的CSS-in-JS库
2. **Styled Components**：使用标签模板字面量的组件样式库
3. **Stitches**：性能优先的CSS-in-JS库

```tsx
// 使用Emotion的示例
/** @jsxImportSource @emotion/react */
import { css } from '@emotion/react';
import { useState } from 'react';

const buttonStyles = (type: string, disabled: boolean) => css`
  我将继续编写Vue组件库开发指南的文档内容。

```markdown:c:\project\kphub\src\frontend\vue\03-组件设计\3.12-组件库开发指南.md
  background-color: ${type === 'primary' ? 'var(--primary-color)' : 'transparent'};
  color: ${type === 'primary' ? 'white' : 'var(--text-color-primary)'};
  border: 1px solid ${type === 'primary' ? 'var(--primary-color)' : 'var(--border-color-base)'};
  padding: 8px 16px;
  border-radius: var(--border-radius-base);
  font-size: var(--font-size-base);
  transition: all 0.3s;
  cursor: ${disabled ? 'not-allowed' : 'pointer'};
  opacity: ${disabled ? 0.5 : 1};
  
  &:hover {
    background-color: ${type === 'primary' ? 'var(--primary-color-hover)' : 'rgba(0, 0, 0, 0.05)'};
  }
`;

const Button = ({ type = 'default', disabled = false, children }) => {
  return (
    <button
      css={buttonStyles(type, disabled)}
      disabled={disabled}
    >
      {children}
    </button>
  );
};
```

## 组件开发流程

建立一个高效的组件开发流程可以提高开发效率和组件质量。

### 组件规划

在开始编码前，应该先规划组件的功能和API：

1. **需求分析**：明确组件的使用场景和功能需求
2. **API设计**：设计组件的props、事件、插槽等接口
3. **交互设计**：规划组件的交互行为和状态变化
4. **视觉设计**：确定组件的视觉风格和样式

### 组件实现

实现组件时，应该遵循以下步骤：

1. **创建基础结构**：创建组件的基本HTML结构
2. **添加交互逻辑**：实现组件的交互行为和状态管理
3. **编写样式**：根据设计规范编写组件样式
4. **添加文档**：编写组件的使用文档和示例

以下是一个按钮组件的实现示例：

```vue
<!-- Button.vue -->
<template>
  <button
    :class="[
      'my-button',
      `my-button--${type}`,
      `my-button--${size}`,
      {
        'is-disabled': disabled,
        'is-loading': loading,
        'is-block': block,
        [`my-button--${shape}`]: shape
      }
    ]"
    :style="customStyle"
    :disabled="disabled || loading"
    :type="htmlType"
    @click="handleClick"
  >
    <span v-if="loading" class="my-button__loading">
      <slot name="loading-icon">
        <i class="my-icon-loading"></i>
      </slot>
    </span>
    <span v-else-if="icon" class="my-button__icon">
      <i :class="['my-icon', `my-icon-${icon}`]"></i>
    </span>
    <span v-if="$slots.default" class="my-button__text">
      <slot></slot>
    </span>
  </button>
</template>

<script lang="ts">
import { defineComponent, computed, PropType, CSSProperties } from 'vue';

type ButtonType = 'default' | 'primary' | 'success' | 'warning' | 'danger' | 'text';
type ButtonSize = 'small' | 'medium' | 'large';
type ButtonShape = 'circle' | 'round' | 'square';
type ButtonHTMLType = 'button' | 'submit' | 'reset';

export default defineComponent({
  name: 'MyButton',
  props: {
    type: {
      type: String as PropType<ButtonType>,
      default: 'default',
      validator: (value: string) => {
        return ['default', 'primary', 'success', 'warning', 'danger', 'text'].includes(value);
      }
    },
    size: {
      type: String as PropType<ButtonSize>,
      default: 'medium',
      validator: (value: string) => {
        return ['small', 'medium', 'large'].includes(value);
      }
    },
    shape: {
      type: String as PropType<ButtonShape>,
      default: 'square',
      validator: (value: string) => {
        return ['circle', 'round', 'square'].includes(value);
      }
    },
    disabled: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    block: {
      type: Boolean,
      default: false
    },
    icon: {
      type: String,
      default: ''
    },
    htmlType: {
      type: String as PropType<ButtonHTMLType>,
      default: 'button',
      validator: (value: string) => {
        return ['button', 'submit', 'reset'].includes(value);
      }
    },
    customStyle: {
      type: Object as PropType<CSSProperties>,
      default: () => ({})
    }
  },
  emits: ['click'],
  setup(props, { emit }) {
    const handleClick = (event: MouseEvent) => {
      if (props.disabled || props.loading) return;
      emit('click', event);
    };
    
    return {
      handleClick
    };
  }
});
</script>

<style lang="scss">
.my-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 8px 16px;
  border-radius: var(--border-radius-base);
  font-size: var(--font-size-base);
  line-height: 1.5;
  transition: all 0.3s;
  cursor: pointer;
  border: 1px solid var(--border-color-base);
  background-color: white;
  color: var(--text-color-primary);
  outline: none;
  
  &:hover, &:focus {
    color: var(--primary-color);
    border-color: var(--primary-color);
  }
  
  &:active {
    color: var(--primary-color-active);
    border-color: var(--primary-color-active);
  }
  
  &__icon {
    margin-right: 8px;
  }
  
  &__loading {
    margin-right: 8px;
    animation: spin 1s infinite linear;
  }
  
  // 类型
  &--primary {
    background-color: var(--primary-color);
    border-color: var(--primary-color);
    color: white;
    
    &:hover, &:focus {
      background-color: var(--primary-color-hover);
      border-color: var(--primary-color-hover);
      color: white;
    }
    
    &:active {
      background-color: var(--primary-color-active);
      border-color: var(--primary-color-active);
      color: white;
    }
  }
  
  &--success {
    background-color: var(--success-color);
    border-color: var(--success-color);
    color: white;
    
    &:hover, &:focus {
      background-color: lighten(var(--success-color), 10%);
      border-color: lighten(var(--success-color), 10%);
      color: white;
    }
    
    &:active {
      background-color: darken(var(--success-color), 10%);
      border-color: darken(var(--success-color), 10%);
      color: white;
    }
  }
  
  // 尺寸
  &--small {
    padding: 4px 8px;
    font-size: var(--font-size-sm);
    border-radius: var(--border-radius-sm);
  }
  
  &--large {
    padding: 12px 24px;
    font-size: var(--font-size-lg);
    border-radius: var(--border-radius-lg);
  }
  
  // 形状
  &--circle {
    border-radius: 50%;
    padding: 0;
    width: 32px;
    height: 32px;
    
    &.my-button--small {
      width: 24px;
      height: 24px;
    }
    
    &.my-button--large {
      width: 40px;
      height: 40px;
    }
  }
  
  &--round {
    border-radius: 20px;
  }
  
  // 状态
  &.is-disabled {
    cursor: not-allowed;
    opacity: 0.5;
    pointer-events: none;
  }
  
  &.is-loading {
    pointer-events: none;
  }
  
  &.is-block {
    display: flex;
    width: 100%;
  }
  
  // 文本按钮
  &--text {
    border-color: transparent;
    background: transparent;
    padding: 0;
    
    &:hover, &:focus {
      background: transparent;
      color: var(--primary-color-hover);
    }
    
    &:active {
      color: var(--primary-color-active);
    }
  }
}

@keyframes spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
</style>
```

### 组件测试

测试是确保组件质量的关键步骤：

1. **单元测试**：测试组件的各个功能点
2. **快照测试**：确保组件的渲染输出不会意外变化
3. **交互测试**：测试组件的交互行为
4. **可访问性测试**：确保组件符合可访问性标准

```ts
// Button.spec.ts
import { mount } from '@vue/test-utils';
import { describe, it, expect } from 'vitest';
import Button from '../src/Button.vue';

describe('Button', () => {
  // 渲染测试
  it('renders correctly', () => {
    const wrapper = mount(Button, {
      props: {
        type: 'primary'
      },
      slots: {
        default: '按钮'
      }
    });
    
    expect(wrapper.classes()).toContain('my-button--primary');
    expect(wrapper.text()).toBe('按钮');
  });
  
  // 事件测试
  it('emits click event when clicked', async () => {
    const wrapper = mount(Button);
    
    await wrapper.trigger('click');
    
    expect(wrapper.emitted().click).toBeTruthy();
    expect(wrapper.emitted().click.length).toBe(1);
  });
  
  // 禁用状态测试
  it('does not emit click event when disabled', async () => {
    const wrapper = mount(Button, {
      props: {
        disabled: true
      }
    });
    
    await wrapper.trigger('click');
    
    expect(wrapper.emitted().click).toBeFalsy();
  });
  
  // 加载状态测试
  it('shows loading icon when loading is true', () => {
    const wrapper = mount(Button, {
      props: {
        loading: true
      }
    });
    
    expect(wrapper.find('.my-button__loading').exists()).toBe(true);
  });
  
  // 尺寸测试
  it('applies correct size class', () => {
    const wrapper = mount(Button, {
      props: {
        size: 'large'
      }
    });
    
    expect(wrapper.classes()).toContain('my-button--large');
  });
  
  // 形状测试
  it('applies correct shape class', () => {
    const wrapper = mount(Button, {
      props: {
        shape: 'circle'
      }
    });
    
    expect(wrapper.classes()).toContain('my-button--circle');
  });
  
  // 块级按钮测试
  it('applies block class when block is true', () => {
    const wrapper = mount(Button, {
      props: {
        block: true
      }
    });
    
    expect(wrapper.classes()).toContain('is-block');
  });
  
  // 图标测试
  it('renders icon when icon prop is provided', () => {
    const wrapper = mount(Button, {
      props: {
        icon: 'search'
      }
    });
    
    expect(wrapper.find('.my-button__icon').exists()).toBe(true);
    expect(wrapper.find('.my-icon-search').exists()).toBe(true);
  });
  
  // HTML类型测试
  it('sets correct HTML type attribute', () => {
    const wrapper = mount(Button, {
      props: {
        htmlType: 'submit'
      }
    });
    
    expect(wrapper.attributes('type')).toBe('submit');
  });
  
  // 自定义样式测试
  it('applies custom styles', () => {
    const wrapper = mount(Button, {
      props: {
        customStyle: {
          backgroundColor: 'red',
          color: 'white'
        }
      }
    });
    
    expect(wrapper.attributes('style')).toContain('background-color: red');
    expect(wrapper.attributes('style')).toContain('color: white');
  });
});
```

### 组件文档

良好的文档是组件库易用性的关键：

1. **API文档**：详细记录组件的props、事件、插槽等接口
2. **使用示例**：提供常见使用场景的示例代码
3. **设计原则**：说明组件的设计思路和最佳实践
4. **更新日志**：记录组件的版本变化和更新内容

```md
# Button 按钮

按钮用于开始一个即时操作。

## 何时使用

标记了一个（或封装一组）操作命令，响应用户点击行为，触发相应的业务逻辑。

## 代码演示

### 按钮类型

按钮有五种类型：默认按钮、主要按钮、成功按钮、警告按钮和危险按钮。

```vue
<template>
  <div class="demo-button">
    <my-button>默认按钮</my-button>
    <my-button type="primary">主要按钮</my-button>
    <my-button type="success">成功按钮</my-button>
    <my-button type="warning">警告按钮</my-button>
    <my-button type="danger">危险按钮</my-button>
    <my-button type="text">文本按钮</my-button>
  </div>
</template>
```

### 按钮尺寸

按钮有三种尺寸：小、中、大。

```vue
<template>
  <div class="demo-button">
    <my-button size="small">小按钮</my-button>
    <my-button>默认按钮</my-button>
    <my-button size="large">大按钮</my-button>
  </div>
</template>
```

### 禁用状态

按钮不可用状态。

```vue
<template>
  <div class="demo-button">
    <my-button disabled>默认按钮</my-button>
    <my-button type="primary" disabled>主要按钮</my-button>
  </div>
</template>
```

### 加载状态

点击按钮后进入加载状态。

```vue
<template>
  <div class="demo-button">
    <my-button :loading="loading" @click="startLoading">点击加载</my-button>
  </div>
</template>

<script>
export default {
  data() {
    return {
      loading: false
    };
  },
  methods: {
    startLoading() {
      this.loading = true;
      setTimeout(() => {
        this.loading = false;
      }, 2000);
    }
  }
};
</script>
```

## API

### Props

| 参数 | 说明 | 类型 | 默认值 |
| --- | --- | --- | --- |
| type | 按钮类型 | `'default' \| 'primary' \| 'success' \| 'warning' \| 'danger' \| 'text'` | `'default'` |
| size | 按钮尺寸 | `'small' \| 'medium' \| 'large'` | `'medium'` |
| shape | 按钮形状 | `'circle' \| 'round' \| 'square'` | `'square'` |
| disabled | 是否禁用 | `boolean` | `false` |
| loading | 是否加载中 | `boolean` | `false` |
| block | 是否为块级按钮 | `boolean` | `false` |
| icon | 图标名称 | `string` | `''` |
| htmlType | 原生button类型 | `'button' \| 'submit' \| 'reset'` | `'button'` |
| customStyle | 自定义样式 | `CSSProperties` | `{}` |

### Events

| 事件名 | 说明 | 回调参数 |
| --- | --- | --- |
| click | 点击按钮时触发 | `(event: MouseEvent) => void` |

### Slots

| 插槽名 | 说明 |
| --- | --- |
| default | 按钮内容 |
| loading-icon | 自定义加载图标 |
```

## 构建与发布

构建和发布是组件库开发的最后阶段，需要确保组件库能够正确地被其他项目使用。

### 构建配置

使用合适的构建工具和配置，确保组件库能够被正确打包：

```ts
// vite.config.ts
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import { resolve } from 'path';
import dts from 'vite-plugin-dts';

export default defineConfig({
  plugins: [
    vue(),
    dts({
      include: ['packages/**/*.ts', 'packages/**/*.d.ts', 'packages/**/*.vue'],
      beforeWriteFile: (filePath, content) => {
        return {
          filePath: filePath.replace('/packages/', '/'),
          content
        };
      }
    })
  ],
  build: {
    lib: {
      entry: resolve(__dirname, 'packages/index.ts'),
      name: 'MyUI',
      fileName: (format) => `my-ui.${format}.js`
    },
    rollupOptions: {
      // 确保外部化处理那些你不想打包进库的依赖
      external: ['vue'],
      output: {
        // 在 UMD 构建模式下为这些外部化的依赖提供一个全局变量
        globals: {
          vue: 'Vue'
        },
        // 为每个组件生成单独的文件
        preserveModules: true,
        preserveModulesRoot: 'packages',
        // 确保CSS文件被正确输出
        assetFileNames: (assetInfo) => {
          if (assetInfo.name === 'style.css') return 'my-ui.css';
          return assetInfo.name;
        }
      }
    },
    // 确保CSS被提取到单独的文件
    cssCodeSplit: true,
    // 生成sourcemap
    sourcemap: true,
    // 压缩代码
    minify: 'terser',
    // 设置输出目录
    outDir: 'dist'
  }
});
```

### 包配置

在`package.json`中正确配置包信息，确保组件库能够被正确安装和使用：

```json
{
  "name": "my-ui",
  "version": "1.0.0",
  "description": "A Vue 3 UI component library",
  "main": "dist/my-ui.umd.js",
  "module": "dist/my-ui.es.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist"
  ],
  "exports": {
    ".": {
      "import": "./dist/my-ui.es.js",
      "require": "./dist/my-ui.umd.js"
    },
    "./dist/style.css": "./dist/style.css"
  },
  "scripts": {
    "dev": "vite",
    "build": "vue-tsc --noEmit && vite build",
    "preview": "vite preview",
    "test": "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "lint": "eslint --ext .js,.ts,.vue --ignore-path .gitignore .",
    "lint:fix": "eslint --ext .js,.ts,.vue --ignore-path .gitignore . --fix",
    "docs:dev": "vitepress dev docs",
    "docs:build": "vitepress build docs",
    "docs:serve": "vitepress serve docs"
  },
  "peerDependencies": {
    "vue": "^3.2.0"
  },
  "devDependencies": {
    "@types/node": "^18.11.9",
    "@typescript-eslint/eslint-plugin": "^5.42.1",
    "@typescript-eslint/parser": "^5.42.1",
    "@vitejs/plugin-vue": "^3.2.0",
    "@vue/eslint-config-typescript": "^11.0.2",
    "@vue/test-utils": "^2.2.1",
    "eslint": "^8.27.0",
    "eslint-plugin-vue": "^9.7.0",
    "jsdom": "^20.0.2",
    "sass": "^1.56.1",
    "terser": "^5.15.1",
    "typescript": "^4.8.4",
    "vite": "^3.2.3",
    "vite-plugin-dts": "^1.7.1",
    "vitepress": "^1.0.0-alpha.29",
    "vitest": "^0.25.2",
    "vue-tsc": "^1.0.9"
  },
  "keywords": [
    "vue",
    "vue3",
    "component",
    "ui",
    "library"
  ],
  "author": "Your Name",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/yourusername/my-ui.git"
  },
  "bugs": {
    "url": "https://github.com/yourusername/my-ui/issues"
  },
  "homepage": "https://github.com/yourusername/my-ui#readme"
}
```

### 入口文件

创建一个入口文件，导出所有组件和相关功能：

```ts
// packages/index.ts
import type { App } from 'vue';
import Button from './components/button';
import Input from './components/input';
import Select from './components/select';
// 导入更多组件...

// 导入指令
import { clickOutside } from './directives/click-outside';

// 导入组合式函数
import { useForm } from './hooks/use-form';

// 组件列表
const components = [
  Button,
  Input,
  Select,
  // 更多组件...
];

// 指令列表
const directives = {
  clickOutside
};

// 安装函数
const install = (app: App) => {
  // 注册组件
  components.forEach(component => {
    app.component(component.name, component);
  });
  
  // 注册指令
  Object.keys(directives).forEach(key => {
    app.directive(key, directives[key]);
  });
  
  return app;
};

// 导出版本号
export const version = '1.0.0';

// 导出安装函数
export default {
  install
};

// 导出单个组件
export {
  Button,
  Input,
  Select,
  // 更多组件...
};

// 导出指令
export {
  clickOutside
};

// 导出组合式函数
export {
  useForm
};
```

### 类型声明

为组件库提供完整的TypeScript类型声明：

```ts
// packages/components/button/types.ts
import { ExtractPropTypes, PropType } from 'vue';

export type ButtonType = 'default' | 'primary' | 'success' | 'warning' | 'danger' | 'text';
export type ButtonSize = 'small' | 'medium' | 'large';
export type ButtonShape = 'circle' | 'round' | 'square';
export type ButtonHTMLType = 'button' | 'submit' | 'reset';

export const buttonProps = {
  type: {
    type: String as PropType<ButtonType>,
    default: 'default',
    validator: (value: string) => {
      return ['default', 'primary', 'success', 'warning', 'danger', 'text'].includes(value);
    }
  },
  size: {
    type: String as PropType<ButtonSize>,
    default: 'medium',
    validator: (value: string) => {
      return ['small', 'medium', 'large'].includes(value);
    }
  },
  shape: {
    type: String as PropType<ButtonShape>,
    default: 'square',
    validator: (value: string) => {
      return ['circle', 'round', 'square'].includes(value);
    }
  },
  disabled: {
    type: Boolean,
    default: false
  },
  loading: {
    type: Boolean,
    default: false
  },
  block: {
    type: Boolean,
    default: false
  },
  icon: {
    type: String,
    default: ''
  },
  htmlType: {
    type: String as PropType<ButtonHTMLType>,
    default: 'button',
    validator: (value: string) => {
      return ['button', 'submit', 'reset'].includes(value);
    }
  },
  customStyle: {
    type: Object,
    default: () => ({})
  }
};

export type ButtonProps = ExtractPropTypes<typeof buttonProps>;

export const buttonEmits = {
  click: (event: MouseEvent) => event instanceof MouseEvent
};

export type ButtonEmits = typeof buttonEmits;
```

### 发布流程

建立一个规范的发布流程，确保组件库的版本管理和发布过程顺畅：

1. **版本管理**：使用语义化版本（Semantic Versioning）管理版本号
2. **更新日志**：记录每个版本的变更内容
3. **发布脚本**：编写自动化发布脚本
4. **CI/CD**：配置持续集成和持续部署流程

```bash
#!/bin/bash
# 发布脚本示例

# 确保在主分支上
git checkout main

# 拉取最新代码
git pull origin main

# 运行测试
npm run test

# 如果测试失败，退出
if [ $? -ne 0 ]; then
  echo "Tests failed, aborting release"
  exit 1
fi

# 构建库
npm run build

# 如果构建失败，退出
if [ $? -ne 0 ]; then
  echo "Build failed, aborting release"
  exit 1
fi

# 更新版本号
npm version $1

# 生成更新日志
npx conventional-changelog -p angular -i CHANGELOG.md -s

# 提交版本更新
git add CHANGELOG.md package.json
git commit -m "chore(release): v$(node -p "require('./package.json').version")"

# 创建标签
git tag v$(node -p "require('./package.json').version")

# 推送到远程仓库
git push origin main --tags

# 发布到npm
npm publish
```

## 文档网站搭建

一个好的文档网站对于组件库的推广和使用至关重要。

### VitePress搭建文档

VitePress是一个基于Vite的静态网站生成器，非常适合搭建组件库文档：

```ts
// docs/.vitepress/config.ts
import { defineConfig } from 'vitepress';

export default defineConfig({
  title: 'My UI',
  description: 'A Vue 3 UI component library',
  themeConfig: {
    logo: '/logo.svg',
    nav: [
      { text: '首页', link: '/' },
      { text: '组件', link: '/components/button' },
      { text: '指南', link: '/guide/installation' },
      { text: 'API参考', link: '/api/' },
      { text: '更新日志', link: '/changelog' }
    ],
    sidebar: {
      '/components/': [
        {
          text: '基础组件',
          items: [
            { text: 'Button 按钮', link: '/components/button' },
            { text: 'Icon 图标', link: '/components/icon' },
            { text: 'Layout 布局', link: '/components/layout' }
          ]
        },
        {
          text: '表单组件',
          items: [
            { text: 'Input 输入框', link: '/components/input' },
            { text: 'Select 选择器', link: '/components/select' },
            { text: 'Checkbox 复选框', link: '/components/checkbox' },
            { text: 'Radio 单选框', link: '/components/radio' },
            { text: 'Switch 开关', link: '/components/switch' },
            { text: 'Form 表单', link: '/components/form' }
          ]
        },
        {
          text: '数据展示',
          items: [
            { text: 'Table 表格', link: '/components/table' },
            { text: 'Pagination 分页', link: '/components/pagination' },
            { text: 'Tree 树形控件',我将继续编写Vue组件库开发指南的文档内容。

```markdown:c:\project\kphub\src\frontend\vue\03-组件设计\3.12-组件库开发指南.md
            { text: 'Tree 树形控件', link: '/components/tree' },
            { text: 'Tabs 标签页', link: '/components/tabs' },
            { text: 'Tag 标签', link: '/components/tag' }
          ]
        },
        {
          text: '反馈组件',
          items: [
            { text: 'Alert 警告', link: '/components/alert' },
            { text: 'Modal 对话框', link: '/components/modal' },
            { text: 'Message 消息提示', link: '/components/message' },
            { text: 'Notification 通知', link: '/components/notification' },
            { text: 'Progress 进度条', link: '/components/progress' }
          ]
        },
        {
          text: '导航组件',
          items: [
            { text: 'Menu 菜单', link: '/components/menu' },
            { text: 'Dropdown 下拉菜单', link: '/components/dropdown' },
            { text: 'Breadcrumb 面包屑', link: '/components/breadcrumb' },
            { text: 'Steps 步骤条', link: '/components/steps' }
          ]
        }
      ],
      '/guide/': [
        {
          text: '开始',
          items: [
            { text: '安装', link: '/guide/installation' },
            { text: '快速上手', link: '/guide/quickstart' },
            { text: '主题定制', link: '/guide/theme' },
            { text: '国际化', link: '/guide/i18n' }
          ]
        },
        {
          text: '进阶',
          items: [
            { text: '按需引入', link: '/guide/import-on-demand' },
            { text: '自定义主题', link: '/guide/custom-theme' },
            { text: '从 v1 升级到 v2', link: '/guide/migration-from-v1' }
          ]
        }
      ]
    },
    socialLinks: [
      { icon: 'github', link: 'https://github.com/yourusername/my-ui' }
    ],
    footer: {
      message: 'Released under the MIT License.',
      copyright: 'Copyright © 2023 Your Name'
    }
  }
});
```

### 组件演示

在文档中添加交互式组件演示，帮助用户理解组件的使用方法：

```vue
<!-- docs/.vitepress/theme/components/Demo.vue -->
<template>
  <div class="demo-block">
    <div class="demo-block-source">
      <slot name="source"></slot>
    </div>
    <div class="demo-block-meta">
      <div class="demo-block-title">{{ title }}</div>
      <div class="demo-block-description">{{ description }}</div>
    </div>
    <div class="demo-block-control" @click="toggleCode">
      <span>{{ expanded ? '收起代码' : '显示代码' }}</span>
      <i class="icon" :class="{ 'is-expanded': expanded }">▼</i>
    </div>
    <div class="demo-block-code" :class="{ 'is-expanded': expanded }">
      <slot name="code"></slot>
    </div>
  </div>
</template>

<script>
import { ref } from 'vue';

export default {
  name: 'Demo',
  props: {
    title: {
      type: String,
      default: ''
    },
    description: {
      type: String,
      default: ''
    }
  },
  setup() {
    const expanded = ref(false);
    
    const toggleCode = () => {
      expanded.value = !expanded.value;
    };
    
    return {
      expanded,
      toggleCode
    };
  }
};
</script>

<style>
.demo-block {
  border: 1px solid #ebeef5;
  border-radius: 4px;
  margin-bottom: 24px;
  transition: all 0.2s;
}

.demo-block:hover {
  box-shadow: 0 0 8px 0 rgba(0, 0, 0, 0.1);
}

.demo-block-source {
  padding: 24px;
  border-bottom: 1px solid #ebeef5;
}

.demo-block-meta {
  padding: 16px;
  border-bottom: 1px solid #ebeef5;
}

.demo-block-title {
  font-size: 16px;
  font-weight: 500;
  margin-bottom: 8px;
}

.demo-block-description {
  font-size: 14px;
  color: #666;
  line-height: 1.5;
}

.demo-block-control {
  padding: 8px 16px;
  background-color: #f9f9f9;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  color: #666;
  transition: all 0.2s;
}

.demo-block-control:hover {
  color: #1890ff;
}

.demo-block-control .icon {
  margin-left: 8px;
  transition: transform 0.2s;
}

.demo-block-control .icon.is-expanded {
  transform: rotate(180deg);
}

.demo-block-code {
  height: 0;
  overflow: hidden;
  transition: height 0.3s;
}

.demo-block-code.is-expanded {
  height: auto;
  padding: 16px;
  background-color: #f9f9f9;
  border-top: 1px solid #ebeef5;
}
</style>
```

### 注册全局组件

在VitePress中注册组件库的所有组件，以便在文档中直接使用：

```ts
// docs/.vitepress/theme/index.ts
import DefaultTheme from 'vitepress/theme';
import MyUI from 'my-ui';
import 'my-ui/dist/style.css';
import Demo from './components/Demo.vue';
import './styles/index.css';

export default {
  ...DefaultTheme,
  enhanceApp({ app }) {
    // 注册组件库
    app.use(MyUI);
    
    // 注册文档组件
    app.component('Demo', Demo);
  }
};
```

### 编写组件文档

为每个组件编写详细的文档，包括使用示例、API说明等：

```md
# Button 按钮

按钮用于开始一个即时操作。

## 基础用法

使用`type`、`size`、`disabled`等属性来定义按钮的样式。

<Demo title="基础用法" description="按钮有五种类型：默认按钮、主要按钮、成功按钮、警告按钮和危险按钮。">
  <template #source>
    <div class="demo-button">
      <my-button>默认按钮</my-button>
      <my-button type="primary">主要按钮</my-button>
      <my-button type="success">成功按钮</my-button>
      <my-button type="warning">警告按钮</my-button>
      <my-button type="danger">危险按钮</my-button>
      <my-button type="text">文本按钮</my-button>
    </div>
  </template>
  <template #code>

```vue
<template>
  <div class="demo-button">
    <my-button>默认按钮</my-button>
    <my-button type="primary">主要按钮</my-button>
    <my-button type="success">成功按钮</my-button>
    <my-button type="warning">警告按钮</my-button>
    <my-button type="danger">危险按钮</my-button>
    <my-button type="text">文本按钮</my-button>
  </div>
</template>
```

  </template>
</Demo>

## 按钮尺寸

使用`size`属性设置按钮大小，可选值为`small`、`medium`、`large`，默认为`medium`。

<Demo title="按钮尺寸" description="按钮有三种尺寸：小、中、大。">
  <template #source>
    <div class="demo-button">
      <my-button size="small">小按钮</my-button>
      <my-button>默认按钮</my-button>
      <my-button size="large">大按钮</my-button>
    </div>
  </template>
  <template #code>

```vue
<template>
  <div class="demo-button">
    <my-button size="small">小按钮</my-button>
    <my-button>默认按钮</my-button>
    <my-button size="large">大按钮</my-button>
  </div>
</template>
```

  </template>
</Demo>

## API

### Props

| 参数 | 说明 | 类型 | 默认值 |
| --- | --- | --- | --- |
| type | 按钮类型 | `'default' \| 'primary' \| 'success' \| 'warning' \| 'danger' \| 'text'` | `'default'` |
| size | 按钮尺寸 | `'small' \| 'medium' \| 'large'` | `'medium'` |
| shape | 按钮形状 | `'circle' \| 'round' \| 'square'` | `'square'` |
| disabled | 是否禁用 | `boolean` | `false` |
| loading | 是否加载中 | `boolean` | `false` |
| block | 是否为块级按钮 | `boolean` | `false` |
| icon | 图标名称 | `string` | `''` |
| htmlType | 原生button类型 | `'button' \| 'submit' \| 'reset'` | `'button'` |
| customStyle | 自定义样式 | `CSSProperties` | `{}` |

### Events

| 事件名 | 说明 | 回调参数 |
| --- | --- | --- |
| click | 点击按钮时触发 | `(event: MouseEvent) => void` |

### Slots

| 插槽名 | 说明 |
| --- | --- |
| default | 按钮内容 |
| loading-icon | 自定义加载图标 |
```

## 组件库的高级特性

除了基本的组件开发，一个成熟的组件库还应该具备一些高级特性。

### 国际化

支持多语言是现代组件库的重要特性：

```ts
// packages/locale/index.ts
import { ref, computed } from 'vue';
import zhCN from './lang/zh-CN';
import enUS from './lang/en-US';

// 支持的语言
export const languages = {
  'zh-CN': zhCN,
  'en-US': enUS
};

// 当前语言
const currentLang = ref('zh-CN');

// 当前语言包
const locale = computed(() => languages[currentLang.value]);

// 设置语言
export function setLang(lang: string) {
  if (languages[lang]) {
    currentLang.value = lang;
  } else {
    console.warn(`Language ${lang} not found, fallback to zh-CN`);
    currentLang.value = 'zh-CN';
  }
}

// 获取当前语言
export function getLang() {
  return currentLang.value;
}

// 翻译函数
export function t(key: string, ...args: any[]) {
  const message = key.split('.').reduce((obj, k) => obj && obj[k], locale.value);
  
  if (!message) {
    return key;
  }
  
  return typeof message === 'function' ? message(...args) : message;
}

// 语言注册函数
export function registerLang(lang: string, messages: Record<string, any>) {
  languages[lang] = messages;
}

export default {
  setLang,
  getLang,
  t,
  registerLang
};
```

```ts
// packages/locale/lang/zh-CN.ts
export default {
  common: {
    confirm: '确认',
    cancel: '取消',
    loading: '加载中',
    noData: '暂无数据',
    placeholder: '请输入',
    search: '搜索'
  },
  pagination: {
    total: '共 {total} 条',
    page: '页',
    pageSize: '条/页',
    jumper: '前往',
    prev: '上一页',
    next: '下一页'
  },
  modal: {
    confirmTitle: '确认',
    confirmContent: '确定执行此操作吗？'
  },
  form: {
    required: '{field}不能为空',
    email: '请输入有效的邮箱地址',
    url: '请输入有效的URL',
    number: '请输入数字'
  }
};
```

```ts
// packages/locale/lang/en-US.ts
export default {
  common: {
    confirm: 'Confirm',
    cancel: 'Cancel',
    loading: 'Loading',
    noData: 'No Data',
    placeholder: 'Please input',
    search: 'Search'
  },
  pagination: {
    total: 'Total {total} items',
    page: 'Page',
    pageSize: 'items/page',
    jumper: 'Go to',
    prev: 'Previous',
    next: 'Next'
  },
  modal: {
    confirmTitle: 'Confirm',
    confirmContent: 'Are you sure to perform this operation?'
  },
  form: {
    required: '{field} is required',
    email: 'Please enter a valid email address',
    url: 'Please enter a valid URL',
    number: 'Please enter a number'
  }
};
```

### 表单验证

为表单组件提供强大的验证功能：

```ts
// packages/hooks/use-form.ts
import { ref, reactive, computed, watch } from 'vue';
import { t } from '../locale';

// 验证规则类型
export interface Rule {
  required?: boolean;
  message?: string;
  validator?: (value: any, formData: Record<string, any>) => boolean | string | Promise<boolean | string>;
  trigger?: 'blur' | 'change' | 'submit' | string[];
  min?: number;
  max?: number;
  len?: number;
  pattern?: RegExp;
  type?: 'string' | 'number' | 'boolean' | 'array' | 'object' | 'email' | 'url' | 'date';
}

// 表单项配置
export interface FormItemConfig {
  value: any;
  rules?: Rule[];
  label?: string;
}

// 表单配置
export interface FormConfig {
  [key: string]: FormItemConfig;
}

// 验证结果
export interface ValidationResult {
  valid: boolean;
  message?: string;
}

// 表单验证钩子
export function useForm(config: FormConfig) {
  // 表单数据
  const formData = reactive(
    Object.keys(config).reduce((acc, key) => {
      acc[key] = config[key].value;
      return acc;
    }, {} as Record<string, any>)
  );
  
  // 错误信息
  const errors = reactive(
    Object.keys(config).reduce((acc, key) => {
      acc[key] = '';
      return acc;
    }, {} as Record<string, string>)
  );
  
  // 是否验证过
  const validated = ref(false);
  
  // 是否有错误
  const hasError = computed(() => {
    return Object.values(errors).some(error => error !== '');
  });
  
  // 验证单个字段
  const validateField = async (field: string, trigger?: string): Promise<ValidationResult> => {
    const fieldConfig = config[field];
    const value = formData[field];
    
    if (!fieldConfig || !fieldConfig.rules) {
      return { valid: true };
    }
    
    // 过滤规则
    const rules = trigger
      ? fieldConfig.rules.filter(rule => {
          if (!rule.trigger) return true;
          const triggers = Array.isArray(rule.trigger) ? rule.trigger : [rule.trigger];
          return triggers.includes(trigger);
        })
      : fieldConfig.rules;
    
    // 验证规则
    for (const rule of rules) {
      // 必填验证
      if (rule.required && (value === undefined || value === null || value === '')) {
        const message = rule.message || t('form.required', { field: fieldConfig.label || field });
        errors[field] = message;
        return { valid: false, message };
      }
      
      // 跳过空值的非必填验证
      if ((value === undefined || value === null || value === '') && !rule.required) {
        continue;
      }
      
      // 长度验证
      if (rule.len !== undefined && String(value).length !== rule.len) {
        const message = rule.message || `${fieldConfig.label || field} must be exactly ${rule.len} characters`;
        errors[field] = message;
        return { valid: false, message };
      }
      
      // 最小长度验证
      if (rule.min !== undefined && String(value).length < rule.min) {
        const message = rule.message || `${fieldConfig.label || field} must be at least ${rule.min} characters`;
        errors[field] = message;
        return { valid: false, message };
      }
      
      // 最大长度验证
      if (rule.max !== undefined && String(value).length > rule.max) {
        const message = rule.message || `${fieldConfig.label || field} cannot exceed ${rule.max} characters`;
        errors[field] = message;
        return { valid: false, message };
      }
      
      // 正则验证
      if (rule.pattern && !rule.pattern.test(String(value))) {
        const message = rule.message || `${fieldConfig.label || field} format is invalid`;
        errors[field] = message;
        return { valid: false, message };
      }
      
      // 类型验证
      if (rule.type) {
        let typeValid = true;
        let typeMessage = '';
        
        switch (rule.type) {
          case 'email':
            typeValid = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/.test(String(value));
            typeMessage = t('form.email');
            break;
          case 'url':
            typeValid = /^(https?:\/\/)?([\da-z.-]+)\.([a-z.]{2,6})([/\w.-]*)*\/?$/.test(String(value));
            typeMessage = t('form.url');
            break;
          case 'number':
            typeValid = !isNaN(Number(value));
            typeMessage = t('form.number');
            break;
          // 其他类型验证...
        }
        
        if (!typeValid) {
          const message = rule.message || typeMessage;
          errors[field] = message;
          return { valid: false, message };
        }
      }
      
      // 自定义验证
      if (rule.validator) {
        try {
          const result = await rule.validator(value, formData);
          if (result !== true) {
            const message = typeof result === 'string' ? result : rule.message || `${fieldConfig.label || field} validation failed`;
            errors[field] = message;
            return { valid: false, message };
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : `${fieldConfig.label || field} validation error`;
          errors[field] = message;
          return { valid: false, message };
        }
      }
    }
    
    // 验证通过
    errors[field] = '';
    return { valid: true };
  };
  
  // 验证所有字段
  const validate = async (trigger?: string): Promise<boolean> => {
    validated.value = true;
    
    const results = await Promise.all(
      Object.keys(config).map(field => validateField(field, trigger))
    );
    
    return results.every(result => result.valid);
  };
  
  // 重置表单
  const resetForm = () => {
    Object.keys(config).forEach(key => {
      formData[key] = config[key].value;
      errors[key] = '';
    });
    validated.value = false;
  };
  
  // 监听数据变化，自动验证
  Object.keys(config).forEach(field => {
    watch(
      () => formData[field],
      () => {
        if (validated.value) {
          validateField(field, 'change');
        }
      }
    );
  });
  
  return {
    formData,
    errors,
    validated,
    hasError,
    validateField,
    validate,
    resetForm
  };
}
```

### 虚拟滚动

为列表组件提供虚拟滚动功能，优化大数据渲染性能：

```vue
<!-- packages/components/virtual-list/src/index.vue -->
<template>
  <div
    ref="containerRef"
    class="my-virtual-list"
    @scroll="handleScroll"
  >
    <div
      class="my-virtual-list__phantom"
      :style="{ height: `${totalHeight}px` }"
    ></div>
    <div
      class="my-virtual-list__content"
      :style="{ transform: `translateY(${offsetY}px)` }"
    >
      <div
        v-for="item in visibleItems"
        :key="item.index"
        class="my-virtual-list__item"
        :style="{ height: `${itemHeight}px` }"
      >
        <slot :item="item.data" :index="item.index"></slot>
      </div>
    </div>
  </div>
</template>

<script lang="ts">
import { defineComponent, ref, computed, onMounted, onUnmounted, watch, PropType } from 'vue';

export default defineComponent({
  name: 'MyVirtualList',
  props: {
    data: {
      type: Array as PropType<any[]>,
      required: true
    },
    itemHeight: {
      type: Number,
      default: 50
    },
    buffer: {
      type: Number,
      default: 5
    }
  },
  setup(props) {
    // 容器引用
    const containerRef = ref<HTMLElement | null>(null);
    
    // 滚动位置
    const scrollTop = ref(0);
    
    // 容器高度
    const viewportHeight = ref(0);
    
    // 总高度
    const totalHeight = computed(() => {
      return props.data.length * props.itemHeight;
    });
    
    // 起始索引
    const startIndex = computed(() => {
      return Math.max(0, Math.floor(scrollTop.value / props.itemHeight) - props.buffer);
    });
    
    // 结束索引
    const endIndex = computed(() => {
      return Math.min(
        props.data.length - 1,
        Math.ceil((scrollTop.value + viewportHeight.value) / props.itemHeight) + props.buffer
      );
    });
    
    // 可见项目
    const visibleItems = computed(() => {
      return props.data
        .slice(startIndex.value, endIndex.value + 1)
        .map((data, index) => ({
          data,
          index: startIndex.value + index
        }));
    });
    
    // 偏移量
    const offsetY = computed(() => {
      return startIndex.value * props.itemHeight;
    });
    
    // 处理滚动事件
    const handleScroll = () => {
      if (containerRef.value) {
        scrollTop.value = containerRef.value.scrollTop;
      }
    };
    
    // 更新容器高度
    const updateViewportHeight = () => {
      if (containerRef.value) {
        viewportHeight.value = containerRef.value.clientHeight;
      }
    };
    
    // 监听窗口大小变化
    const handleResize = () => {
      updateViewportHeight();
    };
    
    // 生命周期钩子
    onMounted(() => {
      updateViewportHeight();
      window.addEventListener('resize', handleResize);
    });
    
    onUnmounted(() => {
      window.removeEventListener('resize', handleResize);
    });
    
    // 监听数据变化
    watch(
      () => props.data,
      () => {
        if (containerRef.value) {
          containerRef.value.scrollTop = 0;
          scrollTop.value = 0;
        }
      }
    );
    
    return {
      containerRef,
      totalHeight,
      visibleItems,
      offsetY,
      handleScroll
    };
  }
});
</script>

<style>
.my-virtual-list {
  position: relative;
  overflow-y: auto;
  height: 100%;
}

.my-virtual-list__phantom {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  z-index: -1;
}

.my-virtual-list__content {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  will-change: transform;
}

.my-virtual-list__item {
  box-sizing: border-box;
}
</style>
```

### 主题定制

提供灵活的主题定制功能：

```ts
// packages/theme/src/index.ts
import { reactive, watch } from 'vue';

// 默认主题变量
const defaultTheme = {
  // 颜色
  'primary-color': '#1890ff',
  'success-color': '#52c41a',
  'warning-color': '#faad14',
  'error-color': '#f5222d',
  'info-color': '#1890ff',
  
  // 文本颜色
  'text-color': 'rgba(0, 0, 0, 0.85)',
  'text-color-secondary': 'rgba(0, 0, 0, 0.65)',
  'disabled-color': 'rgba(0, 0, 0, 0.25)',
  
  // 边框颜色
  'border-color': '#d9d9d9',
  'border-color-split': '#f0f0f0',
  
  // 背景颜色
  'background-color-base': '#f5f5f5',
  'background-color-light': '#fafafa',
  
  // 字体
  'font-family': `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif`,
  'font-size-base': '14px',
  'font-size-sm': '12px',
  'font-size-lg': '16px',
  
  // 圆角
  'border-radius-base': '4px',
  'border-radius-sm': '2px',
  'border-radius-lg': '8px',
  
  // 阴影
  'box-shadow-base': '0 2px 8px rgba(0, 0, 0, 0.15)',
  
  // 动画
  'animation-duration-base': '0.2s',
  'animation-duration-slow': '0.3s',
  'animation-duration-fast': '0.1s',
  
  // 组件特定变量
  'button-height-base': '32px',
  'button-height-sm': '24px',
  'button-height-lg': '40px',
  
  'input-height-base': '32px',
  'input-height-sm': '24px',
  'input-height-lg': '40px',
  
  // 更多变量...
};

// 当前主题
const currentTheme = reactive({ ...defaultTheme });

// 更新CSS变量
const updateCSSVariables = () => {
  const root = document.documentElement;
  
  Object.entries(currentTheme).forEach(([key, value]) => {
    root.style.setProperty(`--${key}`, value);
  });
};

// 设置主题
export function setTheme(theme: Partial<typeof defaultTheme>) {
  Object.assign(currentTheme, theme);
  updateCSSVariables();
}

// 重置主题
export function resetTheme() {
  Object.assign(currentTheme, defaultTheme);
  updateCSSVariables();
}

// 获取当前主题
export function getTheme() {
  return { ...currentTheme };
}

// 初始化
export function initTheme() {
  updateCSSVariables();
}

// 监听主题变化
watch(currentTheme, () => {
  updateCSSVariables();
}, { deep: true });

export default {
  setTheme,
  resetTheme,
  getTheme,
  initTheme
};
```

## 组件库的持续维护

组件库的开发不是一次性工作，需要持续维护和更新。

### 版本管理

使用语义化版本（Semantic Versioning）管理组件库版本：

1. **主版本号（Major）**：当你做了不兼容的API修改
2. **次版本号（Minor）**：当你做了向下兼容的功能性新增
3. **修订号（Patch）**：当你做了向下兼容的问题修正

### 更新日志

维护详细的更新日志，记录每个版本的变更内容：

```md
# 更新日志

## [2.0.0] - 2023-06-15

### 破坏性变更

- **全局**：升级到Vue 3，不再支持Vue 2
- **Button**：移除`ghost`属性，使用`type="text"`替代
- **Form**：重构表单验证API，不再兼容旧版本

### 新特性

- **全局**：使用TypeScript重我将继续编写Vue组件库开发指南的文档内容。

```markdown:c:\project\kphub\src\frontend\vue\03-组件设计\3.12-组件库开发指南.md
- **全局**：使用TypeScript重写所有组件，提供完整类型支持
- **Theme**：新增主题定制功能，支持运行时切换主题
- **VirtualList**：新增虚拟滚动组件，优化大数据渲染性能
- **Form**：新的表单验证系统，支持异步验证和自定义验证规则
- **Table**：新增树形数据展示、行拖拽排序功能
- **Upload**：支持大文件分片上传和断点续传

### 优化

- **性能**：优化组件渲染性能，减少不必要的重渲染
- **体积**：减小打包体积，支持按需引入
- **可访问性**：提升所有组件的可访问性支持
- **文档**：全新的文档网站，提供更丰富的示例和API说明

### 修复

- **Button**：修复在某些情况下点击事件不触发的问题
- **Select**：修复在IE11中下拉菜单定位错误的问题
- **DatePicker**：修复日期范围选择时的边界条件处理问题
- **Modal**：修复多层嵌套时的z-index计算问题

## [1.5.0] - 2023-01-10

### 新特性

- **Table**：新增虚拟滚动功能，优化大数据表格性能
- **Form**：新增表单验证状态展示
- **Upload**：支持文件夹上传

### 优化

- **Button**：优化按钮点击反馈效果
- **Select**：优化下拉菜单定位逻辑
- **Tree**：提升大数据量下的渲染性能

### 修复

- **Pagination**：修复页码计算错误问题
- **DatePicker**：修复日期格式化问题
- **Tabs**：修复标签切换动画问题
```

### 社区贡献

鼓励社区参与组件库的开发和维护：

1. **贡献指南**：编写详细的贡献指南，说明如何参与开发
2. **Issue模板**：提供标准化的Issue模板，方便用户报告问题
3. **Pull Request流程**：规范Pull Request流程，确保代码质量
4. **代码审查**：建立代码审查机制，保证代码质量

```md
# 贡献指南

感谢你考虑为My UI做出贡献！以下是参与贡献的指南。

## 行为准则

请阅读并遵守我们的[行为准则](CODE_OF_CONDUCT.md)。

## 如何贡献

### 报告Bug

1. 确保该Bug尚未在[Issues](https://github.com/yourusername/my-ui/issues)中报告
2. 使用[Bug报告模板](.github/ISSUE_TEMPLATE/bug_report.md)创建一个新的Issue

### 提出新功能

1. 使用[功能请求模板](.github/ISSUE_TEMPLATE/feature_request.md)创建一个新的Issue
2. 描述你想要的功能，以及它如何解决现有问题

### 提交Pull Request

1. Fork仓库并创建你的分支
2. 编写代码和测试
3. 确保代码风格符合规范
4. 提交Pull Request

## 开发流程

### 环境设置

```bash
# 克隆仓库
git clone https://github.com/yourusername/my-ui.git
cd my-ui

# 安装依赖
pnpm install

# 启动开发服务器
pnpm dev
```

### 目录结构

请参考[目录结构](#目录结构)部分了解项目结构。

### 开发新组件

1. 在`packages/components`目录下创建新组件目录
2. 实现组件功能
3. 编写测试
4. 更新文档

### 代码规范

我们使用ESLint和Prettier来保证代码质量和风格一致性：

```bash
# 运行代码检查
pnpm lint

# 自动修复代码风格问题
pnpm lint:fix
```

### 测试

所有新功能和Bug修复都应该包含测试：

```bash
# 运行所有测试
pnpm test

# 运行特定组件的测试
pnpm test button

# 生成测试覆盖率报告
pnpm test:coverage
```

## Pull Request检查清单

提交Pull Request前，请确保：

- [ ] 代码通过所有测试
- [ ] 添加了新功能的测试
- [ ] 更新了相关文档
- [ ] 代码符合代码风格规范
- [ ] Commit消息符合[约定式提交](https://www.conventionalcommits.org/)规范
```

### 持续集成

使用持续集成（CI）工具自动化测试和构建过程：

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
        with:
          version: 7
      - uses: actions/setup-node@v3
        with:
          node-version: '16'
          cache: 'pnpm'
      - run: pnpm install
      - run: pnpm lint

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
        with:
          version: 7
      - uses: actions/setup-node@v3
        with:
          node-version: '16'
          cache: 'pnpm'
      - run: pnpm install
      - run: pnpm test:coverage
      - uses: codecov/codecov-action@v3
        with:
          token: ${{ secrets.CODECOV_TOKEN }}

  build:
    runs-on: ubuntu-latest
    needs: [lint, test]
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
        with:
          version: 7
      - uses: actions/setup-node@v3
        with:
          node-version: '16'
          cache: 'pnpm'
      - run: pnpm install
      - run: pnpm build
      - uses: actions/upload-artifact@v3
        with:
          name: dist
          path: dist/
```

### 自动化发布

使用GitHub Actions自动化发布流程：

```yaml
# .github/workflows/release.yml
name: Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
        with:
          version: 7
      - uses: actions/setup-node@v3
        with:
          node-version: '16'
          cache: 'pnpm'
      - run: pnpm install
      - run: pnpm build
      - uses: actions/upload-artifact@v3
        with:
          name: dist
          path: dist/

  publish-npm:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
        with:
          version: 7
      - uses: actions/setup-node@v3
        with:
          node-version: '16'
          cache: 'pnpm'
          registry-url: 'https://registry.npmjs.org'
      - uses: actions/download-artifact@v3
        with:
          name: dist
          path: dist/
      - run: pnpm publish --no-git-checks
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

  create-github-release:
    needs: publish-npm
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - uses: actions/setup-node@v3
        with:
          node-version: '16'
      - run: npx conventional-changelog-cli -p angular -r 2 > CHANGELOG.md
      - uses: softprops/action-gh-release@v1
        with:
          body_path: CHANGELOG.md
          files: |
            dist/my-ui.es.js
            dist/my-ui.umd.js
            dist/style.css
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

## 组件库的性能优化

组件库的性能直接影响使用该组件库的应用性能，因此性能优化至关重要。

### 减小打包体积

减小组件库的打包体积可以提高应用的加载速度：

1. **Tree Shaking**：确保组件库支持Tree Shaking，只打包使用的组件
2. **代码分割**：将组件拆分为独立的包，支持按需加载
3. **压缩代码**：使用Terser等工具压缩代码
4. **移除不必要的依赖**：减少或优化第三方依赖

```ts
// vite.config.ts中的优化配置
export default defineConfig({
  // ...
  build: {
    // ...
    rollupOptions: {
      // 外部化依赖
      external: ['vue'],
      output: {
        // 为每个组件生成单独的文件
        preserveModules: true,
        preserveModulesRoot: 'packages',
        // 优化chunk命名
        manualChunks: {
          'utils': ['packages/utils/index.ts'],
          'hooks': ['packages/hooks/index.ts'],
          'theme': ['packages/theme/index.ts']
        }
      }
    },
    // 压缩代码
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true
      }
    }
  }
});
```

### 优化渲染性能

提高组件的渲染性能可以提升应用的响应速度：

1. **减少不必要的渲染**：使用`v-memo`、`computed`等优化渲染
2. **虚拟滚动**：对大数据列表使用虚拟滚动
3. **延迟加载**：对非关键组件使用延迟加载
4. **缓存计算结果**：缓存复杂计算的结果

```vue
<!-- 优化表格渲染性能 -->
<template>
  <div class="my-table">
    <table>
      <thead>
        <tr>
          <th v-for="column in columns" :key="column.key">
            {{ column.title }}
          </th>
        </tr>
      </thead>
      <tbody>
        <tr
          v-for="(row, rowIndex) in visibleData"
          :key="getRowKey(row, rowIndex)"
        >
          <td
            v-for="column in columns"
            :key="column.key"
            v-memo="[row[column.key], column.key, rowIndex]"
          >
            <template v-if="column.render">
              <component
                :is="column.render"
                :record="row"
                :index="rowIndex"
                :column="column"
              />
            </template>
            <template v-else>
              {{ row[column.key] }}
            </template>
          </td>
        </tr>
      </tbody>
    </table>
  </div>
</template>

<script>
import { computed } from 'vue';

export default {
  props: {
    data: Array,
    columns: Array,
    rowKey: [String, Function]
  },
  setup(props) {
    // 使用计算属性缓存可见数据
    const visibleData = computed(() => {
      return props.data.slice(0, 100); // 简化示例，实际应使用虚拟滚动
    });
    
    // 获取行的唯一键
    const getRowKey = (row, index) => {
      if (typeof props.rowKey === 'function') {
        return props.rowKey(row);
      }
      return props.rowKey ? row[props.rowKey] : index;
    };
    
    return {
      visibleData,
      getRowKey
    };
  }
};
</script>
```

### 优化首次加载时间

减少组件库对应用首次加载时间的影响：

1. **按需加载**：只加载使用的组件
2. **代码分割**：将大组件拆分为多个小块
3. **预编译**：预编译模板，减少运行时编译
4. **服务端渲染**：支持服务端渲染，提高首屏加载速度

```ts
// 支持按需加载的插件配置
// vite.config.ts
import { Plugin } from 'vite';

function myUIImport(): Plugin {
  return {
    name: 'my-ui-import',
    transform(code, id) {
      if (!/\.[jt]sx?$/.test(id) || id.includes('node_modules')) {
        return;
      }
      
      // 匹配 import { Button, Input } from 'my-ui'
      const importRegex = /import\s+{([^}]+)}\s+from\s+['"]my-ui['"]/g;
      
      return code.replace(importRegex, (match, components) => {
        const componentList = components
          .split(',')
          .map(name => name.trim())
          .filter(Boolean);
        
        // 转换为按需导入
        return componentList
          .map(name => `import ${name} from 'my-ui/es/${name.toLowerCase()}';`)
          .join('\n');
      });
    }
  };
}
```

## 组件库的未来趋势

随着前端技术的发展，组件库也在不断演进。以下是一些值得关注的趋势：

### Web Components

Web Components是一组标准化的API，允许创建可重用的自定义元素：

```ts
// 使用Web Components封装Vue组件
import { defineCustomElement } from 'vue';
import Button from './components/button/src/Button.vue';

// 将Vue组件转换为自定义元素构造函数
const ButtonElement = defineCustomElement(Button);

// 注册自定义元素
customElements.define('my-button', ButtonElement);
```

### 跨框架组件

开发能够在多个框架中使用的组件：

```ts
// 使用Stencil开发跨框架组件
import { Component, Prop, h, Event, EventEmitter } from '@stencil/core';

@Component({
  tag: 'my-button',
  styleUrl: 'button.css',
  shadow: true
})
export class MyButton {
  @Prop() type: string = 'default';
  @Prop() disabled: boolean = false;
  @Prop() loading: boolean = false;
  
  @Event() myClick: EventEmitter;
  
  handleClick = (event: MouseEvent) => {
    if (this.disabled || this.loading) return;
    this.myClick.emit(event);
  };
  
  render() {
    return (
      <button
        class={{
          'my-button': true,
          [`my-button--${this.type}`]: true,
          'is-disabled': this.disabled,
          'is-loading': this.loading
        }}
        disabled={this.disabled || this.loading}
        onClick={this.handleClick}
      >
        {this.loading && <span class="loading-icon"></span>}
        <slot></slot>
      </button>
    );
  }
}
```

### 无障碍设计

更加注重组件的可访问性设计：

```vue
<!-- 可访问的下拉菜单组件 -->
<template>
  <div class="my-dropdown">
    <button
      :id="`dropdown-button-${id}`"
      class="my-dropdown__button"
      aria-haspopup="true"
      :aria-expanded="isOpen"
      :aria-controls="`dropdown-menu-${id}`"
      @click="toggle"
    >
      <slot name="button">{{ label }}</slot>
    </button>
    
    <div
      :id="`dropdown-menu-${id}`"
      class="my-dropdown__menu"
      :class="{ 'is-open': isOpen }"
      role="menu"
      :aria-labelledby="`dropdown-button-${id}`"
      v-show="isOpen"
    >
      <slot></slot>
    </div>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted } from 'vue';
import { useId } from '../../hooks';

export default {
  name: 'MyDropdown',
  props: {
    label: {
      type: String,
      default: 'Dropdown'
    }
  },
  setup() {
    const id = useId();
    const isOpen = ref(false);
    
    const toggle = () => {
      isOpen.value = !isOpen.value;
    };
    
    const close = (event) => {
      if (!event.target.closest('.my-dropdown')) {
        isOpen.value = false;
      }
    };
    
    onMounted(() => {
      document.addEventListener('click', close);
    });
    
    onUnmounted(() => {
      document.removeEventListener('click', close);
    });
    
    return {
      id,
      isOpen,
      toggle
    };
  }
};
</script>
```

### 低代码集成

设计能够与低代码平台集成的组件：

```ts
// 组件元数据，用于低代码平台
export const buttonMeta = {
  componentName: 'Button',
  title: '按钮',
  category: '基础组件',
  props: [
    {
      name: 'type',
      title: '类型',
      type: 'string',
      defaultValue: 'default',
      options: [
        { label: '默认', value: 'default' },
        { label: '主要', value: 'primary' },
        { label: '成功', value: 'success' },
        { label: '警告', value: 'warning' },
        { label: '危险', value: 'danger' }
      ]
    },
    {
      name: 'size',
      title: '尺寸',
      type: 'string',
      defaultValue: 'medium',
      options: [
        { label: '小', value: 'small' },
        { label: '中', value: 'medium' },
        { label: '大', value: 'large' }
      ]
    },
    {
      name: 'disabled',
      title: '禁用',
      type: 'boolean',
      defaultValue: false
    },
    {
      name: 'loading',
      title: '加载中',
      type: 'boolean',
      defaultValue: false
    }
  ],
  events: [
    {
      name: 'click',
      title: '点击事件'
    }
  ],
  slots: [
    {
      name: 'default',
      title: '默认插槽'
    },
    {
      name: 'loading-icon',
      title: '加载图标'
    }
  ]
};
```

## 总结

开发一个高质量的Vue组件库是一项复杂的工作，需要考虑架构设计、API设计、样式系统、文档生成、测试策略等多个方面。本文详细介绍了组件库开发的各个环节，从前期准备到持续维护，希望能够帮助读者构建自己的组件库。

组件库开发是一个持续迭代的过程，需要不断收集用户反馈，优化组件设计和实现。随着前端技术的发展，组件库也需要不断更新，以适应新的技术趋势和用户需求。

通过遵循本文介绍的最佳实践，你可以开发出一个易用、高效、可维护的Vue组件库，为你的团队或社区提供价值。

## 参考资料

1. [Vue.js官方文档](https://cn.vuejs.org/)
2. [Element Plus组件库](https://element-plus.org/)
3. [Ant Design Vue组件库](https://antdv.com/)
4. [VitePress文档生成器](https://vitepress.vuejs.org/)
5. [Vite构建工具](https://cn.vitejs.dev/)
6. [TypeScript官方文档](https://www.typescriptlang.org/)
7. [Web Components标准](https://developer.mozilla.org/zh-CN/docs/Web/Web_Components)
8. [WCAG可访问性指南](https://www.w3.org/WAI/standards-guidelines/wcag/)
9. [Storybook组件开发环境](https://storybook.js.org/)
10. [Vitest测试框架](https://vitest.dev/)
```

这份组件库开发指南涵盖了从架构设计、API设计、样式系统到文档生成、测试策略等多个方面，为开发者提供了全面的指导。文档中包含了大量代码示例和最佳实践，适合不同级别的开发者阅读和参考。
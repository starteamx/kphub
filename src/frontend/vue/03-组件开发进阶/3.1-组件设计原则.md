我将为您编写一份关于Vue组件设计原则的详细文档，适合不同级别的开发者阅读。

```markdown:c:\project\kphub\src\frontend\vue\03-组件设计\3.1-组件设计原则.md
---
title: 组件设计原则
icon: design
order: 1
---

# 组件设计原则

良好的组件设计是构建可维护Vue应用的基础。本文将介绍Vue组件设计的核心原则和最佳实践，包括单一职责、接口设计、状态管理、可复用性、可测试性等内容，帮助读者设计出高质量的Vue组件。

## 为什么组件设计很重要？

在深入探讨具体原则之前，我们需要理解为什么组件设计如此重要。Vue是一个组件化的框架，整个应用由组件构建而成。良好的组件设计能够带来以下好处：

1. **提高代码可维护性**：结构清晰的组件更容易理解和修改
2. **增强代码可复用性**：设计良好的组件可以在多个场景中重复使用
3. **改善团队协作**：明确的组件边界使团队成员能够并行工作而不互相干扰
4. **降低bug率**：职责单一、接口清晰的组件更不容易出错
5. **提升性能**：合理的组件粒度有助于Vue的渲染优化

相反，设计不良的组件会导致"面条式代码"、紧耦合、难以测试和维护的应用。因此，掌握组件设计原则对于构建高质量的Vue应用至关重要。

## 单一职责原则

### 什么是单一职责原则？

单一职责原则（Single Responsibility Principle，SRP）是软件设计中最基本的原则之一，它指出一个组件应该只有一个变化的理由。应用到Vue组件设计中，意味着每个组件应该只专注于做好一件事。

### 为什么要遵循单一职责原则？

当一个组件承担了过多的职责时，会导致以下问题：

1. 组件代码膨胀，难以理解和维护
2. 组件之间的耦合度增加
3. 组件难以复用
4. 测试变得复杂

### 如何在Vue中应用单一职责原则

#### 1. 按功能拆分组件

识别组件中的不同功能点，将它们拆分为独立的子组件：

```vue
<!-- 不好的例子：UserDashboard.vue 承担了多个职责 -->
<template>
  <div class="dashboard">
    <!-- 用户信息展示 -->
    <div class="user-profile">
      <img :src="user.avatar" alt="User avatar">
      <h2>{{ user.name }}</h2>
      <p>{{ user.email }}</p>
      <button @click="editProfile">编辑资料</button>
    </div>
    
    <!-- 数据统计展示 -->
    <div class="statistics">
      <h3>数据统计</h3>
      <div class="stat-item">
        <span>文章数:</span>
        <span>{{ statistics.articles }}</span>
      </div>
      <div class="stat-item">
        <span>评论数:</span>
        <span>{{ statistics.comments }}</span>
      </div>
      <div class="stat-item">
        <span>点赞数:</span>
        <span>{{ statistics.likes }}</span>
      </div>
    </div>
    
    <!-- 最近活动列表 -->
    <div class="recent-activities">
      <h3>最近活动</h3>
      <ul>
        <li v-for="activity in recentActivities" :key="activity.id">
          {{ activity.description }} - {{ formatDate(activity.date) }}
        </li>
      </ul>
    </div>
  </div>
</template>
```

改进后的设计：

```vue
<!-- 好的例子：UserDashboard.vue 只负责组织布局 -->
<template>
  <div class="dashboard">
    <UserProfile 
      :user="user" 
      @edit="handleEditProfile" 
    />
    
    <UserStatistics :statistics="statistics" />
    
    <ActivityList 
      :activities="recentActivities" 
      title="最近活动" 
    />
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import UserProfile from './UserProfile.vue'
import UserStatistics from './UserStatistics.vue'
import ActivityList from './ActivityList.vue'
import { fetchUserData } from '@/api/user'

const user = ref({})
const statistics = ref({})
const recentActivities = ref([])

onMounted(async () => {
  const userData = await fetchUserData()
  user.value = userData.profile
  statistics.value = userData.statistics
  recentActivities.value = userData.activities
})

function handleEditProfile() {
  // 处理编辑资料的逻辑
}
</script>
```

#### 2. 使用组合式API分离关注点

组合式API（Composition API）是Vue 3引入的特性，它允许我们按照逻辑关注点组织代码，而不是按照选项类型：

```vue
<script setup>
import { ref, onMounted } from 'vue'
import { useUserProfile } from '@/composables/useUserProfile'
import { useStatistics } from '@/composables/useStatistics'
import { useActivities } from '@/composables/useActivities'

// 用户资料相关逻辑
const { user, updateUser, isLoading: isUserLoading } = useUserProfile()

// 统计数据相关逻辑
const { statistics, refreshStatistics, isLoading: isStatsLoading } = useStatistics()

// 活动列表相关逻辑
const { activities, loadMore, hasMore, isLoading: isActivitiesLoading } = useActivities()

// 页面加载状态
const isPageLoading = computed(() => 
  isUserLoading.value || isStatsLoading.value || isActivitiesLoading.value
)
</script>
```

这种方式使得每个关注点的逻辑都被封装在独立的组合式函数中，使代码更加模块化和可维护。

## 接口设计原则

组件的接口是指组件与外部世界交互的方式，主要包括props、事件和插槽。良好的接口设计使组件更易于使用和理解。

### Props设计原则

Props是父组件向子组件传递数据的方式。设计良好的props应该遵循以下原则：

#### 1. 明确的类型和默认值

始终为props指定类型和默认值（如果适用），这样可以提高组件的可预测性和自文档性：

```vue
<script setup>
defineProps({
  // 不好的例子
  items: Array,
  
  // 好的例子
  products: {
    type: Array,
    required: true,
    default: () => []
  },
  maxDisplay: {
    type: Number,
    default: 5,
    validator: (value) => value > 0
  },
  sortOrder: {
    type: String,
    default: 'asc',
    validator: (value) => ['asc', 'desc'].includes(value)
  }
})
</script>
```

#### 2. 使用对象props减少参数数量

当需要传递多个相关的props时，考虑使用一个对象prop来减少参数数量：

```vue
<!-- 不好的例子：参数过多 -->
<UserCard
  :firstName="user.firstName"
  :lastName="user.lastName"
  :email="user.email"
  :age="user.age"
  :address="user.address"
  :phone="user.phone"
  :company="user.company"
/>

<!-- 好的例子：使用对象prop -->
<UserCard :user="user" />
```

#### 3. 避免过度使用布尔props

多个布尔props可能导致组件使用复杂化。考虑使用枚举值或对象配置：

```vue
<!-- 不好的例子：多个布尔props -->
<DataTable
  :showHeader="true"
  :showFooter="false"
  :enableSorting="true"
  :enableFiltering="true"
  :enablePagination="true"
  :enableSelection="false"
/>

<!-- 好的例子：使用对象配置 -->
<DataTable :options="{
  header: true,
  footer: false,
  features: {
    sorting: true,
    filtering: true,
    pagination: true,
    selection: false
  }
}" />
```

### 事件设计原则

事件是子组件向父组件传递信息的主要方式。

#### 1. 使用具有描述性的事件名称

事件名称应该清晰地表达发生了什么，而不是父组件应该做什么：

```vue
<!-- 不好的例子：事件名称描述父组件行为 -->
<template>
  <button @click="$emit('showUserDetails', user.id)">查看详情</button>
</template>

<!-- 好的例子：事件名称描述发生了什么 -->
<template>
  <button @click="$emit('user-click', user.id)">查看详情</button>
</template>
```

#### 2. 提供有用的事件参数

事件参数应该包含父组件可能需要的所有信息：

```vue
<!-- 不好的例子：参数不足 -->
<template>
  <div class="product-card" @click="$emit('click')">
    <!-- 产品卡片内容 -->
  </div>
</template>

<!-- 好的例子：提供完整参数 -->
<template>
  <div class="product-card" @click="handleClick">
    <!-- 产品卡片内容 -->
  </div>
</template>

<script setup>
const props = defineProps({
  product: {
    type: Object,
    required: true
  }
})

const emit = defineEmits(['product-click'])

function handleClick(event) {
  emit('product-click', {
    product: props.product,
    originalEvent: event
  })
}
</script>
```

#### 3. 使用update:propName模式实现双向绑定

对于需要支持双向绑定的组件，使用`update:propName`事件模式：

```vue
<!-- CustomInput.vue -->
<template>
  <input
    :value="modelValue"
    @input="$emit('update:modelValue', $event.target.value)"
  />
</template>

<script setup>
defineProps({
  modelValue: {
    type: String,
    default: ''
  }
})

defineEmits(['update:modelValue'])
</script>

<!-- 使用组件 -->
<template>
  <CustomInput v-model="searchText" />
</template>
```

### 插槽设计原则

插槽允许父组件向子组件传递内容，是实现组件灵活性的重要机制。

#### 1. 提供合理的默认内容

为插槽提供默认内容，使组件在没有传入内容时也能正常工作：

```vue
<template>
  <button class="btn">
    <slot>
      <!-- 默认内容 -->
      提交
    </slot>
  </button>
</template>
```

#### 2. 使用具名插槽组织复杂布局

当组件有多个内容分发点时，使用具名插槽：

```vue
<template>
  <div class="card">
    <div class="card-header">
      <slot name="header">
        <h3>默认标题</h3>
      </slot>
    </div>
    
    <div class="card-body">
      <slot>
        <!-- 默认内容 -->
        <p>暂无内容</p>
      </slot>
    </div>
    
    <div class="card-footer">
      <slot name="footer">
        <!-- 默认页脚 -->
      </slot>
    </div>
  </div>
</template>
```

#### 3. 使用作用域插槽传递数据

当子组件需要向插槽内容传递数据时，使用作用域插槽：

```vue
<!-- ItemList.vue -->
<template>
  <ul class="item-list">
    <li v-for="(item, index) in items" :key="item.id">
      <slot :item="item" :index="index" :remove="() => removeItem(index)">
        <!-- 默认渲染 -->
        {{ item.name }}
      </slot>
    </li>
  </ul>
</template>

<script setup>
import { defineProps } from 'vue'

const props = defineProps({
  items: {
    type: Array,
    required: true
  }
})

const emit = defineEmits(['remove'])

function removeItem(index) {
  emit('remove', index)
}
</script>

<!-- 使用组件 -->
<template>
  <ItemList :items="tasks" @remove="removeTask">
    <template #default="{ item, index, remove }">
      <div class="task-item">
        <span>{{ index + 1 }}. {{ item.name }}</span>
        <button @click="remove">删除</button>
      </div>
    </template>
  </ItemList>
</template>
```

## 状态管理原则

组件状态是指组件内部的数据，它决定了组件的渲染输出。良好的状态管理是设计高质量组件的关键。

### 状态分类与管理策略

#### 1. 本地状态

本地状态是只在组件内部使用的数据，不需要与其他组件共享：

```vue
<script setup>
import { ref } from 'vue'

// 本地状态
const isExpanded = ref(false)
const activeTab = ref('info')

function toggleExpand() {
  isExpanded.value = !isExpanded.value
}

function setActiveTab(tab) {
  activeTab.value = tab
}
</script>
```

本地状态应该保持在组件内部，不要暴露给外部。

#### 2. 共享状态

共享状态需要在多个组件之间共享。根据共享范围的不同，可以采用不同的管理策略：

- **父子组件共享**：使用props和事件
- **兄弟组件共享**：通过共同的父组件或状态管理库
- **全局共享**：使用Pinia或Vuex等状态管理库

```vue
<!-- 使用Pinia管理共享状态 -->
<script setup>
import { useCartStore } from '@/stores/cart'

// 获取购物车状态
const cartStore = useCartStore()

// 使用状态
const { items, totalPrice, itemCount } = storeToRefs(cartStore)

// 调用操作
function addToCart(product) {
  cartStore.addItem(product)
}
</script>
```

### 状态派生原则

尽可能使用计算属性派生状态，而不是创建额外的响应式变量：

```vue
<script setup>
import { ref, computed } from 'vue'

const items = ref([
  { id: 1, name: 'Item 1', price: 100, quantity: 2 },
  { id: 2, name: 'Item 2', price: 200, quantity: 1 },
  { id: 3, name: 'Item 3', price: 300, quantity: 3 }
])

// 不好的例子：创建额外的响应式变量
const totalPrice = ref(0)
watch(items, () => {
  totalPrice.value = items.value.reduce((sum, item) => sum + item.price * item.quantity, 0)
}, { immediate: true })

// 好的例子：使用计算属性派生状态
const totalAmount = computed(() => 
  items.value.reduce((sum, item) => sum + item.price * item.quantity, 0)
)

const itemCount = computed(() => items.value.length)

const hasItems = computed(() => itemCount.value > 0)
</script>
```

### 状态变更原则

状态变更应该是可预测的，并且遵循单向数据流：

```vue
<script setup>
import { ref } from 'vue'

const count = ref(0)

// 不好的例子：多处修改状态，难以追踪
function handleButtonClick() {
  count.value += 1
}

function handleKeyPress() {
  count.value += 1
}

// 好的例子：集中管理状态变更
function increment() {
  count.value += 1
}

function handleButtonClick() {
  increment()
}

function handleKeyPress() {
  increment()
}
</script>
```

## 可复用性原则

可复用的组件可以在多个场景中使用，减少代码重复并提高开发效率。

### 设计可复用组件的原则

#### 1. 关注点分离

将组件的视觉表现与行为逻辑分离：

```vue
<!-- 不好的例子：紧耦合的表现和逻辑 -->
<template>
  <div class="user-list">
    <div v-if="loading">加载中...</div>
    <div v-else-if="error">加载失败: {{ error }}</div>
    <ul v-else>
      <li v-for="user in users" :key="user.id">
        {{ user.name }}
      </li>
    </ul>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue'
import axios from 'axios'

const users = ref([])
const loading = ref(true)
const error = ref(null)

onMounted(async () => {
  try {
    const response = await axios.get('/api/users')
    users.value = response.data
  } catch (err) {
    error.value = err.message
  } finally {
    loading.value = false
  }
})
</script>

<!-- 好的例子：分离的关注点 -->
<!-- DataFetcher.vue - 处理数据获取逻辑 -->
<template>
  <div>
    <div v-if="loading">
      <slot name="loading">加载中...</slot>
    </div>
    <div v-else-if="error">
      <slot name="error" :error="error">加载失败: {{ error }}</slot>
    </div>
    <div v-else>
      <slot :data="data"></slot>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, watch } from 'vue'

const props = defineProps({
  url: {
    type: String,
    required: true
  },
  method: {
    type: String,
    default: 'GET'
  },
  params: {
    type: Object,
    default: () => ({})
  }
})

const data = ref(null)
const loading = ref(true)
const error = ref(null)

async function fetchData() {
  loading.value = true
  error.value = null
  
  try {
    const response = await fetch(props.url, {
      method: props.method,
      ...props.params
    })
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    data.value = await response.json()
  } catch (err) {
    error.value = err.message
  } finally {
    loading.value = false
  }
}

onMounted(fetchData)

watch(() => [props.url, props.method, props.params], fetchData)
</script>

<!-- 使用DataFetcher组件 -->
<template>
  <div class="user-list">
    <DataFetcher url="/api/users">
      <template #loading>
        <LoadingSpinner />
      </template>
      
      <template #error="{ error }">
        <ErrorMessage :message="error" />
      </template>
      
      <template #default="{ data }">
        <UserList :users="data" />
      </template>
    </DataFetcher>
  </div>
</template>
```

#### 2. 组合优于继承

Vue的组件系统鼓励通过组合而非继承来构建UI。使用组合式API、混入或组合组件来实现代码复用：

```vue
<!-- 使用组合式API实现功能复用 -->
<script setup>
import { useForm } from '@/composables/useForm'
import { useValidation } from '@/composables/useValidation'
import { useSubmit } from '@/composables/useSubmit'

// 表单状态管理
const { formData, resetForm, updateField } = useForm({
  name: '',
  email: '',
  message: ''
})

// 表单验证
const { errors, validate, isValid } = useValidation(formData, {
  name: { required: true, minLength: 3 },
  email: { required: true, email: true },
  message: { required: true, minLength: 10 }
})

// 表单提交
const { submit, isSubmitting, isSubmitted, submitError } = useSubmit({
  url: '/api/contact',
  onSuccess: resetForm
})

// 处理表单提交
async function handleSubmit() {
  if (await validate()) {
    submit(formData)
  }
}
</script>
```

#### 3. 配置驱动的组件

设计可通过配置调整行为的组件，而不是创建多个相似的组件：

```vue
<!-- 可配置的按钮组件 -->
<template>
  <button
    :class="[
      'btn',
      `btn-${variant}`,
      `btn-${size}`,
      { 'btn-block': block, 'btn-rounded': rounded }
    ]"
    :disabled="disabled || loading"
    @click="$emit('click', $event)"
  >
    <span v-if="loading" class="spinner"></span>
    <slot></slot>
  </button>
</template>

<script setup>
defineProps({
  variant: {
    type: String,
    default: 'primary',
    validator: (value) => ['primary', 'secondary', 'success', 'danger', 'warning', 'info'].includes(value)
  },
  size: {
    type: String,
    default: 'md',
    validator: (value) => ['sm', 'md', 'lg'].includes(value)
  },
  block: {
    type: Boolean,
    default: false
  },
  rounded: {
    type: Boolean,
    default: false
  },
  disabled: {
    type: Boolean,
    default: false
  },
  loading: {
    type: Boolean,
    default: false
  }
})

defineEmits(['click'])
</script>

<!-- 使用可配置按钮 -->
<template>
  <div>
    <AppButton>默认按钮</AppButton>
    <AppButton variant="success" size="lg">大号成功按钮</AppButton>
    <AppButton variant="danger" rounded>圆角危险按钮</AppButton>
    <AppButton variant="info" block>块级信息按钮</AppButton>
    <AppButton loading>加载中按钮</AppButton>
  </div>
</template>
```

### 组件抽象级别

根据抽象级别，可以将组件分为以下几类：

#### 1. 基础组件（Base/UI Components）

基础组件是最底层的可复用组件，通常只关注UI表现，不包含业务逻辑：

```vue
<!-- BaseInput.vue -->
<template>
  <div class="form-group">
    <label v-if="label" :for="id">{{ label }}</label>
    <input
      :id="id"
      :type="type"
      :value="modelValue"
      :placeholder="placeholder"
      :disabled="disabled"
      :class="['form-control', { 'is-invalid': error }]"
      @input="$emit('update:modelValue', $event.target.value)"
    />
    <div v-if="error" class="invalid-feedback">{{ error }}</div>
    <small v-if="hint" class="form-text text-muted">{{ hint }}</small>
  </div>
</template>

<script setup>
import { computed } from 'vue'

const props = defineProps({
  modelValue: {
    type: [String, Number],
    default: ''
  },
  label: {
    type: String,
    default: ''
  },
  type: {
    type: String,
    default: 'text'
  },
  placeholder: {
    type: String,
    default: ''
  },
  disabled: {
    type: Boolean,
    default: false
  },
  error: {
    type: String,
    default: ''
  },
  hint: {
    type: String,
    default: ''
  },
  id: {
    type: String,
    default: ''
  }
})

defineEmits(['update:modelValue'])

const inputId = computed(() => props.id || `input-${Date.now()}`)
</script>
```

#### 2. 复合组件（Composite Components）

复合组件由多个基础组件组合而成，可能包含一些简单的业务逻辑：

```vue
<!-- SearchBox.vue -->
<template>
  <div class="search-box">
    <BaseInput
      v-model="searchQuery"
      :placeholder="placeholder"
      :disabled="disabled"
      @update:modelValue="handleInput"
    >
      <template #prepend>
        <BaseIcon name="search" />
      </template>
    </BaseInput>
    
    <BaseButton
      v-if="showClearButton && searchQuery"
      variant="text"
      @click="clearSearch"
    >
      <BaseIcon name="x" />
    </BaseButton>
  </div>
</template>

<script setup>
import { ref, watch } from 'vue'
import BaseInput from '@/components/base/BaseInput.vue'
import BaseButton from '@/components/base/BaseButton.vue'
import BaseIcon from '@/components/base/BaseIcon.vue'

const props = defineProps({
  initialValue: {
    type: String,
    default: ''
  },
  placeholder: {
    type: String,
    default: '搜索...'
  },
  disabled: {
    type: Boolean,
    default: false
  },
  showClearButton: {
    type: Boolean,
    default: true
  },
  debounce: {
    type: Number,
    default: 300
  }
})

const emit = defineEmits(['search', 'clear'])

const searchQuery = ref(props.initialValue)
let debounceTimer = null

function handleInput(value) {
  searchQuery.value = value
  
  if (debounceTimer) clearTimeout(debounceTimer)
  
  debounceTimer = setTimeout(() => {
    emit('search', value)
  }, props.debounce)
}

function clearSearch() {
  searchQuery.value = ''
  emit('clear')
  emit('search', '')
}

watch(() => props.initialValue, (newValue) => {
  searchQuery.value = newValue
})
</script>
```

#### 3. 业务组件（Business Components）

业务组件包含特定业务逻辑，通常不会跨项目复用：

```vue
<!-- ProductCard.vue -->
<template>
  <div class="product-card" :class="{ 'is-featured': product.featured }">
    <div class="product-image">
      <img :src="product.image" :alt="product.name">
      <span v-if="product.discount" class="discount-badge">
        -{{ product.discount }}%
      </span>
    </div>
    
    <div class="product-info">
      <h3 class="product-name">{{ product.name }}</h3>
      <div class="product-price">
        <span v-if="product.discount" class="original-price">
          {{ formatPrice(product.price) }}
        </span>
        <span class="current-price">
          {{ formatPrice(discountedPrice) }}
        </span>
      </div>
      
      <div class="product-rating">
        <StarRating :value="product.rating" readonly />
        <span class="review-count">({{ product.reviewCount }})</span>
      </div>
    </div>
    
    <div class="product-actions">
      <BaseButton
        variant="primary"
        :disabled="!product.inStock"
        @click="addToCart"
      >
        {{ product.inStock ? '加入购物车' : '缺货' }}
      </BaseButton>
      
      <BaseButton
        variant="outline"
        @click="toggleFavorite"
      >
        <BaseIcon :name="isFavorite ? 'heart-fill' : 'heart'" />
      </BaseButton>
    </div>
  </div>
</template>

<script setup>
import { computed, ref } from 'vue'
import { useCartStore } from '@/stores/cart'
import { useFavoriteStore } from '@/stores/favorites'
import BaseButton from '@/components/base/BaseButton.vue'
import BaseIcon from '@/components/base/BaseIcon.vue'
import StarRating from '@/components/StarRating.vue'

const props = defineProps({
  product: {
    type: Object,
    required: true
  }
})

const cartStore = useCartStore()
const favoriteStore = useFavoriteStore()

const isFavorite = computed(() => 
  favoriteStore.isFavorite(props.product.id)
)

const discountedPrice = computed(() => {
  if (!props.product.discount) return props.product.price
  return props.product.price * (1 - props.product.discount / 100)
})我将继续编写Vue组件设计原则的文档内容。

```markdown:c:\project\kphub\src\frontend\vue\03-组件设计\3.1-组件设计原则.md
<script setup>
import { computed, ref } from 'vue'
import { useCartStore } from '@/stores/cart'
import { useFavoriteStore } from '@/stores/favorites'
import BaseButton from '@/components/base/BaseButton.vue'
import BaseIcon from '@/components/base/BaseIcon.vue'
import StarRating from '@/components/StarRating.vue'

const props = defineProps({
  product: {
    type: Object,
    required: true
  }
})

const cartStore = useCartStore()
const favoriteStore = useFavoriteStore()

const isFavorite = computed(() => 
  favoriteStore.isFavorite(props.product.id)
)

const discountedPrice = computed(() => {
  if (!props.product.discount) return props.product.price
  return props.product.price * (1 - props.product.discount / 100)
})

function formatPrice(price) {
  return `¥${price.toFixed(2)}`
}

function addToCart() {
  cartStore.addItem(props.product)
}

function toggleFavorite() {
  if (isFavorite.value) {
    favoriteStore.removeFavorite(props.product.id)
  } else {
    favoriteStore.addFavorite(props.product)
  }
}
</script>
```

#### 4. 页面组件（Page Components）

页面组件是应用的顶层组件，通常对应一个路由：

```vue
<!-- ProductListPage.vue -->
<template>
  <div class="product-list-page">
    <PageHeader title="产品列表">
      <template #actions>
        <SearchBox
          v-model="searchQuery"
          placeholder="搜索产品..."
          @search="handleSearch"
        />
        <FilterDropdown
          :options="filterOptions"
          v-model="activeFilter"
        />
        <SortDropdown
          :options="sortOptions"
          v-model="activeSort"
        />
      </template>
    </PageHeader>
    
    <div class="product-grid">
      <template v-if="isLoading">
        <ProductCardSkeleton v-for="i in 8" :key="i" />
      </template>
      
      <template v-else-if="filteredProducts.length">
        <ProductCard
          v-for="product in filteredProducts"
          :key="product.id"
          :product="product"
          @click="navigateToDetail(product.id)"
        />
      </template>
      
      <EmptyState
        v-else
        title="没有找到产品"
        description="尝试调整搜索条件或筛选器"
        icon="search-not-found"
      />
    </div>
    
    <Pagination
      v-if="totalPages > 1"
      :current-page="currentPage"
      :total-pages="totalPages"
      @change="handlePageChange"
    />
  </div>
</template>

<script setup>
import { ref, computed, onMounted, watch } from 'vue'
import { useRouter } from 'vue-router'
import { useProductStore } from '@/stores/product'
import PageHeader from '@/components/layout/PageHeader.vue'
import SearchBox from '@/components/SearchBox.vue'
import FilterDropdown from '@/components/FilterDropdown.vue'
import SortDropdown from '@/components/SortDropdown.vue'
import ProductCard from '@/components/ProductCard.vue'
import ProductCardSkeleton from '@/components/skeletons/ProductCardSkeleton.vue'
import EmptyState from '@/components/EmptyState.vue'
import Pagination from '@/components/Pagination.vue'

const router = useRouter()
const productStore = useProductStore()

// 页面状态
const searchQuery = ref('')
const activeFilter = ref('all')
const activeSort = ref('newest')
const currentPage = ref(1)
const pageSize = 12

// 筛选和排序选项
const filterOptions = [
  { value: 'all', label: '全部' },
  { value: 'inStock', label: '有库存' },
  { value: 'featured', label: '推荐' },
  { value: 'discounted', label: '折扣' }
]

const sortOptions = [
  { value: 'newest', label: '最新' },
  { value: 'priceAsc', label: '价格从低到高' },
  { value: 'priceDesc', label: '价格从高到低' },
  { value: 'nameAsc', label: '名称 A-Z' },
  { value: 'nameDesc', label: '名称 Z-A' }
]

// 加载产品
const isLoading = ref(true)

onMounted(async () => {
  try {
    await productStore.fetchProducts()
  } finally {
    isLoading.value = false
  }
})

// 筛选和排序产品
const filteredProducts = computed(() => {
  let result = productStore.products

  // 应用搜索
  if (searchQuery.value) {
    const query = searchQuery.value.toLowerCase()
    result = result.filter(product => 
      product.name.toLowerCase().includes(query) ||
      product.description.toLowerCase().includes(query)
    )
  }

  // 应用筛选
  if (activeFilter.value === 'inStock') {
    result = result.filter(product => product.inStock)
  } else if (activeFilter.value === 'featured') {
    result = result.filter(product => product.featured)
  } else if (activeFilter.value === 'discounted') {
    result = result.filter(product => product.discount > 0)
  }

  // 应用排序
  if (activeSort.value === 'priceAsc') {
    result = [...result].sort((a, b) => a.price - b.price)
  } else if (activeSort.value === 'priceDesc') {
    result = [...result].sort((a, b) => b.price - a.price)
  } else if (activeSort.value === 'nameAsc') {
    result = [...result].sort((a, b) => a.name.localeCompare(b.name))
  } else if (activeSort.value === 'nameDesc') {
    result = [...result].sort((a, b) => b.name.localeCompare(a.name))
  } else {
    // 默认按最新排序
    result = [...result].sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))
  }

  return result
})

// 分页
const totalProducts = computed(() => filteredProducts.value.length)
const totalPages = computed(() => Math.ceil(totalProducts.value / pageSize))
const paginatedProducts = computed(() => {
  const start = (currentPage.value - 1) * pageSize
  const end = start + pageSize
  return filteredProducts.value.slice(start, end)
})

// 处理页面变化
function handlePageChange(page) {
  currentPage.value = page
  window.scrollTo({ top: 0, behavior: 'smooth' })
}

// 处理搜索
function handleSearch(query) {
  searchQuery.value = query
  currentPage.value = 1
}

// 导航到产品详情
function navigateToDetail(productId) {
  router.push(`/products/${productId}`)
}

// 重置分页
watch([searchQuery, activeFilter, activeSort], () => {
  currentPage.value = 1
})
</script>
```

## 可测试性原则

可测试的组件更容易验证其功能正确性，减少bug和回归问题。

### 设计可测试组件的原则

#### 1. 关注点分离

将业务逻辑与UI渲染分离，使逻辑部分更容易测试：

```vue
<!-- 不好的例子：逻辑和UI混合 -->
<template>
  <div>
    <h2>购物车</h2>
    <ul>
      <li v-for="item in items" :key="item.id">
        {{ item.name }} - {{ item.price }}元 x {{ item.quantity }}
        <button @click="removeItem(item.id)">删除</button>
      </li>
    </ul>
    <p>总价: {{ calculateTotal() }}元</p>
    <button @click="checkout">结算</button>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const items = ref([
  { id: 1, name: '商品1', price: 100, quantity: 2 },
  { id: 2, name: '商品2', price: 200, quantity: 1 }
])

function calculateTotal() {
  return items.value.reduce((sum, item) => sum + item.price * item.quantity, 0)
}

function removeItem(id) {
  const index = items.value.findIndex(item => item.id === id)
  if (index !== -1) {
    items.value.splice(index, 1)
  }
}

function checkout() {
  if (items.value.length === 0) {
    alert('购物车为空')
    return
  }
  
  // 复杂的结算逻辑...
  alert(`结算成功，总金额：${calculateTotal()}元`)
  items.value = []
}
</script>

<!-- 好的例子：使用组合式函数分离逻辑 -->
<!-- useCart.js -->
import { ref, computed } from 'vue'

export function useCart() {
  const items = ref([])
  
  const totalPrice = computed(() => 
    items.value.reduce((sum, item) => sum + item.price * item.quantity, 0)
  )
  
  const isEmpty = computed(() => items.value.length === 0)
  
  function addItem(product, quantity = 1) {
    const existingItem = items.value.find(item => item.id === product.id)
    
    if (existingItem) {
      existingItem.quantity += quantity
    } else {
      items.value.push({
        id: product.id,
        name: product.name,
        price: product.price,
        quantity
      })
    }
  }
  
  function removeItem(id) {
    const index = items.value.findIndex(item => item.id === id)
    if (index !== -1) {
      items.value.splice(index, 1)
    }
  }
  
  function updateQuantity(id, quantity) {
    const item = items.value.find(item => item.id === id)
    if (item) {
      item.quantity = Math.max(1, quantity)
    }
  }
  
  function clearCart() {
    items.value = []
  }
  
  async function checkout() {
    if (isEmpty.value) {
      throw new Error('购物车为空')
    }
    
    // 这里可以添加API调用
    // const response = await api.checkout(items.value)
    
    // 模拟API调用
    return new Promise((resolve) => {
      setTimeout(() => {
        clearCart()
        resolve({ success: true, total: totalPrice.value })
      }, 1000)
    })
  }
  
  return {
    items,
    totalPrice,
    isEmpty,
    addItem,
    removeItem,
    updateQuantity,
    clearCart,
    checkout
  }
}

<!-- CartPage.vue -->
<template>
  <div class="cart-page">
    <h2>购物车</h2>
    
    <div v-if="isEmpty" class="empty-cart">
      <p>购物车为空</p>
      <router-link to="/products" class="btn">继续购物</router-link>
    </div>
    
    <template v-else>
      <CartItemList
        :items="items"
        @remove="removeItem"
        @update-quantity="updateQuantity"
      />
      
      <div class="cart-summary">
        <p class="total-price">总价: {{ formatPrice(totalPrice) }}</p>
        <button 
          class="checkout-btn"
          :disabled="isCheckingOut"
          @click="handleCheckout"
        >
          {{ isCheckingOut ? '处理中...' : '结算' }}
        </button>
      </div>
    </template>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { useCart } from '@/composables/useCart'
import CartItemList from '@/components/CartItemList.vue'

const {
  items,
  totalPrice,
  isEmpty,
  removeItem,
  updateQuantity,
  checkout
} = useCart()

const isCheckingOut = ref(false)

function formatPrice(price) {
  return `¥${price.toFixed(2)}`
}

async function handleCheckout() {
  try {
    isCheckingOut.value = true
    const result = await checkout()
    alert(`结算成功，总金额：${formatPrice(result.total)}`)
  } catch (error) {
    alert(`结算失败: ${error.message}`)
  } finally {
    isCheckingOut.value = false
  }
}
</script>
```

#### 2. 依赖注入与依赖倒置

使用依赖注入使组件更容易测试，特别是对于外部依赖：

```vue
<!-- 不好的例子：直接导入API服务 -->
<script setup>
import { ref, onMounted } from 'vue'
import api from '@/api'

const users = ref([])
const loading = ref(true)
const error = ref(null)

onMounted(async () => {
  try {
    const response = await api.getUsers()
    users.value = response.data
  } catch (err) {
    error.value = err.message
  } finally {
    loading.value = false
  }
})
</script>

<!-- 好的例子：通过props或provide/inject注入依赖 -->
<script setup>
import { ref, onMounted, inject } from 'vue'

// 通过依赖注入获取API服务
const api = inject('api')

const props = defineProps({
  // 也可以通过props传入
  apiService: {
    type: Object,
    default: null
  }
})

const users = ref([])
const loading = ref(true)
const error = ref(null)

onMounted(async () => {
  // 使用注入的API或props中的API
  const apiService = props.apiService || api
  
  try {
    const response = await apiService.getUsers()
    users.value = response.data
  } catch (err) {
    error.value = err.message
  } finally {
    loading.value = false
  }
})
</script>
```

#### 3. 纯函数与副作用隔离

尽可能使用纯函数，将副作用隔离在特定的函数或钩子中：

```vue
<script setup>
import { ref, computed } from 'vue'

const items = ref([
  { id: 1, name: '商品1', price: 100, quantity: 2 },
  { id: 2, name: '商品2', price: 200, quantity: 1 }
])

// 纯函数：给定相同的输入，总是返回相同的输出，没有副作用
function calculateItemTotal(item) {
  return item.price * item.quantity
}

// 使用纯函数的计算属性
const totalPrice = computed(() => 
  items.value.reduce((sum, item) => sum + calculateItemTotal(item), 0)
)

// 包含副作用的函数
function saveToLocalStorage() {
  localStorage.setItem('cart', JSON.stringify(items.value))
}

// 在特定钩子或事件处理函数中调用包含副作用的函数
function handleUpdate() {
  // 业务逻辑...
  
  // 副作用隔离在特定函数中
  saveToLocalStorage()
}
</script>
```

### 编写可测试组件的实践

#### 1. 使用props和事件进行通信

通过props和事件进行组件通信，使组件更容易在隔离环境中测试：

```vue
<!-- 可测试的表单组件 -->
<template>
  <form @submit.prevent="handleSubmit">
    <div v-if="error" class="error-message">{{ error }}</div>
    
    <div class="form-group">
      <label for="username">用户名</label>
      <input
        id="username"
        v-model="form.username"
        type="text"
        :disabled="isSubmitting"
      />
    </div>
    
    <div class="form-group">
      <label for="password">密码</label>
      <input
        id="password"
        v-model="form.password"
        type="password"
        :disabled="isSubmitting"
      />
    </div>
    
    <button type="submit" :disabled="isSubmitting">
      {{ isSubmitting ? '提交中...' : '登录' }}
    </button>
  </form>
</template>

<script setup>
import { reactive, ref } from 'vue'

const props = defineProps({
  initialValues: {
    type: Object,
    default: () => ({})
  },
  isSubmitting: {
    type: Boolean,
    default: false
  },
  error: {
    type: String,
    default: ''
  }
})

const emit = defineEmits(['submit'])

const form = reactive({
  username: props.initialValues.username || '',
  password: props.initialValues.password || ''
})

function handleSubmit() {
  emit('submit', { ...form })
}
</script>
```

#### 2. 使用组合式函数组织逻辑

将复杂逻辑提取到组合式函数中，使其更容易单独测试：

```js
// useAuthentication.js
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import { useUserStore } from '@/stores/user'

export function useAuthentication() {
  const router = useRouter()
  const userStore = useUserStore()
  
  const isLoading = ref(false)
  const error = ref('')
  
  async function login(credentials) {
    isLoading.value = true
    error.value = ''
    
    try {
      await userStore.login(credentials)
      router.push('/dashboard')
      return true
    } catch (err) {
      error.value = err.message || '登录失败'
      return false
    } finally {
      isLoading.value = false
    }
  }
  
  async function logout() {
    isLoading.value = true
    error.value = ''
    
    try {
      await userStore.logout()
      router.push('/login')
      return true
    } catch (err) {
      error.value = err.message || '登出失败'
      return false
    } finally {
      isLoading.value = false
    }
  }
  
  return {
    isLoading,
    error,
    login,
    logout
  }
}
```

```vue
<!-- LoginPage.vue -->
<template>
  <div class="login-page">
    <h1>登录</h1>
    
    <LoginForm
      :is-submitting="isLoading"
      :error="error"
      @submit="handleLogin"
    />
  </div>
</template>

<script setup>
import { useAuthentication } from '@/composables/useAuthentication'
import LoginForm from '@/components/LoginForm.vue'

const { isLoading, error, login } = useAuthentication()

async function handleLogin(credentials) {
  await login(credentials)
}
</script>
```

#### 3. 使用数据属性标记元素

使用`data-testid`等属性标记元素，使测试更容易选择和交互：

```vue
<template>
  <div class="product-card" data-testid="product-card">
    <h3 data-testid="product-name">{{ product.name }}</h3>
    <p data-testid="product-price">{{ formatPrice(product.price) }}</p>
    
    <button 
      data-testid="add-to-cart-button"
      @click="addToCart"
      :disabled="!product.inStock"
    >
      加入购物车
    </button>
  </div>
</template>
```

## 性能优化原则

性能优化是组件设计中的重要考虑因素，良好的性能可以提升用户体验。

### 组件性能优化策略

#### 1. 合理的组件粒度

组件粒度过大会导致不必要的重渲染，粒度过小会增加组件通信成本：

```vue
<!-- 不好的例子：粒度过大 -->
<template>
  <div class="dashboard">
    <header>
      <h1>{{ title }}</h1>
      <div class="user-info">
        <img :src="user.avatar" alt="User avatar">
        <span>{{ user.name }}</span>
      </div>
    </header>
    
    <main>
      <div class="statistics">
        <!-- 统计数据 -->
      </div>
      
      <div class="recent-activities">
        <!-- 活动列表 -->
      </div>
      
      <div class="notifications">
        <!-- 通知列表 -->
      </div>
    </main>
  </div>
</template>

<!-- 好的例子：合理的组件粒度 -->
<template>
  <div class="dashboard">
    <DashboardHeader :title="title" :user="user" />
    
    <main>
      <StatisticsPanel :data="statistics" />
      <ActivityList :activities="recentActivities" />
      <NotificationList :notifications="notifications" />
    </main>
  </div>
</template>
```

#### 2. 使用v-memo优化列表渲染

对于大型列表，使用`v-memo`指令避免不必要的重渲染：

```vue
<template>
  <ul>
    <li
      v-for="(item, index) in items"
      :key="item.id"
      v-memo="[item.id, item.name, isSelected(item.id)]"
    >
      <div class="item" :class="{ selected: isSelected(item.id) }">
        {{ item.name }}
        <button @click="toggleSelect(item.id)">
          {{ isSelected(item.id) ? '取消选择' : '选择' }}
        </button>
      </div>
    </li>
  </ul>
</template>

<script setup>
import { ref } from 'vue'

const props = defineProps({
  items: {
    type: Array,
    required: true
  }
})

const selectedIds = ref(new Set())

function isSelected(id) {
  return selectedIds.value.has(id)
}

function toggleSelect(id) {
  if (selectedIds.value.has(id)) {
    selectedIds.value.delete(id)
  } else {
    selectedIds.value.add(id)
  }
}
</script>
```

#### 3. 使用计算属性缓存计算结果

对于复杂的计算，使用计算属性而不是方法：

```vue
<template>
  <div>
    <!-- 不好的例子：每次渲染都会重新计算 -->
    <p>总价: {{ calculateTotal() }}元</p>
    
    <!-- 好的例子：使用计算属性缓存结果 -->
    <p>总价: {{ total }}元</p>
  </div>
</template>

<script setup>
import { computed } from 'vue'

const props = defineProps({
  items: {
    type: Array,
    required: true
  }
})

// 方法：每次调用都会重新计算
function calculateTotal() {
  console.log('计算总价...')
  return props.items.reduce((sum, item) => sum + item.price * item.quantity, 0)
}

// 计算属性：只有依赖变化时才会重新计算
const total = computed(() => {
  console.log('计算总价...')
  return props.items.reduce((sum, item) => sum + item.price * item.quantity, 0)
})
</script>
```

#### 4. 使用异步组件和懒加载

对于大型组件或不是立即需要的组件，使用异步组件和懒加载：

```js
// 路由配置中使用懒加载
const routes = [
  {
    path: '/',
    component: () => import('./views/Home.vue')
  },
  {
    path: '/about',
    component: () => import('./views/About.vue')
  },
  {
    path: '/dashboard',
    component: () => import('./views/Dashboard.vue')
  }
]

// 在组件中使用异步组件
import { defineAsyncComponent } from 'vue'

const HeavyComponent = defineAsyncComponent(() => 
  import('./components/HeavyComponent.vue')
)

// 带加载和错误状态的异步组件
const ComplexComponent = defineAsyncComponent({
  loader: () => import('./components/ComplexComponent.vue'),
  loadingComponent: LoadingSpinner,
  errorComponent: ErrorDisplay,
  delay: 200,
  timeout: 10000
})
```

## 可访问性原则

可访问性（Accessibility，简称a11y）是指设计和开发产品时考虑所有用户的需求，包括残障用户。

### 设计可访问组件的原则

#### 1. 语义化HTML

使用语义化的HTML元素，而不是仅仅依赖`div`和`span`：

```vue
<!-- 不好的例子：缺乏语义 -->
<template>
  <div class="nav">
    <div class="nav-item" v-for="item in items" :key="item.id" @click="navigate(item.url)">
      {{ item.label }}
    </div>
  </div>
</template>

<!-- 好的例子：使用语义化HTML -->
<template>
  <nav aria-label="主导航">
    <ul class="nav-list">
      <li v-for="item in items" :key="item.id">
        <a :href="item.url" class="nav-link">{{ item.label }}</a>
      </li>
    </ul>
  </nav>
</template>
```

#### 2. 适当的ARIA属性

使用ARIA（Accessible Rich Internet Applications）属性增强可访问性：

```vue
<template>
  <div class="accordion">
    <div 
      v-for="(item, index) in items" 
      :key="item.id"
      class="accordion-item"
    >
      <button
        class="accordion-header"
        :id="`accordion-header-${index}`"
        :aria-expanded="activeIndex === index"
        :aria-controls="`accordion-panel-${index}`"
        @click="toggleItem(index)"
      >
        {{ item.title }}
        <span class="accordion-icon" aria-hidden="true">
          {{ activeIndex === index ? '▼' : '▶' }}
        </span>
      </button>
      
      <div
        class="accordion-panel"
        :id="`accordion-panel-${index}`"
        role="region"
        :aria-labelledby="`accordion-header-${index}`"
        v-show="activeIndex === index"
      >
        {{ item.content }}
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const props = defineProps({
  items: {
    type: Array,
    required: true
  },
  defaultIndex: {
    type: Number,
    default: -1
  }
})

const activeIndex = ref(props.defaultIndex)

function toggleItem(index) {
  activeIndex.value = activeIndex.value === index ? -1 : index
}
</script>
```

#### 3. 键盘可访问性

确保组件可以通过键盘操作：

```vue
<template>
  <div class="tabs" role="tablist">
    <button
      v-for="(tab, index) in tabs"
      :key="tab.id"
      class="tab-button"
      role="tab"
      :id="`tab-${index}`"
      :aria-selected="activeIndex === index"
      :aria-controls="`panel-${index}`"
      :tabindex="activeIndex === index ? 0 : -1"
      @click="activateTab(index)"
      @keydown="handleKeyDown"
    >
      {{ tab.label }}
    </button>
    
    <div
      v-for="(tab, index) in tabs"
      :key="`panel-${tab.id}`"
      class="tab-panel"
      role="tabpanel"
      :id="`panel-${index}`"
      :aria-labelledby="`tab-${index}`"
      v-show="activeIndex === index"
      tabindex="0"
    >
      {{ tab.content }}
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'

const props = defineProps({
  tabs: {
    type: Array,
    required: true
  },
  defaultIndex: {
    type: Number,
    default: 0
  }
})

const activeIndex = ref(props.defaultIndex)

function activateTab(index) {
  activeIndex.value = index
}

function handleKeyDown(event) {
  const tabCount = props.tabs.length
  
  switch (event.key) {
    case 'ArrowRight':
      activateTab((activeIndex.value + 1) % tabCount)
      focusActiveTab()
      break
    case 'ArrowLeft':
      activateTab((activeIndex.value - 1 + tabCount) % tabCount)
      focusActiveTab()
      break
    case 'Home':
      activateTab(0)
      focusActiveTab()
      break
    case 'End':
      activateTab(tabCount - 1)
      focusActiveTab()
      break
  }
}

function focusActiveTab() {
  // 使用nextTick确保DOM更新后再聚焦
  nextTick(() => {
    const activeTab = document.getElementById(`tab-${activeIndex.value}`)
    if (activeTab) {
      activeTab.focus()
    }
  })
}
</script>
```

## 文档和风格指南

良好的组我将继续编写Vue组件设计原则的文档内容。

```markdown:c:\project\kphub\src\frontend\vue\03-组件设计\3.1-组件设计原则.md
## 文档和风格指南

良好的组件文档和一致的风格指南对于团队协作和组件维护至关重要。

### 组件文档

为组件编写清晰的文档，包括以下内容：

#### 1. 组件描述

简要描述组件的用途和功能：

```js
/**
 * 数据表格组件
 * 
 * 用于展示和操作表格数据，支持排序、筛选、分页等功能。
 * 适用于管理界面中的数据展示场景。
 */
```

#### 2. Props文档

详细说明组件的props，包括类型、默认值和用途：

```js
/**
 * DataTable组件
 * 
 * @prop {Array} data - 表格数据数组
 * @prop {Array} columns - 表格列配置数组，每列包含{key, label, sortable, width}等属性
 * @prop {Boolean} loading - 是否显示加载状态，默认false
 * @prop {Object} pagination - 分页配置，包含{currentPage, pageSize, total}
 * @prop {String} emptyText - 数据为空时显示的文本，默认"暂无数据"
 * @prop {Boolean} bordered - 是否显示边框，默认true
 * @prop {Boolean} striped - 是否显示斑马纹，默认false
 */
```

#### 3. 事件文档

说明组件触发的事件及其参数：

```js
/**
 * @event sort - 当用户点击可排序的列头时触发
 *   @param {String} key - 排序的列键名
 *   @param {String} order - 排序方向，"asc"或"desc"
 * 
 * @event page-change - 当页码变化时触发
 *   @param {Number} page - 新的页码
 * 
 * @event selection-change - 当选择项变化时触发
 *   @param {Array} selectedRows - 当前选中的行数据
 */
```

#### 4. 插槽文档

描述组件提供的插槽：

```js
/**
 * @slot default - 自定义单元格内容，作用域参数：{row, column, index}
 * @slot header - 自定义表头，作用域参数：{column}
 * @slot empty - 自定义空数据展示
 * @slot pagination - 自定义分页组件
 */
```

#### 5. 使用示例

提供组件的基本使用示例：

```js
/**
 * 基本使用示例：
 * 
 * <DataTable
 *   :data="users"
 *   :columns="[
 *     { key: 'name', label: '姓名' },
 *     { key: 'age', label: '年龄', sortable: true },
 *     { key: 'address', label: '地址' }
 *   ]"
 *   :pagination="{
 *     currentPage: 1,
 *     pageSize: 10,
 *     total: 100
 *   }"
 *   @sort="handleSort"
 *   @page-change="handlePageChange"
 * >
 *   <template #default="{row, column}">
 *     <span v-if="column.key === 'name'" class="user-name">
 *       {{ row.name }}
 *     </span>
 *   </template>
 * </DataTable>
 */
```

### 风格指南

制定并遵循一致的组件风格指南，包括：

#### 1. 命名约定

- **组件名称**：使用PascalCase（首字母大写的驼峰式命名），如`UserProfile`、`DataTable`
- **props**：使用camelCase（小写字母开头的驼峰式命名），如`itemList`、`maxLength`
- **事件名**：使用kebab-case（短横线分隔的小写字母），如`item-click`、`page-change`
- **插槽名**：使用kebab-case，如`item-header`、`empty-state`

#### 2. 文件组织

```
components/
  ├── base/                 # 基础UI组件
  │   ├── BaseButton.vue
  │   ├── BaseInput.vue
  │   └── BaseSelect.vue
  ├── common/               # 通用业务组件
  │   ├── UserAvatar.vue
  │   ├── SearchBox.vue
  │   └── Pagination.vue
  ├── layout/               # 布局组件
  │   ├── AppHeader.vue
  │   ├── AppSidebar.vue
  │   └── PageContainer.vue
  └── features/             # 特定功能组件
      ├── user/             # 按功能分组
      │   ├── UserList.vue
      │   └── UserForm.vue
      └── product/
          ├── ProductCard.vue
          └── ProductDetail.vue
```

#### 3. 代码风格

- 使用组合式API时，按照以下顺序组织代码：
  1. 导入语句
  2. Props定义
  3. Emits定义
  4. 响应式状态
  5. 计算属性
  6. 生命周期钩子
  7. 方法定义

```vue
<script setup>
// 1. 导入
import { ref, computed, onMounted } from 'vue'
import { useRouter } from 'vue-router'
import BaseButton from '@/components/base/BaseButton.vue'

// 2. Props
const props = defineProps({
  initialValue: {
    type: Number,
    default: 0
  }
})

// 3. Emits
const emit = defineEmits(['change', 'reset'])

// 4. 响应式状态
const count = ref(props.initialValue)
const router = useRouter()

// 5. 计算属性
const doubleCount = computed(() => count.value * 2)

// 6. 生命周期钩子
onMounted(() => {
  console.log('组件已挂载')
})

// 7. 方法
function increment() {
  count.value++
  emit('change', count.value)
}

function reset() {
  count.value = props.initialValue
  emit('reset')
}
</script>
```

## 实际案例分析

让我们通过一个实际案例来综合应用上述原则，设计一个产品卡片组件系统。

### 需求分析

我们需要设计一个产品卡片组件，用于在电商网站的不同场景中展示产品信息。该组件需要：

1. 展示产品基本信息（图片、名称、价格等）
2. 支持不同的展示风格（网格、列表）
3. 支持产品操作（加入购物车、收藏）
4. 可以显示产品促销信息
5. 适应不同的屏幕尺寸

### 组件设计

根据单一职责原则，我们将组件拆分为以下几个部分：

1. **BaseProductCard**：基础产品卡片，只负责基本布局和样式
2. **ProductImage**：产品图片组件，处理图片加载、错误状态等
3. **ProductInfo**：产品信息组件，展示名称、价格等
4. **ProductActions**：产品操作组件，包含按钮等交互元素
5. **ProductBadge**：产品徽章组件，用于显示促销、折扣等信息

#### 基础产品卡片组件

```vue
<!-- BaseProductCard.vue -->
<template>
  <div 
    class="product-card"
    :class="[
      `product-card--${variant}`,
      { 'product-card--featured': featured }
    ]"
    data-testid="product-card"
  >
    <slot name="badge"></slot>
    
    <div class="product-card__image">
      <slot name="image"></slot>
    </div>
    
    <div class="product-card__content">
      <slot name="info"></slot>
      <slot name="actions"></slot>
    </div>
    
    <slot></slot>
  </div>
</template>

<script setup>
/**
 * 基础产品卡片组件
 * 
 * 提供产品卡片的基本布局和样式，通过插槽允许自定义内容。
 * 
 * @prop {String} variant - 卡片变体，可选值：'grid'、'list'，默认'grid'
 * @prop {Boolean} featured - 是否为特色产品，默认false
 * 
 * @slot badge - 产品徽章位置
 * @slot image - 产品图片位置
 * @slot info - 产品信息位置
 * @slot actions - 产品操作按钮位置
 * @slot default - 默认插槽，可用于添加任何自定义内容
 */
defineProps({
  variant: {
    type: String,
    default: 'grid',
    validator: (value) => ['grid', 'list'].includes(value)
  },
  featured: {
    type: Boolean,
    default: false
  }
})
</script>

<style scoped>
.product-card {
  border: 1px solid #eee;
  border-radius: 8px;
  overflow: hidden;
  transition: box-shadow 0.3s, transform 0.3s;
  position: relative;
}

.product-card:hover {
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
  transform: translateY(-2px);
}

.product-card--grid {
  display: flex;
  flex-direction: column;
}

.product-card--list {
  display: flex;
  flex-direction: row;
}

.product-card--list .product-card__image {
  width: 200px;
  flex-shrink: 0;
}

.product-card--list .product-card__content {
  flex: 1;
  padding: 16px;
}

.product-card--featured {
  border-color: #f0c14b;
  background-color: #fffcf3;
}

.product-card__image {
  position: relative;
  overflow: hidden;
}

.product-card__content {
  padding: 16px;
}

@media (max-width: 768px) {
  .product-card--list {
    flex-direction: column;
  }
  
  .product-card--list .product-card__image {
    width: 100%;
  }
}
</style>
```

#### 产品图片组件

```vue
<!-- ProductImage.vue -->
<template>
  <div 
    class="product-image"
    :class="{ 'product-image--loading': isLoading }"
    :style="{ aspectRatio }"
  >
    <img
      v-if="!error && !isLoading"
      :src="src"
      :alt="alt"
      @load="handleLoad"
      @error="handleError"
    />
    
    <div v-else-if="isLoading" class="product-image__placeholder">
      <slot name="loading">
        <div class="product-image__loader"></div>
      </slot>
    </div>
    
    <div v-else class="product-image__error">
      <slot name="error">
        <span>图片加载失败</span>
      </slot>
    </div>
  </div>
</template>

<script setup>
/**
 * 产品图片组件
 * 
 * 处理产品图片的加载、错误状态等。
 * 
 * @prop {String} src - 图片URL，必填
 * @prop {String} alt - 图片替代文本，默认为"产品图片"
 * @prop {String} aspectRatio - 图片宽高比，默认为"1/1"
 * 
 * @slot loading - 自定义加载中状态
 * @slot error - 自定义错误状态
 * 
 * @emits load - 图片加载成功时触发
 * @emits error - 图片加载失败时触发
 */
import { ref } from 'vue'

const props = defineProps({
  src: {
    type: String,
    required: true
  },
  alt: {
    type: String,
    default: '产品图片'
  },
  aspectRatio: {
    type: String,
    default: '1/1'
  }
})

const emit = defineEmits(['load', 'error'])

const isLoading = ref(true)
const error = ref(false)

function handleLoad(event) {
  isLoading.value = false
  emit('load', event)
}

function handleError(event) {
  isLoading.value = false
  error.value = true
  emit('error', event)
}
</script>

<style scoped>
.product-image {
  position: relative;
  width: 100%;
  background-color: #f5f5f5;
  overflow: hidden;
}

.product-image img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  display: block;
}

.product-image__placeholder,
.product-image__error {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #666;
}

.product-image__loader {
  width: 40px;
  height: 40px;
  border: 3px solid #f3f3f3;
  border-top: 3px solid #3498db;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
</style>
```

#### 产品信息组件

```vue
<!-- ProductInfo.vue -->
<template>
  <div class="product-info">
    <h3 class="product-info__name" data-testid="product-name">
      <slot name="name">{{ name }}</slot>
    </h3>
    
    <div class="product-info__price" data-testid="product-price">
      <slot name="price" :formatted-price="formattedPrice" :original-price="originalPrice">
        <span v-if="originalPrice && originalPrice > price" class="product-info__original-price">
          {{ formatPrice(originalPrice) }}
        </span>
        <span class="product-info__current-price">{{ formattedPrice }}</span>
      </slot>
    </div>
    
    <div v-if="$slots.rating || rating" class="product-info__rating">
      <slot name="rating" :rating="rating" :max-rating="5">
        <div class="stars">
          <span 
            v-for="i in 5" 
            :key="i" 
            class="star"
            :class="{ 'star--filled': i <= rating }"
          >★</span>
        </div>
        <span v-if="reviewCount" class="review-count">({{ reviewCount }})</span>
      </slot>
    </div>
    
    <p v-if="$slots.description || description" class="product-info__description">
      <slot name="description">{{ description }}</slot>
    </p>
  </div>
</template>

<script setup>
/**
 * 产品信息组件
 * 
 * 展示产品的基本信息，如名称、价格、评分等。
 * 
 * @prop {String} name - 产品名称，必填
 * @prop {Number} price - 产品价格，必填
 * @prop {Number} originalPrice - 产品原价，可选
 * @prop {Number} rating - 产品评分，范围0-5，可选
 * @prop {Number} reviewCount - 评价数量，可选
 * @prop {String} description - 产品描述，可选
 * @prop {String} currency - 货币符号，默认"¥"
 * 
 * @slot name - 自定义产品名称
 * @slot price - 自定义价格展示，提供formattedPrice和originalPrice作用域变量
 * @slot rating - 自定义评分展示，提供rating和maxRating作用域变量
 * @slot description - 自定义产品描述
 */
import { computed } from 'vue'

const props = defineProps({
  name: {
    type: String,
    required: true
  },
  price: {
    type: Number,
    required: true
  },
  originalPrice: {
    type: Number,
    default: null
  },
  rating: {
    type: Number,
    default: null,
    validator: (value) => value === null || (value >= 0 && value <= 5)
  },
  reviewCount: {
    type: Number,
    default: null
  },
  description: {
    type: String,
    default: ''
  },
  currency: {
    type: String,
    default: '¥'
  }
})

const formattedPrice = computed(() => formatPrice(props.price))

function formatPrice(price) {
  return `${props.currency}${price.toFixed(2)}`
}
</script>

<style scoped>
.product-info {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.product-info__name {
  margin: 0;
  font-size: 1rem;
  font-weight: 500;
  color: #333;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.product-info__price {
  display: flex;
  align-items: center;
  gap: 8px;
}

.product-info__current-price {
  font-weight: bold;
  color: #e53935;
}

.product-info__original-price {
  color: #999;
  text-decoration: line-through;
  font-size: 0.9em;
}

.product-info__rating {
  display: flex;
  align-items: center;
  gap: 4px;
}

.stars {
  display: flex;
}

.star {
  color: #ddd;
}

.star--filled {
  color: #ffc107;
}

.review-count {
  color: #666;
  font-size: 0.9em;
}

.product-info__description {
  margin: 0;
  color: #666;
  font-size: 0.9em;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
}
</style>
```

#### 产品操作组件

```vue
<!-- ProductActions.vue -->
<template>
  <div class="product-actions">
    <slot 
      name="default"
      :add-to-cart="addToCart"
      :toggle-favorite="toggleFavorite"
      :is-favorite="isFavorite"
      :is-in-cart="isInCart"
      :is-in-stock="inStock"
    >
      <button
        class="product-actions__cart-btn"
        :class="{ 'product-actions__cart-btn--in-cart': isInCart }"
        :disabled="!inStock || isAddingToCart"
        @click="addToCart"
        data-testid="add-to-cart-button"
      >
        <span v-if="isAddingToCart">添加中...</span>
        <span v-else-if="isInCart">已添加</span>
        <span v-else-if="!inStock">缺货</span>
        <span v-else>加入购物车</span>
      </button>
      
      <button
        class="product-actions__favorite-btn"
        :class="{ 'product-actions__favorite-btn--active': isFavorite }"
        @click="toggleFavorite"
        data-testid="favorite-button"
      >
        <span class="favorite-icon">♥</span>
      </button>
    </slot>
  </div>
</template>

<script setup>
/**
 * 产品操作组件
 * 
 * 提供产品相关的操作按钮，如加入购物车、收藏等。
 * 
 * @prop {Boolean} inStock - 产品是否有库存，默认true
 * @prop {Boolean} isFavorite - 产品是否已收藏，默认false
 * @prop {Boolean} isInCart - 产品是否已在购物车中，默认false
 * 
 * @slot default - 自定义操作按钮，提供addToCart、toggleFavorite、isFavorite、isInCart、isInStock作用域变量
 * 
 * @emits add-to-cart - 点击加入购物车按钮时触发
 * @emits toggle-favorite - 点击收藏按钮时触发，参数为新的收藏状态
 */
import { ref } from 'vue'

const props = defineProps({
  inStock: {
    type: Boolean,
    default: true
  },
  isFavorite: {
    type: Boolean,
    default: false
  },
  isInCart: {
    type: Boolean,
    default: false
  }
})

const emit = defineEmits(['add-to-cart', 'toggle-favorite'])

const isAddingToCart = ref(false)

async function addToCart() {
  if (!props.inStock || props.isInCart || isAddingToCart.value) return
  
  isAddingToCart.value = true
  
  try {
    await emit('add-to-cart')
  } finally {
    isAddingToCart.value = false
  }
}

function toggleFavorite() {
  emit('toggle-favorite', !props.isFavorite)
}
</script>

<style scoped>
.product-actions {
  display: flex;
  gap: 8px;
  margin-top: 12px;
}

.product-actions__cart-btn {
  flex: 1;
  padding: 8px 16px;
  background-color: #4caf50;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  transition: background-color 0.3s;
}

.product-actions__cart-btn:hover:not(:disabled) {
  background-color: #388e3c;
}

.product-actions__cart-btn:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

.product-actions__cart-btn--in-cart {
  background-color: #2196f3;
}

.product-actions__favorite-btn {
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: white;
  border: 1px solid #ddd;
  border-radius: 4px;
  cursor: pointer;
  transition: all 0.3s;
}

.product-actions__favorite-btn:hover {
  border-color: #ff5252;
}

.product-actions__favorite-btn--active {
  color: #ff5252;
  border-color: #ff5252;
}

.favorite-icon {
  font-size: 1.2rem;
}
</style>
```

#### 产品徽章组件

```vue
<!-- ProductBadge.vue -->
<template>
  <div 
    class="product-badge"
    :class="`product-badge--${type}`"
    :style="{ backgroundColor: customColor }"
  >
    <slot>{{ text }}</slot>
  </div>
</template>

<script setup>
/**
 * 产品徽章组件
 * 
 * 用于在产品卡片上显示促销、折扣等信息。
 * 
 * @prop {String} type - 徽章类型，可选值：'sale'、'new'、'discount'、'custom'，默认'sale'
 * @prop {String} text - 徽章文本，默认根据type自动设置
 * @prop {String} customColor - 自定义徽章颜色，仅在type为'custom'时有效
 * 
 * @slot default - 自定义徽章内容
 */
import { computed } from 'vue'

const props = defineProps({
  type: {
    type: String,
    default: 'sale',
    validator: (value) => ['sale', 'new', 'discount', 'custom'].includes(value)
  },
  text: {
    type: String,
    default: null
  },
  customColor: {
    type: String,
    default: null
  }
})

const defaultText = computed(() => {
  switch (props.type) {
    case 'sale': return '促销';
    case 'new': return '新品';
    case 'discount': return '折扣';
    default: return '';
  }
})

const text = computed(() => props.text || defaultText.value)
</script>

<style scoped>
.product-badge {
  position: absolute;
  top: 10px;
  left: 10px;
  z-index: 1;
  padding: 4px 8px;
  font-size: 0.8rem;
  font-weight: bold;
  color: white;
  border-radius: 4px;
}

.product-badge--sale {
  background-color: #e53935;
}

.product-badge--new {
  background-color: #2196f3;
}

.product-badge--discount {
  background-color: #ff9800;
}

.product-badge--custom {
  background-color: var(--custom-color, #9c27b0);
}
</style>
```

#### 组合使用

现在，我们可以组合这些组件来创建完整的产品卡片：

```vue
<!-- ProductCard.vue -->
<template>
  <BaseProductCard
    :variant="variant"
    :featured="product.featured"
  >
    <template #badge v-if="product.badge">
      <ProductBadge
        :type="product.badge.type"
        :text="product.badge.text"
      />
    </template>
    
    <template #image>
      <ProductImage
        :src="product.image"
        :alt="product.name"
        @click="$emit('image-click', product)"
      />
    </template>
    
    <template #info>
      <ProductInfo
        :name="product.name"
        :price="product.price"
        :original-price="product.originalPrice"
        :rating="product.rating"
        :review-count="product.reviewCount"
        :description="variant === 'list' ? product.description : ''"
      />
    </template>
    
    <template #actions>
      <ProductActions
        :in-stock="product.inStock"
        :is-favorite="isFavorite"
        :is-in-cart="isInCart"
        @add-to-cart="handleAddToCart"
        @toggle-favorite="handleToggleFavorite"
      />
    </template>
  </BaseProductCard>
</template>

<script setup>
/**
 * 产品卡片组件
 * 
 * 完整的产品卡片，组合了基础卡片、图片、信息、操作和徽章组件。
 * 
 * @prop {Object} product - 产品对象，必填，包含id, name, price, image等属性
 * @prop {String} variant - 卡片变体，可选值：'grid'、'list'，默认'grid'
 * @prop {Boolean} isFavorite - 产品是否已收藏，默认false
 * @prop {Boolean} isInCart - 产品是否已在购物车中，默认false
 * 
 * @emits add-to-cart - 点击加入购物车按钮时触发，参数为产品对象
 * @emits toggle-favorite - 点击收藏按钮时触发，参数为{product, isFavorite}
 * @emits image-click - 点击产品图片时触发，参数为产品对象
 */
import BaseProductCard from './BaseProductCard.vue'
import ProductImage from './ProductImage.vue'
import ProductInfo from './ProductInfo.vue'
import ProductActions from './ProductActions.vue'
import ProductBadge from './ProductBadge.vue'

const props = defineProps({
  product: {
    type: Object,
    required: true
  },
  variant: {
    type: String,
    default: 'grid',
    validator: (value) => ['grid', 'list'].includes(value)
  },
  isFavorite: {
    type: Boolean,
    default: false
  },
  isInCart: {
    type: Boolean,
    default: false
  }
})

const emit = defineEmits(['add-to-cart', 'toggle-favorite', 'image-click'])

function handleAddToCart() {
  emit('add-to-cart', props.product)
}

function handleToggleFavorite(isFavorite) {
  emit('toggle-favorite', {
    product: props.product,
    isFavorite
  })
}
</script>
```

### 使用示例

```vue
<template>
  <div class="product-grid">
    <ProductCard
      v-for="product in products"
      :key="product.id"
      :product="product"
      :is-favorite="isProductFavorite(product.id)"
      :is-in-cart="isProductInCart(product.id)"
      @add-to-cart="addToCart"
      @toggle-favorite="toggleFavorite"
      @image-click="navigateToProduct"
    />
  </div>
</template>

<script setup>我将继续编写Vue组件设计原则的文档内容。

```markdown:c:\project\kphub\src\frontend\vue\03-组件设计\3.1-组件设计原则.md
<script setup>
import { useProductStore } from '@/stores/product'
import { useCartStore } from '@/stores/cart'
import { useFavoriteStore } from '@/stores/favorite'
import { useRouter } from 'vue-router'
import ProductCard from '@/components/product/ProductCard.vue'

const productStore = useProductStore()
const cartStore = useCartStore()
const favoriteStore = useFavoriteStore()
const router = useRouter()

const products = productStore.products

function isProductFavorite(productId) {
  return favoriteStore.isFavorite(productId)
}

function isProductInCart(productId) {
  return cartStore.isInCart(productId)
}

function addToCart(product) {
  return cartStore.addItem(product)
}

function toggleFavorite({ product, isFavorite }) {
  if (isFavorite) {
    favoriteStore.addFavorite(product)
  } else {
    favoriteStore.removeFavorite(product.id)
  }
}

function navigateToProduct(product) {
  router.push(`/products/${product.id}`)
}
</script>

<style scoped>
.product-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 20px;
}

@media (max-width: 768px) {
  .product-grid {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 480px) {
  .product-grid {
    grid-template-columns: 1fr;
  }
}
</style>
```

## 总结

本文详细介绍了Vue组件设计的核心原则和最佳实践，包括：

1. **单一职责原则**：每个组件应该只专注于做好一件事，通过按功能拆分组件和使用组合式API分离关注点来实现。

2. **接口设计原则**：设计良好的props、事件和插槽接口，使组件更易于使用和理解。

3. **状态管理原则**：合理管理组件状态，区分本地状态和共享状态，使用计算属性派生状态，保持状态变更的可预测性。

4. **可复用性原则**：通过关注点分离、组合优于继承、配置驱动设计等方式，提高组件的可复用性。

5. **可测试性原则**：设计可测试的组件，包括关注点分离、依赖注入、纯函数与副作用隔离等实践。

6. **性能优化原则**：通过合理的组件粒度、v-memo优化列表渲染、使用计算属性缓存结果、异步组件和懒加载等方式，提高组件性能。

7. **可访问性原则**：使用语义化HTML、ARIA属性、确保键盘可访问性等，使组件对所有用户都友好。

8. **文档和风格指南**：编写清晰的组件文档，遵循一致的命名约定和代码组织方式。

通过实际案例分析，我们展示了如何将这些原则应用到实际组件设计中，创建一个模块化、可复用、可维护的产品卡片组件系统。

遵循这些组件设计原则，可以帮助我们构建出高质量的Vue应用，提高开发效率，降低维护成本，并为用户提供更好的体验。

## 参考资料

1. [Vue.js官方风格指南](https://cn.vuejs.org/style-guide/)
2. [Vue组合式API文档](https://cn.vuejs.org/guide/extras/composition-api-faq.html)
3. [可复用性与组合](https://cn.vuejs.org/guide/reusability/composables.html)
4. [Vue测试指南](https://cn.vuejs.org/guide/scaling-up/testing.html)
5. [Web可访问性指南(WCAG)](https://www.w3.org/WAI/standards-guidelines/wcag/)
6. [SOLID原则](https://en.wikipedia.org/wiki/SOLID)
7. [组件驱动开发(CDD)](https://www.componentdriven.org/)
```

这份文档详细介绍了Vue组件设计的核心原则和最佳实践，通过理论讲解和实际案例相结合的方式，帮助开发者理解如何设计高质量的Vue组件。文档涵盖了从基础概念到高级技巧的全面内容，适合不同级别的开发者阅读和参考。
---
title: Java发展历史与特性实战篇
icon: practice
order: 2
---

# Java发展历史与特性实战篇

## Java各版本特性实战应用

### Java 8 Lambda表达式与Stream API实战

Java 8引入的Lambda表达式和Stream API是Java语言发展的重要里程碑，它们彻底改变了Java开发者处理集合和编写函数式代码的方式。

#### Lambda表达式基础与应用

Lambda表达式是一种匿名函数，它提供了一种简洁的方式来表示可传递的代码块。

##### 基本语法

```java
// 无参数Lambda表达式
Runnable r1 = () -> System.out.println("Hello World");

// 单参数Lambda表达式（参数类型可省略）
Consumer<String> c1 = (name) -> System.out.println("Hello, " + name);
Consumer<String> c2 = name -> System.out.println("Hello, " + name); // 单参数可省略括号

// 多参数Lambda表达式
BiFunction<Integer, Integer, Integer> add = (a, b) -> a + b;

// 带代码块的Lambda表达式
Comparator<String> c = (s1, s2) -> {
    System.out.println("比较两个字符串");
    return s1.compareTo(s2);
};
```

##### 函数式接口应用

Lambda表达式需要配合函数式接口使用，Java 8在`java.util.function`包中提供了多种函数式接口。

```java
import java.util.function.*;

public class FunctionalInterfaceExample {
    public static void main(String[] args) {
        // Predicate: 接收一个参数，返回布尔值
        Predicate<String> isEmpty = s -> s.isEmpty();
        System.out.println(isEmpty.test("")); // true
        
        // Function: 接收一个参数，返回一个结果
        Function<String, Integer> toLength = s -> s.length();
        System.out.println(toLength.apply("Java")); // 4
        
        // Consumer: 接收一个参数，无返回值
        Consumer<String> printer = s -> System.out.println(s);
        printer.accept("Hello Lambda"); // 输出: Hello Lambda
        
        // Supplier: 无参数，返回一个结果
        Supplier<Double> random = () -> Math.random();
        System.out.println(random.get()); // 随机数
        
        // BiFunction: 接收两个参数，返回一个结果
        BiFunction<Integer, Integer, String> format = 
            (a, b) -> String.format("%d + %d = %d", a, b, a + b);
        System.out.println(format.apply(2, 3)); // 2 + 3 = 5
    }
}
```

##### 方法引用实战

方法引用是Lambda表达式的一种简化形式，可以直接引用已有的方法。

```java
import java.util.*;
import java.util.function.*;

public class MethodReferenceExample {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
        
        // 静态方法引用
        names.forEach(System.out::println);
        
        // 实例方法引用（特定对象）
        StringBuilder sb = new StringBuilder();
        Consumer<String> appender = sb::append;
        names.forEach(appender);
        System.out.println(sb.toString()); // AliceBobCharlie
        
        // 实例方法引用（任意对象）
        names.sort(String::compareToIgnoreCase);
        
        // 构造方法引用
        Function<String, Integer> constructor = Integer::new;
        Integer value = constructor.apply("123");
        System.out.println(value + 1); // 124
        
        // 数组构造方法引用
        Function<Integer, String[]> arrayCreator = String[]::new;
        String[] array = arrayCreator.apply(3);
        array[0] = "Java";
        System.out.println(Arrays.toString(array)); // [Java, null, null]
    }
}
```

#### Stream API实战应用

Stream API提供了一种声明式的方式来处理集合数据，支持顺序和并行操作。

##### 创建Stream

```java
import java.util.*;
import java.util.stream.*;

public class StreamCreationExample {
    public static void main(String[] args) {
        // 从集合创建
        List<String> list = Arrays.asList("a", "b", "c");
        Stream<String> streamFromList = list.stream();
        
        // 从数组创建
        String[] array = {"a", "b", "c"};
        Stream<String> streamFromArray = Arrays.stream(array);
        
        // 使用Stream.of
        Stream<String> streamFromValues = Stream.of("a", "b", "c");
        
        // 创建无限流
        Stream<Integer> infiniteStream = Stream.iterate(0, n -> n + 2);
        infiniteStream.limit(5).forEach(System.out::println); // 0 2 4 6 8
        
        // 创建随机数流
        Stream<Double> randomStream = Stream.generate(Math::random);
        randomStream.limit(3).forEach(System.out::println);
    }
}
```

##### 中间操作

Stream API提供了多种中间操作，用于转换和过滤数据。

```java
import java.util.*;
import java.util.stream.*;

public class StreamIntermediateOpsExample {
    public static void main(String[] args) {
        List<String> words = Arrays.asList("Java", "Stream", "API", "Lambda", "Collection", "Framework");
        
        // filter: 过滤元素
        List<String> longWords = words.stream()
            .filter(w -> w.length() > 5)
            .collect(Collectors.toList());
        System.out.println("长单词: " + longWords); // [Stream, Lambda, Collection, Framework]
        
        // map: 转换元素
        List<Integer> wordLengths = words.stream()
            .map(String::length)
            .collect(Collectors.toList());
        System.out.println("单词长度: " + wordLengths); // [4, 6, 3, 6, 10, 9]
        
        // flatMap: 扁平化嵌套集合
        List<List<Integer>> nestedList = Arrays.asList(
            Arrays.asList(1, 2, 3),
            Arrays.asList(4, 5, 6),
            Arrays.asList(7, 8, 9)
        );
        List<Integer> flatList = nestedList.stream()
            .flatMap(Collection::stream)
            .collect(Collectors.toList());
        System.out.println("扁平化列表: " + flatList); // [1, 2, 3, 4, 5, 6, 7, 8, 9]
        
        // distinct: 去重
        List<Integer> numbers = Arrays.asList(1, 2, 2, 3, 3, 3, 4, 4, 4, 4);
        List<Integer> distinctNumbers = numbers.stream()
            .distinct()
            .collect(Collectors.toList());
        System.out.println("去重后: " + distinctNumbers); // [1, 2, 3, 4]
        
        // sorted: 排序
        List<String> sortedWords = words.stream()
            .sorted(Comparator.comparing(String::length).reversed())
            .collect(Collectors.toList());
        System.out.println("按长度降序: " + sortedWords); // [Collection, Framework, Stream, Lambda, Java, API]
        
        // peek: 查看元素（常用于调试）
        List<String> result = words.stream()
            .filter(w -> w.length() > 4)
            .peek(w -> System.out.println("过滤后: " + w))
            .map(String::toUpperCase)
            .peek(w -> System.out.println("转换后: " + w))
            .collect(Collectors.toList());
        System.out.println("最终结果: " + result);
    }
}
```

##### 终端操作

终端操作会触发Stream的执行并产生结果。

```java
import java.util.*;
import java.util.stream.*;
import static java.util.stream.Collectors.*;

public class StreamTerminalOpsExample {
    static class Person {
        private String name;
        private int age;
        private String department;
        
        public Person(String name, int age, String department) {
            this.name = name;
            this.age = age;
            this.department = department;
        }
        
        public String getName() { return name; }
        public int getAge() { return age; }
        public String getDepartment() { return department; }
        
        @Override
        public String toString() {
            return name + "(" + age + ")";
        }
    }
    
    public static void main(String[] args) {
        List<Person> people = Arrays.asList(
            new Person("张三", 28, "研发"),
            new Person("李四", 32, "市场"),
            new Person("王五", 45, "研发"),
            new Person("赵六", 36, "人事"),
            new Person("钱七", 27, "市场"),
            new Person("孙八", 52, "研发")
        );
        
        // forEach: 遍历元素
        System.out.println("所有人员:");
        people.stream().forEach(p -> System.out.println(p.getName() + ", " + p.getAge() + "岁"));
        
        // count: 计数
        long count = people.stream().filter(p -> p.getAge() > 30).count();
        System.out.println("30岁以上人数: " + count); // 4
        
        // collect: 收集结果
        // 转换为List
        List<String> names = people.stream()
            .map(Person::getName)
            .collect(toList());
        System.out.println("所有姓名: " + names);
        
        // 转换为Set
        Set<String> departments = people.stream()
            .map(Person::getDepartment)
            .collect(toSet());
        System.out.println("所有部门: " + departments);
        
        // 转换为Map
        Map<String, Integer> nameToAge = people.stream()
            .collect(toMap(Person::getName, Person::getAge));
        System.out.println("姓名年龄映射: " + nameToAge);
        
        // 分组
        Map<String, List<Person>> byDepartment = people.stream()
            .collect(groupingBy(Person::getDepartment));
        System.out.println("按部门分组: " + byDepartment);
        
        // 分区
        Map<Boolean, List<Person>> partitioned = people.stream()
            .collect(partitioningBy(p -> p.getAge() > 40));
        System.out.println("40岁以上: " + partitioned.get(true));
        System.out.println("40岁以下: " + partitioned.get(false));
        
        // 统计
        IntSummaryStatistics ageStats = people.stream()
            .collect(summarizingInt(Person::getAge));
        System.out.println("年龄统计: " + ageStats);
        
        // 连接字符串
        String allNames = people.stream()
            .map(Person::getName)
            .collect(joining(", ", "员工[", "]"));
        System.out.println(allNames);
        
        // reduce: 归约操作
        Optional<Person> oldest = people.stream()
            .reduce((p1, p2) -> p1.getAge() > p2.getAge() ? p1 : p2);
        oldest.ifPresent(p -> System.out.println("年龄最大: " + p));
        
        // 求和
        int totalAge = people.stream()
            .mapToInt(Person::getAge)
            .sum();
        System.out.println("年龄总和: " + totalAge);
        
        // anyMatch, allMatch, noneMatch
        boolean anyOver50 = people.stream().anyMatch(p -> p.getAge() > 50);
        boolean allAdults = people.stream().allMatch(p -> p.getAge() >= 18);
        boolean noTeenagers = people.stream().noneMatch(p -> p.getAge() < 20);
        System.out.println("有人超过50岁: " + anyOver50);
        System.out.println("全部成年: " + allAdults);
        System.out.println("没有青少年: " + noTeenagers);
        
        // findFirst, findAny
        Optional<Person> first = people.stream()
            .filter(p -> p.getDepartment().equals("研发"))
            .findFirst();
        first.ifPresent(p -> System.out.println("第一个研发人员: " + p));
    }
}
```

##### 并行Stream实战

并行Stream可以利用多核处理器提高处理大数据集的性能。

```java
import java.util.*;
import java.util.concurrent.TimeUnit;
import java.util.stream.*;

public class ParallelStreamExample {
    public static void main(String[] args) {
        // 创建大数据集
        List<Integer> numbers = new ArrayList<>();
        for (int i = 1; i <= 10_000_000; i++) {
            numbers.add(i);
        }
        
        // 顺序处理
        long start = System.nanoTime();
        long sequentialSum = numbers.stream()
            .filter(n -> n % 2 == 0)
            .mapToLong(Integer::longValue)
            .sum();
        long end = System.nanoTime();
        System.out.println("顺序处理结果: " + sequentialSum);
        System.out.println("顺序处理时间: " + TimeUnit.NANOSECONDS.toMillis(end - start) + " ms");
        
        // 并行处理
        start = System.nanoTime();
        long parallelSum = numbers.parallelStream()
            .filter(n -> n % 2 == 0)
            .mapToLong(Integer::longValue)
            .sum();
        end = System.nanoTime();
        System.out.println("并行处理结果: " + parallelSum);
        System.out.println("并行处理时间: " + TimeUnit.NANOSECONDS.toMillis(end - start) + " ms");
        
        // 注意：并行Stream的陷阱
        List<String> words = Arrays.asList("Java", "Stream", "API", "Parallel", "Processing");
        
        // 使用可变归约操作可能导致问题
        StringBuilder sequentialResult = words.stream()
            .collect(StringBuilder::new, StringBuilder::append, StringBuilder::append);
        System.out.println("顺序收集: " + sequentialResult);
        
        // 并行执行可能导致顺序问题
        StringBuilder parallelResult = words.parallelStream()
            .collect(StringBuilder::new, StringBuilder::append, StringBuilder::append);
        System.out.println("并行收集: " + parallelResult); // 顺序可能混乱
        
        // 正确的并行收集方式
        String correctResult = words.parallelStream()
            .collect(Collectors.joining(" "));
        System.out.println("正确的并行收集: " + correctResult);
    }
}
```

#### 实际业务场景应用

##### 数据过滤与转换

```java
import java.util.*;
import java.util.stream.*;
import java.time.LocalDate;

public class BusinessDataProcessingExample {
    static class Order {
        private long id;
        private LocalDate orderDate;
        private double amount;
        private String customerName;
        private String status;
        
        public Order(long id, LocalDate orderDate, double amount, String customerName, String status) {
            this.id = id;
            this.orderDate = orderDate;
            this.amount = amount;
            this.customerName = customerName;
            this.status = status;
        }
        
        public long getId() { return id; }
        public LocalDate getOrderDate() { return orderDate; }
        public double getAmount() { return amount; }
        public String getCustomerName() { return customerName; }
        public String getStatus() { return status; }
        
        @Override
        public String toString() {
            return "Order{" + id + ", " + amount + ", " + status + "}";
        }
    }
    
    public static void main(String[] args) {
        List<Order> orders = Arrays.asList(
            new Order(1001, LocalDate.of(2023, 1, 15), 199.99, "张三", "COMPLETED"),
            new Order(1002, LocalDate.of(2023, 1, 16), 99.99, "李四", "PENDING"),
            new Order(1003, LocalDate.of(2023, 1, 16), 149.99, "王五", "COMPLETED"),
            new Order(1004, LocalDate.of(2023, 1, 17), 299.99, "赵六", "CANCELLED"),
            new Order(1005, LocalDate.of(2023, 1, 18), 399.99, "张三", "COMPLETED"),
            new Order(1006, LocalDate.of(2023, 1, 19), 599.99, "李四", "PENDING")
        );
        
        // 1. 查找所有已完成的订单
        List<Order> completedOrders = orders.stream()
            .filter(order -> "COMPLETED".equals(order.getStatus()))
            .collect(Collectors.toList());
        System.out.println("已完成订单: " + completedOrders);
        
        // 2. 计算所有已完成订单的总金额
        double totalCompletedAmount = orders.stream()
            .filter(order -> "COMPLETED".equals(order.getStatus()))
            .mapToDouble(Order::getAmount)
            .sum();
        System.out.println("已完成订单总金额: " + totalCompletedAmount);
        
        // 3. 按客户名分组，统计每个客户的订单数量
        Map<String, Long> orderCountByCustomer = orders.stream()
            .collect(Collectors.groupingBy(
                Order::getCustomerName,
                Collectors.counting()
            ));
        System.out.println("客户订单数量: " + orderCountByCustomer);
        
        // 4. 查找金额最高的订单
        Optional<Order> maxAmountOrder = orders.stream()
            .max(Comparator.comparing(Order::getAmount));
        maxAmountOrder.ifPresent(order -> 
            System.out.println("金额最高订单: " + order));
        
        // 5. 按日期分组，计算每天的订单总金额
        Map<LocalDate, Double> totalAmountByDate = orders.stream()
            .collect(Collectors.groupingBy(
                Order::getOrderDate,
                Collectors.summingDouble(Order::getAmount)
            ));
        System.out.println("每日订单金额: " + totalAmountByDate);
        
        // 6. 生成订单报表
        String report = orders.stream()
            .map(order -> String.format("订单ID: %d, 客户: %s, 金额: %.2f, 状态: %s",
                order.getId(), order.getCustomerName(), order.getAmount(), order.getStatus()))
            .collect(Collectors.joining("\n"));
        System.out.println("订单报表:\n" + report);
    }
}
```

##### 复杂业务逻辑处理

```java
import java.util.*;
import java.util.stream.*;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;

public class ComplexBusinessLogicExample {
    static class Product {
        private String id;
        private String name;
        private String category;
        private double price;
        private int stock;
        
        public Product(String id, String name, String category, double price, int stock) {
            this.id = id;
            this.name = name;
            this.category = category;
            this.price = price;
            this.stock = stock;
        }
        
        public String getId() { return id; }
        public String getName() { return name; }
        public String getCategory() { return category; }
        public double getPrice() { return price; }
        public int getStock() { return stock; }
    }
    
    static class Order {
        private String id;
        private String customerId;
        private LocalDate orderDate;
        private List<OrderItem> items;
        private String status;
        
        public Order(String id, String customerId, LocalDate orderDate, List<OrderItem> items, String status) {
            this.id = id;
            this.customerId = customerId;
            this.orderDate = orderDate;
            this.items = items;
            this.status = status;
        }
        
        public String getId() { return id; }
        public String getCustomerId() { return customerId; }
        public LocalDate getOrderDate() { return orderDate; }
        public List<OrderItem> getItems() { return items; }
        public String getStatus() { return status; }
        
        public double getTotalAmount() {
            return items.stream()
                .mapToDouble(item -> item.getPrice() * item.getQuantity())
                .sum();
        }
    }
    
    static class OrderItem {
        private String productId;
        private int quantity;
        private double price;
        
        public OrderItem(String productId, int quantity, double price) {
            this.productId = productId;
            this.quantity = quantity;
            this.price = price;
        }
        
        public String getProductId() { return productId; }
        public int getQuantity() { return quantity; }
        public double getPrice() { return price; }
    }
    
    static class Customer {
        private String id;
        private String name;
        private String tier; // "STANDARD", "PREMIUM", "VIP"
        private LocalDate registrationDate;
        
        public Customer(String id, String name, String tier, LocalDate registrationDate) {
            this.id = id;
            this.name = name;
            this.tier = tier;
            this.registrationDate = registrationDate;
        }
        
        public String getId() { return id; }
        public String getName() { return name; }
        public String getTier() { return tier; }
        public LocalDate getRegistrationDate() { return registrationDate; }
    }
    
    public static void main(String[] args) {
        // 创建产品数据
        List<Product> products = Arrays.asList(
            new Product("P1", "笔记本电脑", "电子产品", 5999.99, 10),
            new Product("P2", "智能手机", "电子产品", 2999.99, 20),
            new Product("P3", "耳机", "配件", 299.99, 50),
            new Product("P4", "鼠标", "配件", 99.99, 100),
            new Product("P5", "键盘", "配件", 199.99, 30),
            new Product("P6", "显示器", "电子产品", 1499.99, 15)
        );
        
        // 创建客户数据
        List<Customer> customers = Arrays.asList(
            new Customer("C1", "张三", "VIP", LocalDate.of(2020, 1, 15)),
            new Customer("C2", "李四", "STANDARD", LocalDate.of(2021, 5, 20)),
            new Customer("C3", "王五", "PREMIUM", LocalDate.of(2019, 11, 10)),
            new Customer("C4", "赵六", "STANDARD", LocalDate.of(2022, 3, 5))
        );
        
        // 创建订单数据
        List<Order> orders = Arrays.asList(
            new Order("O1", "C1", LocalDate.of(2023, 1, 10), 
                Arrays.asList(
                    new OrderItem("P1", 1, 5999.99),
                    new OrderItem("P3", 2, 299.99)
                ), 
                "COMPLETED"),
            new Order("O2", "C2", LocalDate.of(2023, 1, 15), 
                Arrays.asList(
                    new OrderItem("P2", 1, 2999.99)
                ), 
                "COMPLETED"),
            new Order("O3", "C3", LocalDate.of(2023, 1, 20), 
                Arrays.asList(
                    new OrderItem("P4", 2, 99.99),
                    new OrderItem("P5", 1, 199.99)
                ), 
                "PENDING"),
            new Order("O4", "C1", LocalDate.of(2023, 1, 25), 
                Arrays.asList(
                    new OrderItem("P6", 1, 1499.99),
                    new OrderItem("P3", 1, 299.99)
                ), 
                "COMPLETED"),
            new Order("O5", "C4", LocalDate.of(2023, 2, 5), 
                Arrays.asList(
                    new OrderItem("P2", 1, 2999.99),
                    new OrderItem("P4", 1, 99.99)
                ), 
                "CANCELLED")
        );
        
        // 1. 查找库存少于20的产品，并按价格排序
        List<Product> lowStockProducts = products.stream()
            .filter(p -> p.getStock() < 20)
            .sorted(Comparator.comparing(Product::getPrice))
            .collect(Collectors.toList());
        System.out.println("库存不足产品: " + lowStockProducts.stream()
            .map(p -> p.getName() + "(" + p.getStock() + ")")
            .collect(Collectors.joining(", ")));
        
        // 2. 计算每个类别的平均价格
        Map<String, Double> avgPriceByCategory = products.stream()
            .collect(Collectors.groupingBy(
                Product::getCategory,
                Collectors.averagingDouble(Product::getPrice)
            ));
        System.out.println("类别平均价格: " + avgPriceByCategory);
        
        // 3. 查找VIP客户的所有订单
        Map<String, Customer> customerMap = customers.stream()
            .collect(Collectors.toMap(Customer::getId, c -> c));
        
        List<Order> vipOrders = orders.stream()
            .filter(o -> {
                Customer customer = customerMap.get(o.getCustomerId());
                return customer != null && "VIP".equals(customer.getTier());
            })
            .collect(Collectors.toList());
        
        System.out.println("VIP客户订单数: " + vipOrders.size());
        
        // 4. 计算每个客户的总消费金额
        Map<String, Double> totalSpentByCustomer = orders.stream()
            .filter(o -> "COMPLETED".equals(o.getStatus()))
            .collect(Collectors.groupingBy(
                Order::getCustomerId,
                Collectors.summingDouble(Order::getTotalAmount)
            ));
        
        // 添加客户名称
        totalSpentByCustomer.forEach((customerId, amount) -> {
            Customer customer = customerMap.get(customerId);
            if (customer != null) {
                System.out.println(customer.getName() + " 总消费: " + amount);
            }
        });
        
        // 5. 查找最受欢迎的产品（被订购最多次）
        Map<String, Long> productOrderCount = orders.stream()
            .filter(o -> !"CANCELLED".equals(o.getStatus()))
            .flatMap(o -> o.getItems().stream())
            .collect(Collectors.groupingBy(
                OrderItem::getProductId,
                Collectors.counting()
            ));
        
        Optional<Map.Entry<String, Long>> mostPopularProduct = productOrderCount.entrySet().stream()
            .max(Map.Entry.comparingByValue());
        
        mostPopularProduct.ifPresent(entry -> {
            String productId = entry.getKey();
            products.stream()
                .filter(p -> p.getId().equals(productId))
                .findFirst()
                .ifPresent(p -> System.out.println("最受欢迎产品: " + p.getName() + 
                                                  ", 订购次数: " + entry.getValue()));
        });
        
        // 6. 计算最近30天内的订单总金额
        LocalDate now = LocalDate.of(2023, 2, 10);
        LocalDate thirtyDaysAgo = now.minus(30, ChronoUnit.DAYS);
        
        double recentOrdersAmount = orders.stream()
            .filter(o -> !o.getOrderDate().isBefore(thirtyDaysAgo) && 
                         !o.getOrderDate().isAfter(now) &&
                         "COMPLETED".equals(o.getStatus()))
            .mapToDouble(Order::getTotalAmount)
            .sum();
        
        System.out.println("最近30天订单金额: " + recentOrdersAmount);
        
        // 7. 生成客户消费报告
        String customerReport = customers.stream()
            .map(customer -> {
                double totalSpent = totalSpentByCustomer.getOrDefault(customer.getId(), 0.0);
                long orderCount = orders.stream()
                    .filter(o -> o.getCustomerId().equals(customer.getId()) && 
                                "COMPLETED".equals(o.getStatus()))
                    .count();
                
                return String.format("客户: %s, 等级: %s, 订单数: %d, 总消费: %.2f",
                    customer.getName(), customer.getTier(), orderCount, totalSpent);
            })
            .collect(Collectors.joining("\n"));
        
        System.out.println("\n客户消费报告:\n" + customerReport);
    }
}
```

### Java 9+ 模块化系统实践指南

Java 9引入的模块系统（Project Jigsaw）是Java平台的重大变革，它提供了一种更强大的方式来组织和封装代码。

#### 模块系统基础

##### 模块定义与结构

模块是一组相关的包、类和资源的集合，通过`module-info.java`文件定义。

```java
// module-info.java
module com.example.mymodule {
    // 依赖其他
我将继续编写Java发展历史与特性实战篇的内容。

```java
// module-info.java
module com.example.mymodule {
    // 依赖其他模块
    requires java.base; // 隐式依赖，可省略
    requires java.logging;
    
    // 导出包，使其他模块可以使用
    exports com.example.mymodule.api;
    
    // 仅向特定模块导出包
    exports com.example.mymodule.internal to com.example.othermodule;
    
    // 开放包以供反射访问
    opens com.example.mymodule.model;
    
    // 仅向特定模块开放包
    opens com.example.mymodule.config to com.example.framework;
    
    // 使用服务
    uses com.example.mymodule.spi.Service;
    
    // 提供服务实现
    provides com.example.mymodule.spi.Service 
        with com.example.mymodule.impl.ServiceImpl;
}
```

模块系统的主要目标：

1. **强封装**：只有显式导出的包才能被其他模块访问
2. **可靠配置**：模块必须声明其依赖关系
3. **模块化JDK**：将JDK拆分为较小的模块
4. **提高性能**：通过减少类路径扫描提高启动时间
5. **可伸缩性**：支持创建自定义运行时映像

##### 模块类型

Java模块系统支持多种类型的模块：

1. **命名模块**：通过`module-info.java`定义的模块
2. **自动模块**：放在模块路径上但没有`module-info.java`的JAR
3. **未命名模块**：在类路径上的JAR（向后兼容）

#### 创建多模块应用

下面我们将创建一个简单的多模块应用，包含API模块、实现模块和应用模块。

##### 项目结构

```
multi-module-app/
├── app/
│   ├── src/
│   │   ├── main/
│   │   │   ├── java/
│   │   │   │   ├── module-info.java
│   │   │   │   └── com/example/app/
│   │   │   │       └── Main.java
│   │   │   └── resources/
│   ├── pom.xml
├── api/
│   ├── src/
│   │   ├── main/
│   │   │   ├── java/
│   │   │   │   ├── module-info.java
│   │   │   │   └── com/example/api/
│   │   │   │       ├── MessageService.java
│   │   │   │       └── Message.java
│   ├── pom.xml
├── impl/
│   ├── src/
│   │   ├── main/
│   │   │   ├── java/
│   │   │   │   ├── module-info.java
│   │   │   │   └── com/example/impl/
│   │   │   │       └── MessageServiceImpl.java
│   ├── pom.xml
└── pom.xml
```

##### 模块定义

1. API模块 (`api/src/main/java/module-info.java`):

```java
module com.example.api {
    exports com.example.api;
}
```

2. 实现模块 (`impl/src/main/java/module-info.java`):

```java
module com.example.impl {
    requires com.example.api;
    
    provides com.example.api.MessageService 
        with com.example.impl.MessageServiceImpl;
}
```

3. 应用模块 (`app/src/main/java/module-info.java`):

```java
module com.example.app {
    requires com.example.api;
    
    uses com.example.api.MessageService;
}
```

##### 模块代码实现

1. API模块:

```java
// api/src/main/java/com/example/api/Message.java
package com.example.api;

public class Message {
    private final String content;
    
    public Message(String content) {
        this.content = content;
    }
    
    public String getContent() {
        return content;
    }
    
    @Override
    public String toString() {
        return "Message{content='" + content + "'}";
    }
}

// api/src/main/java/com/example/api/MessageService.java
package com.example.api;

public interface MessageService {
    Message getMessage();
}
```

2. 实现模块:

```java
// impl/src/main/java/com/example/impl/MessageServiceImpl.java
package com.example.impl;

import com.example.api.Message;
import com.example.api.MessageService;

public class MessageServiceImpl implements MessageService {
    @Override
    public Message getMessage() {
        return new Message("Hello from MessageServiceImpl!");
    }
}
```

3. 应用模块:

```java
// app/src/main/java/com/example/app/Main.java
package com.example.app;

import com.example.api.MessageService;
import java.util.ServiceLoader;

public class Main {
    public static void main(String[] args) {
        // 使用ServiceLoader加载服务实现
        ServiceLoader<MessageService> services = ServiceLoader.load(MessageService.class);
        
        services.findFirst().ifPresentOrElse(
            service -> System.out.println(service.getMessage()),
            () -> System.out.println("No MessageService implementation found")
        );
    }
}
```

##### 构建与运行

使用Maven构建多模块项目：

```xml
<!-- pom.xml (根项目) -->
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>multi-module-app</artifactId>
    <version>1.0.0</version>
    <packaging>pom</packaging>
    
    <modules>
        <module>api</module>
        <module>impl</module>
        <module>app</module>
    </modules>
    
    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>
</project>

<!-- api/pom.xml -->
<project>
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.example</groupId>
        <artifactId>multi-module-app</artifactId>
        <version>1.0.0</version>
    </parent>
    <artifactId>api</artifactId>
</project>

<!-- impl/pom.xml -->
<project>
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.example</groupId>
        <artifactId>multi-module-app</artifactId>
        <version>1.0.0</version>
    </parent>
    <artifactId>impl</artifactId>
    
    <dependencies>
        <dependency>
            <groupId>com.example</groupId>
            <artifactId>api</artifactId>
            <version>${project.version}</version>
        </dependency>
    </dependencies>
</project>

<!-- app/pom.xml -->
<project>
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.example</groupId>
        <artifactId>multi-module-app</artifactId>
        <version>1.0.0</version>
    </parent>
    <artifactId>app</artifactId>
    
    <dependencies>
        <dependency>
            <groupId>com.example</groupId>
            <artifactId>api</artifactId>
            <version>${project.version}</version>
        </dependency>
        <dependency>
            <groupId>com.example</groupId>
            <artifactId>impl</artifactId>
            <version>${project.version}</version>
            <scope>runtime</scope>
        </dependency>
    </dependencies>
    
    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-jar-plugin</artifactId>
                <version>3.2.0</version>
                <configuration>
                    <archive>
                        <manifest>
                            <mainClass>com.example.app.Main</mainClass>
                        </manifest>
                    </archive>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

使用以下命令构建和运行：

```bash
# 构建项目
mvn clean package

# 运行应用
java --module-path app/target/app-1.0.0.jar:api/target/api-1.0.0.jar:impl/target/impl-1.0.0.jar -m com.example.app/com.example.app.Main
```

#### 创建自定义运行时映像

使用`jlink`工具可以创建自定义运行时映像，只包含应用所需的模块，大大减小部署大小。

```bash
# 创建自定义运行时映像
jlink --module-path $JAVA_HOME/jmods:app/target/app-1.0.0.jar:api/target/api-1.0.0.jar:impl/target/impl-1.0.0.jar --add-modules com.example.app --output custom-runtime

# 运行自定义运行时中的应用
custom-runtime/bin/java -m com.example.app/com.example.app.Main
```

#### 模块化系统实战案例

下面是一个更复杂的模块化应用示例，实现一个简单的插件系统。

##### 项目结构

```
plugin-system/
├── core/
│   ├── src/main/java/
│   │   ├── module-info.java
│   │   └── com/example/plugin/
│   │       ├── api/
│   │       │   └── Plugin.java
│   │       └── core/
│   │           └── PluginManager.java
├── app/
│   ├── src/main/java/
│   │   ├── module-info.java
│   │   └── com/example/app/
│   │       └── Main.java
├── plugins/
│   ├── text-plugin/
│   │   ├── src/main/java/
│   │   │   ├── module-info.java
│   │   │   └── com/example/plugin/text/
│   │   │       └── TextPlugin.java
│   ├── image-plugin/
│   │   ├── src/main/java/
│   │   │   ├── module-info.java
│   │   │   └── com/example/plugin/image/
│   │   │       └── ImagePlugin.java
```

##### 模块定义

1. 核心模块 (`core/src/main/java/module-info.java`):

```java
module com.example.plugin.core {
    exports com.example.plugin.api;
    exports com.example.plugin.core;
    
    uses com.example.plugin.api.Plugin;
}
```

2. 应用模块 (`app/src/main/java/module-info.java`):

```java
module com.example.app {
    requires com.example.plugin.core;
}
```

3. 文本插件模块 (`plugins/text-plugin/src/main/java/module-info.java`):

```java
module com.example.plugin.text {
    requires com.example.plugin.core;
    
    provides com.example.plugin.api.Plugin
        with com.example.plugin.text.TextPlugin;
}
```

4. 图像插件模块 (`plugins/image-plugin/src/main/java/module-info.java`):

```java
module com.example.plugin.image {
    requires com.example.plugin.core;
    
    provides com.example.plugin.api.Plugin
        with com.example.plugin.image.ImagePlugin;
}
```

##### 代码实现

1. 核心模块:

```java
// core/src/main/java/com/example/plugin/api/Plugin.java
package com.example.plugin.api;

public interface Plugin {
    String getName();
    String getVersion();
    void execute(String input);
}

// core/src/main/java/com/example/plugin/core/PluginManager.java
package com.example.plugin.core;

import com.example.plugin.api.Plugin;
import java.util.ServiceLoader;
import java.util.stream.Collectors;
import java.util.List;

public class PluginManager {
    public List<Plugin> loadPlugins() {
        return ServiceLoader.load(Plugin.class)
            .stream()
            .map(ServiceLoader.Provider::get)
            .collect(Collectors.toList());
    }
    
    public void executeAll(String input) {
        List<Plugin> plugins = loadPlugins();
        System.out.println("Found " + plugins.size() + " plugins");
        
        for (Plugin plugin : plugins) {
            System.out.println("Executing plugin: " + plugin.getName() + " v" + plugin.getVersion());
            plugin.execute(input);
        }
    }
}
```

2. 应用模块:

```java
// app/src/main/java/com/example/app/Main.java
package com.example.app;

import com.example.plugin.core.PluginManager;

public class Main {
    public static void main(String[] args) {
        String input = args.length > 0 ? args[0] : "Default input";
        
        PluginManager manager = new PluginManager();
        manager.executeAll(input);
    }
}
```

3. 文本插件模块:

```java
// plugins/text-plugin/src/main/java/com/example/plugin/text/TextPlugin.java
package com.example.plugin.text;

import com.example.plugin.api.Plugin;

public class TextPlugin implements Plugin {
    @Override
    public String getName() {
        return "Text Plugin";
    }
    
    @Override
    public String getVersion() {
        return "1.0.0";
    }
    
    @Override
    public void execute(String input) {
        System.out.println("Text Plugin processing: " + input);
        System.out.println("Text length: " + input.length());
        System.out.println("Uppercase: " + input.toUpperCase());
    }
}
```

4. 图像插件模块:

```java
// plugins/image-plugin/src/main/java/com/example/plugin/image/ImagePlugin.java
package com.example.plugin.image;

import com.example.plugin.api.Plugin;

public class ImagePlugin implements Plugin {
    @Override
    public String getName() {
        return "Image Plugin";
    }
    
    @Override
    public String getVersion() {
        return "1.0.0";
    }
    
    @Override
    public void execute(String input) {
        System.out.println("Image Plugin processing: " + input);
        System.out.println("Simulating image processing for: " + input);
        System.out.println("Image processed with filters applied");
    }
}
```

##### 构建与运行

使用以下命令编译和运行模块化插件系统：

```bash
# 创建目录
mkdir -p mods/com.example.plugin.core mods/com.example.app mods/com.example.plugin.text mods/com.example.plugin.image

# 编译核心模块
javac -d mods/com.example.plugin.core core/src/main/java/module-info.java core/src/main/java/com/example/plugin/api/Plugin.java core/src/main/java/com/example/plugin/core/PluginManager.java

# 编译文本插件模块
javac --module-path mods -d mods/com.example.plugin.text plugins/text-plugin/src/main/java/module-info.java plugins/text-plugin/src/main/java/com/example/plugin/text/TextPlugin.java

# 编译图像插件模块
javac --module-path mods -d mods/com.example.plugin.image plugins/image-plugin/src/main/java/module-info.java plugins/image-plugin/src/main/java/com/example/plugin/image/ImagePlugin.java

# 编译应用模块
javac --module-path mods -d mods/com.example.app app/src/main/java/module-info.java app/src/main/java/com/example/app/Main.java

# 运行应用
java --module-path mods -m com.example.app/com.example.app.Main "Hello, Modular World!"
```

#### 模块化系统最佳实践

1. **模块粒度**：设计适当粒度的模块，既不过大也不过小
2. **明确API边界**：只导出公共API，保持内部实现的封装
3. **服务化设计**：使用服务提供者接口(SPI)实现松耦合
4. **版本管理**：注意模块间的版本兼容性
5. **迁移策略**：逐步将现有应用迁移到模块化系统

```java
// 良好的模块设计示例
module com.example.service {
    // 只导出公共API
    exports com.example.service.api;
    
    // 内部包保持封装
    // com.example.service.internal 不导出
    
    // 使用服务接口实现松耦合
    uses com.example.service.api.DataProvider;
    
    // 依赖其他模块的公共API
    requires com.example.common;
    requires java.logging;
}
```

### Java 10+ var类型推断最佳实践

Java 10引入了局部变量类型推断（使用`var`关键字），简化了变量声明，提高了代码可读性。

#### var基础用法

`var`关键字允许编译器根据初始化表达式推断局部变量的类型。

```java
// 基本用法示例
public class VarBasicsExample {
    public static void main(String[] args) {
        // 不使用var
        String message = "Hello, var";
        int count = 10;
        List<String> names = new ArrayList<>();
        
        // 使用var
        var message2 = "Hello, var"; // 推断为String
        var count2 = 10; // 推断为int
        var names2 = new ArrayList<String>(); // 推断为ArrayList<String>
        
        // 使用var与表达式
        var result = count2 * 2; // 推断为int
        var isValid = count2 > 5; // 推断为boolean
        var chars = message2.toCharArray(); // 推断为char[]
        
        // 在for循环中使用var
        for (var i = 0; i < 5; i++) {
            System.out.println(i);
        }
        
        // 在增强for循环中使用var
        for (var name : List.of("Alice", "Bob", "Charlie")) {
            System.out.println(name);
        }
        
        // 在try-with-resources中使用var
        try (var reader = new BufferedReader(new FileReader("data.txt"))) {
            var line = reader.readLine();
            System.out.println(line);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

#### var的使用场景与限制

`var`关键字有一些使用限制，了解这些限制有助于正确使用它。

```java
public class VarLimitationsExample {
    // 不能用于类字段
    // private var field = "Error"; // 编译错误
    
    // 不能用于方法参数
    // public void process(var data) { } // 编译错误
    
    // 不能用于方法返回类型
    // public var getValue() { return "Error"; } // 编译错误
    
    public static void main(String[] args) {
        // 必须初始化
        // var name; // 编译错误
        
        // 不能赋值为null
        // var reference = null; // 编译错误
        
        // 不能用于lambda参数
        // var processor = (var x) -> x.toUpperCase(); // 编译错误
        
        // 不能用于数组初始化器
        // var arr = { 1, 2, 3 }; // 编译错误
        
        // 正确的数组初始化
        var arr = new int[] { 1, 2, 3 };
        
        // 不能在一条语句中声明多个变量
        // var x = 1, y = 2; // 编译错误
    }
}
```

#### var最佳实践

以下是使用`var`关键字的一些最佳实践：

```java
import java.util.*;
import java.io.*;
import java.nio.file.*;

public class VarBestPracticesExample {
    public static void main(String[] args) throws IOException {
        // 1. 当类型名称冗长且明显时使用var
        // 不使用var
        Map<String, List<Map<String, String>>> complexMap1 = new HashMap<>();
        
        // 使用var - 更简洁
        var complexMap2 = new HashMap<String, List<Map<String, String>>>();
        
        // 2. 当类型在右侧清晰可见时使用var
        // 清晰可见的类型
        var names = new ArrayList<String>();
        var path = Paths.get("example.txt");
        var pattern = Pattern.compile("\\d+");
        
        // 3. 避免使用var导致类型不明确
        // 不好的做法 - 类型不明确
        var result = getResult(); // 返回类型不明确
        
        // 更好的做法 - 显式声明类型
        SomeType explicitResult = getResult();
        
        // 4. 使用var提高代码可读性
        // 不使用var - 类型重复
        BufferedReader reader = new BufferedReader(new FileReader("data.txt"));
        
        // 使用var - 消除重复
        var reader2 = new BufferedReader(new FileReader("data.txt"));
        
        // 5. 在循环中使用var简化代码
        // 使用var简化迭代器
        for (var entry : System.getProperties().entrySet()) {
            var key = entry.getKey();
            var value = entry.getValue();
            System.out.println(key + " = " + value);
        }
        
        // 6. 使用var与菱形操作符结合
        // 不好的做法 - 类型信息丢失
        var list = new ArrayList<>(); // 推断为ArrayList<Object>
        
        // 好的做法 - 保留泛型信息
        var typedList = new ArrayList<String>(); // 推断为ArrayList<String>
        
        // 7. 在链式调用中使用var捕获中间结果
        var files = new File("./").listFiles();
        var txtFiles = Arrays.stream(files)
            .filter(f -> f.getName().endsWith(".txt"))
            .toArray(File[]::new);
    }
    
    private static SomeType getResult() {
        return new SomeType();
    }
    
    static class SomeType {
        // 示例类
    }
}
```

#### 实际应用场景

下面是一些`var`在实际应用中的场景：

```java
import java.util.*;
import java.nio.file.*;
import java.io.*;
import java.util.stream.*;
import java.time.*;

public class VarRealWorldExample {
    public static void main(String[] args) throws Exception {
        // 1. 处理复杂的集合类型
        var employeesByDepartment = new HashMap<String, List<Employee>>();
        employeesByDepartment.put("Engineering", new ArrayList<>());
        
        // 2. 处理I/O操作
        var path = Paths.get("data.csv");
        var lines = Files.readAllLines(path);
        
        for (var line : lines) {
            var parts = line.split(",");
            // 处理CSV数据
        }
        
        // 3. 处理流操作
        var numbers = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
        var sum = numbers.stream()
            .filter(n -> n % 2 == 0)
            .mapToInt(Integer::intValue)
            .sum();
        
        // 4. 处理JSON数据
        var jsonString = "{\"name\":\"John\",\"age\":30}";
        // 假设使用Jackson库
        // var objectMapper = new ObjectMapper();
        // var person = objectMapper.readValue(jsonString, Person.class);
        
        // 5. 处理数据库结果
        // 假设使用JDBC
        // var connection = DriverManager.getConnection(url, username, password);
        // var statement = connection.prepareStatement("SELECT * FROM users");
        // var resultSet = statement.executeQuery();
        
        // while (resultSet.next()) {
        //     var id = resultSet.getInt("id");
        //     var name = resultSet.getString("name");
        //     // 处理结果
        // }
        
        // 6. 处理日期时间
        var now = LocalDateTime.now();
        var formatter = java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        var formattedDate = now.format(formatter);
        
        // 7. 处理HTTP请求
        // 假设使用HttpClient
        // var client = HttpClient.newHttpClient();
        // var request = HttpRequest.newBuilder()
        //     .uri(URI.create("https://api.example.com/data"))
        //     .GET()
        //     .build();
        // var response = client.send(request, HttpResponse.BodyHandlers.ofString());
        // var body = response.body();
    }
    
    static class Employee {
        private String name;
        private int age;
        
        public Employee(String name, int age) {
            this.name = name;
            this.age = age;
        }
        
        // Getters and setters
    }
}
```

#### var与函数式编程

`var`与Java的函数式编程特性结合使用可以提高代码可读性：

```java
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class VarWithFunctionalExample {
    public static void main(String[] args) {
        // 1. 使用var定义函数式接口
        var printer = (Consumer<String>) System.out::println;
        printer.accept("Hello, functional programming!");
        
        // 2. 使用var与方法引用
        var strings = List.of("apple", "banana", "cherry");
        var lengths = strings.stream()
            .map(String::length)
            .collect(Collectors.toList());
        
        // 3. 使用var与复杂的函数组合
        var adder = (Function<Integer, Function<Integer, Integer>>) 
            x -> y -> x + y;
        var add5 = adder.apply(5);
        System.out.println(add5.apply(3)); // 输出: 8
        
        // 4. 使用var简化Stream操作
        var numbers = IntStream.rangeClosed(1, 10).boxed().collect(Collectors.toList());
        
        var evenSquares = numbers.stream()
            .filter(n -> n % 2 == 0)
            .map(n -> n * n)
            .collect(Collectors.toList());
        
        System.out.println(evenSquares); // [4, 16, 36, 64, 100]
        
        // 5. 使用var与Optional
        var optionalValue = Optional.of("Hello");
        var result = optionalValue
            .map(String::toUpperCase)
            .orElse("Default");
        
        // 6. 使用var与自定义收集器
        var groupedByLength = strings.stream()
            .collect(Collectors.groupingBy(
                String::length,
                Collectors.counting()
            ));
        
        // 7. 使用var与并行流
        var parallelResult = numbers.parallelStream()
            .filter(n -> n % 2 == 1)
            .map(n -> n * n)
            .collect(Collectors.toList());
    }
}
```

### Java 14+ Records与Pattern Matching应用

Java 14引入了Records作为预览特性，Java 16正式发布。同时，Java也在不断增强模式匹配功能。这些新特性大大简化了数据处理代码。

#### Records基础

Records提供了一种简洁的方式来声明不可变的数据类。

```java
// Records基础示例
public class RecordsBasicsExample {
    // 定义一个简单的Record
    record Point(int x, int y) {}
    
    // 带有额外方法的Record
    record Rectangle(int width, int height) {
        // 紧凑构造函数
        public Rectangle {
            if (width <= 0 || height <= 0) {
                throw new IllegalArgumentException("Dimensions must be positive");
            }
        }
        
        // 添加自定义方法
        public int area() {
            return width * height;
        }
        
        public boolean isSquare() {
            return width == height;
        }
    }
    
    // 带有静态工厂方法的Record
    record Circle(double radius) {
        // 静态工厂方法
        public static Circle ofDiameter(double diameter) {
            return new Circle(diameter / 2);
        }
        
        // 计算面积
        public double area() {
            return Math.PI * radius * radius;
        }
    }
    
    public static void main(String[] args) {
        // 创建并使用Point
        var point = new Point(10, 20);
        System.out.println("Point: " + point); // 自动生成toString()
        System
我将继续编写Java发展历史与特性实战篇的内容。

```java
public static void main(String[] args) {
    // 创建并使用Point
    var point = new Point(10, 20);
    System.out.println("Point: " + point); // 自动生成toString()
    System.out.println("x = " + point.x() + ", y = " + point.y()); // 自动生成访问器
    
    // 创建并使用Rectangle
    var rectangle = new Rectangle(5, 10);
    System.out.println("Rectangle area: " + rectangle.area());
    System.out.println("Is square? " + rectangle.isSquare());
    
    // 使用静态工厂方法
    var circle = Circle.ofDiameter(10);
    System.out.println("Circle radius: " + circle.radius());
    System.out.println("Circle area: " + circle.area());
    
    // 解构Record
    var anotherPoint = new Point(30, 40);
    int x = anotherPoint.x();
    int y = anotherPoint.y();
    System.out.println("Destructured: x = " + x + ", y = " + y);
    
    // 使用equals和hashCode
    var samePoint = new Point(10, 20);
    System.out.println("point equals samePoint: " + point.equals(samePoint)); // true
    System.out.println("point hashCode: " + point.hashCode());
    System.out.println("samePoint hashCode: " + samePoint.hashCode());
}
```

#### Records实战应用

Records在实际应用中特别适合作为数据传输对象(DTO)、值对象和不可变数据容器。

```java
import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;

public class RecordsInPracticeExample {
    // 定义业务领域的Records
    record Customer(String id, String name, String email, LocalDate registrationDate) {}
    
    record Product(String id, String name, String category, double price) {}
    
    record OrderItem(String productId, int quantity, double unitPrice) {
        // 计算小计
        public double subtotal() {
            return quantity * unitPrice;
        }
    }
    
    record Order(String id, String customerId, LocalDate orderDate, 
                List<OrderItem> items, String status) {
        // 计算订单总金额
        public double total() {
            return items.stream()
                .mapToDouble(OrderItem::subtotal)
                .sum();
        }
        
        // 检查订单是否包含特定产品
        public boolean containsProduct(String productId) {
            return items.stream()
                .anyMatch(item -> item.productId().equals(productId));
        }
    }
    
    // 用于API响应的Record
    record ApiResponse<T>(int status, String message, T data) {}
    
    // 用于分页结果的Record
    record PagedResult<T>(List<T> items, int page, int pageSize, long totalItems) {
        public int totalPages() {
            return (int) Math.ceil((double) totalItems / pageSize);
        }
        
        public boolean hasNext() {
            return page < totalPages();
        }
        
        public boolean hasPrevious() {
            return page > 1;
        }
    }
    
    public static void main(String[] args) {
        // 创建客户
        var customer = new Customer(
            "C001", 
            "张三", 
            "zhangsan@example.com", 
            LocalDate.of(2022, 1, 15)
        );
        
        // 创建产品
        var product1 = new Product("P001", "笔记本电脑", "电子产品", 5999.99);
        var product2 = new Product("P002", "无线鼠标", "配件", 99.99);
        
        // 创建订单项
        var item1 = new OrderItem("P001", 1, 5999.99);
        var item2 = new OrderItem("P002", 2, 99.99);
        
        // 创建订单
        var order = new Order(
            "O001",
            customer.id(),
            LocalDate.now(),
            List.of(item1, item2),
            "PENDING"
        );
        
        // 使用订单方法
        System.out.println("订单总金额: " + order.total());
        System.out.println("订单包含P001产品: " + order.containsProduct("P001"));
        
        // 创建API响应
        var response = new ApiResponse<>(
            200,
            "订单创建成功",
            order
        );
        
        // 创建分页结果
        var orders = List.of(order);
        var pagedResult = new PagedResult<>(
            orders,
            1,
            10,
            1
        );
        
        System.out.println("总页数: " + pagedResult.totalPages());
        System.out.println("是否有下一页: " + pagedResult.hasNext());
        
        // 使用Records与Stream API
        var orderItems = order.items();
        var totalQuantity = orderItems.stream()
            .mapToInt(OrderItem::quantity)
            .sum();
        
        System.out.println("订单总数量: " + totalQuantity);
        
        // 使用Records作为Map的键
        var productMap = new HashMap<Product, Integer>();
        productMap.put(product1, 10); // 库存数量
        productMap.put(product2, 20);
        
        // 由于Records自动实现了equals和hashCode，可以安全地用作Map键
        var stock = productMap.get(new Product("P001", "笔记本电脑", "电子产品", 5999.99));
        System.out.println("P001库存: " + stock);
    }
}
```

#### Records与JSON处理

Records非常适合与JSON数据的序列化和反序列化。

```java
import java.util.*;
import java.time.LocalDate;

// 假设使用Jackson库
// import com.fasterxml.jackson.databind.ObjectMapper;
// import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;

public class RecordsWithJsonExample {
    // API请求和响应Records
    record UserRequest(String username, String email, String password) {}
    
    record UserResponse(String id, String username, String email, LocalDate createdAt) {}
    
    record ErrorResponse(int code, String message, List<String> details) {}
    
    // 嵌套Records
    record Address(String street, String city, String zipCode, String country) {}
    
    record Customer(String id, String name, String email, Address address, 
                   List<String> phoneNumbers) {}
    
    public static void main(String[] args) throws Exception {
        // 创建请求对象
        var userRequest = new UserRequest(
            "zhangsan",
            "zhangsan@example.com",
            "password123"
        );
        
        // 序列化为JSON
        // ObjectMapper mapper = new ObjectMapper();
        // mapper.registerModule(new JavaTimeModule());
        
        // String json = mapper.writeValueAsString(userRequest);
        // System.out.println("序列化后的JSON: " + json);
        
        // 反序列化JSON
        String userJson = """
            {
                "username": "lisi",
                "email": "lisi@example.com",
                "password": "securepass"
            }
            """;
        
        // UserRequest parsedRequest = mapper.readValue(userJson, UserRequest.class);
        // System.out.println("反序列化的对象: " + parsedRequest);
        
        // 创建嵌套Records
        var address = new Address(
            "中关村大街1号",
            "北京",
            "100080",
            "中国"
        );
        
        var customer = new Customer(
            "C001",
            "王五",
            "wangwu@example.com",
            address,
            List.of("13800138000", "13900139000")
        );
        
        // 序列化嵌套Records
        // String customerJson = mapper.writeValueAsString(customer);
        // System.out.println("嵌套Records序列化: " + customerJson);
        
        // 模拟API响应生成
        var successResponse = createSuccessResponse("U001", userRequest);
        var errorResponse = createErrorResponse(400, "验证失败", 
            List.of("邮箱格式不正确", "密码长度不足"));
        
        System.out.println("成功响应: " + successResponse);
        System.out.println("错误响应: " + errorResponse);
    }
    
    private static UserResponse createSuccessResponse(String id, UserRequest request) {
        return new UserResponse(
            id,
            request.username(),
            request.email(),
            LocalDate.now()
        );
    }
    
    private static ErrorResponse createErrorResponse(int code, String message, List<String> details) {
        return new ErrorResponse(code, message, details);
    }
}
```

#### Pattern Matching基础

Java 14开始引入模式匹配特性，并在后续版本中不断增强。

```java
// 模式匹配基础示例
public class PatternMatchingBasicsExample {
    public static void main(String[] args) {
        // 1. instanceof模式匹配 (Java 16+)
        Object obj = "Hello, Pattern Matching!";
        
        // 传统方式
        if (obj instanceof String) {
            String s = (String) obj;
            System.out.println("字符串长度: " + s.length());
        }
        
        // 使用模式匹配
        if (obj instanceof String s) {
            // 直接使用绑定变量s
            System.out.println("字符串长度: " + s.length());
        }
        
        // 在条件表达式中使用
        if (obj instanceof String s && s.length() > 10) {
            System.out.println("这是一个长字符串: " + s);
        }
        
        // 2. switch表达式 (Java 14+)
        var day = "MONDAY";
        
        // 传统switch语句
        switch (day) {
            case "MONDAY":
                System.out.println("星期一");
                break;
            case "TUESDAY":
                System.out.println("星期二");
                break;
            default:
                System.out.println("其他日子");
        }
        
        // 使用switch表达式
        String result = switch (day) {
            case "MONDAY" -> "星期一";
            case "TUESDAY" -> "星期二";
            default -> "其他日子";
        };
        
        System.out.println(result);
        
        // 带代码块的switch表达式
        int numLetters = switch (day) {
            case "MONDAY", "FRIDAY", "SUNDAY" -> {
                System.out.println("六个字母");
                yield 6;
            }
            case "TUESDAY" -> {
                System.out.println("七个字母");
                yield 7;
            }
            case "THURSDAY", "SATURDAY" -> {
                System.out.println("八个字母");
                yield 8;
            }
            case "WEDNESDAY" -> {
                System.out.println("九个字母");
                yield 9;
            }
            default -> {
                System.out.println("无效的日子");
                yield -1;
            }
        };
        
        System.out.println("字母数: " + numLetters);
    }
}
```

#### Pattern Matching与Records结合

Pattern Matching与Records结合使用可以创建更简洁、更强大的代码。

```java
import java.util.*;

public class PatternMatchingWithRecordsExample {
    // 定义一些Records
    record Point(int x, int y) {}
    record Circle(Point center, double radius) {}
    record Rectangle(Point topLeft, int width, int height) {}
    record Triangle(Point p1, Point p2, Point p3) {}
    
    // 形状层次结构
    sealed interface Shape permits Circle, Rectangle, Triangle {}
    record Circle(Point center, double radius) implements Shape {}
    record Rectangle(Point topLeft, int width, int height) implements Shape {}
    record Triangle(Point p1, Point p2, Point p3) implements Shape {}
    
    public static void main(String[] args) {
        // 创建一些形状
        List<Shape> shapes = List.of(
            new Circle(new Point(0, 0), 10),
            new Rectangle(new Point(5, 5), 20, 10),
            new Triangle(new Point(0, 0), new Point(10, 0), new Point(5, 10))
        );
        
        // 使用instanceof模式匹配处理形状
        for (Shape shape : shapes) {
            if (shape instanceof Circle c) {
                double area = Math.PI * c.radius() * c.radius();
                System.out.println("圆形面积: " + area);
            } else if (shape instanceof Rectangle r) {
                int area = r.width() * r.height();
                System.out.println("矩形面积: " + area);
            } else if (shape instanceof Triangle t) {
                // 使用海伦公式计算三角形面积
                double a = distance(t.p1(), t.p2());
                double b = distance(t.p2(), t.p3());
                double c = distance(t.p3(), t.p1());
                double s = (a + b + c) / 2;
                double area = Math.sqrt(s * (s - a) * (s - b) * (s - c));
                System.out.println("三角形面积: " + area);
            }
        }
        
        // 使用switch表达式处理形状
        for (Shape shape : shapes) {
            double area = calculateArea(shape);
            System.out.println("面积: " + area);
        }
        
        // 使用Records作为方法参数
        Point p1 = new Point(10, 20);
        Point p2 = new Point(30, 40);
        double distance = distance(p1, p2);
        System.out.println("两点距离: " + distance);
    }
    
    // 使用switch表达式和模式匹配计算面积
    static double calculateArea(Shape shape) {
        return switch (shape) {
            case Circle c -> Math.PI * c.radius() * c.radius();
            case Rectangle r -> r.width() * r.height();
            case Triangle t -> {
                double a = distance(t.p1(), t.p2());
                double b = distance(t.p2(), t.p3());
                double c = distance(t.p3(), t.p1());
                double s = (a + b + c) / 2;
                yield Math.sqrt(s * (s - a) * (s - b) * (s - c));
            }
        };
    }
    
    // 计算两点距离
    static double distance(Point p1, Point p2) {
        int dx = p2.x() - p1.x();
        int dy = p2.y() - p1.y();
        return Math.sqrt(dx * dx + dy * dy);
    }
}
```

#### 实际业务场景应用

下面是Records和Pattern Matching在实际业务场景中的应用示例：

```java
import java.time.*;
import java.util.*;
import java.util.stream.*;

public class BusinessPatternMatchingExample {
    // 定义消息类型
    sealed interface Message permits TextMessage, ImageMessage, VideoMessage, ErrorMessage {}
    
    record TextMessage(String sender, String content, LocalDateTime timestamp) implements Message {}
    record ImageMessage(String sender, String imageUrl, String caption, LocalDateTime timestamp) implements Message {}
    record VideoMessage(String sender, String videoUrl, int durationSeconds, LocalDateTime timestamp) implements Message {}
    record ErrorMessage(String errorCode, String description, LocalDateTime timestamp) implements Message {}
    
    // 定义支付类型
    sealed interface Payment permits CreditCardPayment, PayPalPayment, BankTransferPayment {}
    
    record CreditCardPayment(String cardNumber, String cardholderName, 
                            double amount, LocalDate expiryDate) implements Payment {}
    record PayPalPayment(String email, double amount) implements Payment {}
    record BankTransferPayment(String accountNumber, String bankCode, 
                              double amount, String reference) implements Payment {}
    
    // 定义API响应
    sealed interface ApiResult<T> permits Success, Failure {}
    record Success<T>(T data) implements ApiResult<T> {}
    record Failure<T>(int errorCode, String message) implements ApiResult<T> {}
    
    public static void main(String[] args) {
        // 处理消息示例
        List<Message> messages = List.of(
            new TextMessage("张三", "你好，最近怎么样？", LocalDateTime.now().minusHours(1)),
            new ImageMessage("李四", "https://example.com/image.jpg", "风景照", LocalDateTime.now().minusMinutes(30)),
            new VideoMessage("王五", "https://example.com/video.mp4", 120, LocalDateTime.now().minusMinutes(15)),
            new ErrorMessage("MSG_404", "消息未找到", LocalDateTime.now())
        );
        
        // 使用模式匹配处理消息
        for (Message message : messages) {
            processMessage(message);
        }
        
        // 处理支付示例
        List<Payment> payments = List.of(
            new CreditCardPayment("1234-5678-9012-3456", "张三", 199.99, LocalDate.of(2025, 12, 31)),
            new PayPalPayment("zhangsan@example.com", 99.99),
            new BankTransferPayment("987654321", "ICBC", 1299.99, "INV-001")
        );
        
        // 计算总金额
        double totalAmount = payments.stream()
            .mapToDouble(payment -> getPaymentAmount(payment))
            .sum();
        
        System.out.println("总支付金额: " + totalAmount);
        
        // 处理支付并生成收据
        for (Payment payment : payments) {
            String receipt = generateReceipt(payment);
            System.out.println(receipt);
        }
        
        // 模拟API调用
        ApiResult<User> userResult = fetchUser("U001");
        handleApiResult(userResult);
        
        ApiResult<List<Order>> ordersResult = fetchOrders("U001");
        handleApiResult(ordersResult);
    }
    
    // 使用switch表达式处理消息
    static void processMessage(Message message) {
        String displayText = switch (message) {
            case TextMessage text -> 
                String.format("[%s] %s: %s", 
                    formatTime(text.timestamp()), text.sender(), text.content());
                
            case ImageMessage image -> 
                String.format("[%s] %s sent an image: %s", 
                    formatTime(image.timestamp()), image.sender(), 
                    image.caption().isEmpty() ? "(no caption)" : image.caption());
                
            case VideoMessage video -> 
                String.format("[%s] %s sent a video (%d seconds)", 
                    formatTime(video.timestamp()), video.sender(), video.durationSeconds());
                
            case ErrorMessage error -> 
                String.format("[%s] ERROR %s: %s", 
                    formatTime(error.timestamp()), error.errorCode(), error.description());
        };
        
        System.out.println(displayText);
    }
    
    // 格式化时间
    static String formatTime(LocalDateTime time) {
        return time.format(java.time.format.DateTimeFormatter.ofPattern("HH:mm:ss"));
    }
    
    // 获取支付金额
    static double getPaymentAmount(Payment payment) {
        return switch (payment) {
            case CreditCardPayment cc -> cc.amount();
            case PayPalPayment pp -> pp.amount();
            case BankTransferPayment bt -> bt.amount();
        };
    }
    
    // 生成收据
    static String generateReceipt(Payment payment) {
        return switch (payment) {
            case CreditCardPayment cc -> 
                String.format("信用卡支付收据 - 卡号: %s, 持卡人: %s, 金额: %.2f, 有效期: %s",
                    maskCardNumber(cc.cardNumber()), cc.cardholderName(), 
                    cc.amount(), cc.expiryDate());
                
            case PayPalPayment pp -> 
                String.format("PayPal支付收据 - 邮箱: %s, 金额: %.2f",
                    pp.email(), pp.amount());
                
            case BankTransferPayment bt -> 
                String.format("银行转账收据 - 账号: %s, 银行代码: %s, 金额: %.2f, 参考号: %s",
                    bt.accountNumber(), bt.bankCode(), bt.amount(), bt.reference());
        };
    }
    
    // 掩码信用卡号
    static String maskCardNumber(String cardNumber) {
        if (cardNumber == null || cardNumber.length() < 8) {
            return cardNumber;
        }
        return "*".repeat(cardNumber.length() - 4) + cardNumber.substring(cardNumber.length() - 4);
    }
    
    // 处理API结果
    static <T> void handleApiResult(ApiResult<T> result) {
        switch (result) {
            case Success<T> success -> 
                System.out.println("API调用成功: " + success.data());
                
            case Failure<T> failure -> 
                System.out.println("API调用失败: 错误码=" + failure.errorCode() + 
                                  ", 消息=" + failure.message());
        }
    }
    
    // 模拟API调用
    static ApiResult<User> fetchUser(String userId) {
        if ("U001".equals(userId)) {
            return new Success<>(new User("U001", "张三", "zhangsan@example.com"));
        } else {
            return new Failure<>(404, "用户不存在");
        }
    }
    
    static ApiResult<List<Order>> fetchOrders(String userId) {
        if ("U001".equals(userId)) {
            return new Success<>(List.of(
                new Order("O001", "U001", 199.99, LocalDate.now()),
                new Order("O002", "U001", 299.99, LocalDate.now().minusDays(5))
            ));
        } else {
            return new Failure<>(404, "用户不存在");
        }
    }
    
    // 用户和订单Records
    record User(String id, String name, String email) {}
    record Order(String id, String userId, double amount, LocalDate orderDate) {}
}
```

### Java 21 虚拟线程实战案例

Java 21引入的虚拟线程是一项重大特性，它通过轻量级线程实现高并发，而无需大量系统资源。

#### 虚拟线程基础

虚拟线程是由JVM管理的轻量级线程，而不是直接映射到操作系统线程。

```java
import java.time.Duration;
import java.time.Instant;
import java.util.concurrent.*;
import java.util.stream.*;

public class VirtualThreadBasicsExample {
    public static void main(String[] args) throws Exception {
        // 创建单个虚拟线程
        Thread vThread = Thread.startVirtualThread(() -> {
            System.out.println("在虚拟线程中运行: " + Thread.currentThread());
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        
        // 等待虚拟线程完成
        vThread.join();
        
        // 使用虚拟线程执行器
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            // 提交任务
            Future<String> future = executor.submit(() -> {
                Thread.sleep(100);
                return "虚拟线程任务完成";
            });
            
            // 获取结果
            System.out.println(future.get());
        } // 执行器自动关闭
        
        // 创建多个虚拟线程
        Instant start = Instant.now();
        
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            // 创建10000个虚拟线程
            List<Future<Integer>> futures = IntStream.range(0, 10_000)
                .mapToObj(i -> executor.submit(() -> {
                    Thread.sleep(100); // 模拟I/O操作
                    return i;
                }))
                .collect(Collectors.toList());
            
            // 等待所有任务完成
            int sum = 0;
            for (Future<Integer> future : futures) {
                sum += future.get();
            }
            
            System.out.println("总和: " + sum);
        }
        
        Instant end = Instant.now();
        System.out.println("执行10000个虚拟线程任务耗时: " + 
                          Duration.between(start, end).toMillis() + " ms");
        
        // 对比平台线程
        start = Instant.now();
        
        try (var executor = Executors.newFixedThreadPool(200)) { // 使用200个平台线程
            List<Future<Integer>> futures = IntStream.range(0, 10_000)
                .mapToObj(i -> executor.submit(() -> {
                    Thread.sleep(100); // 模拟I/O操作
                    return i;
                }))
                .collect(Collectors.toList());
            
            int sum = 0;
            for (Future<Integer> future : futures) {
                sum += future.get();
            }
            
            System.out.println("总和: " + sum);
        }
        
        end = Instant.now();
        System.out.println("执行10000个平台线程任务耗时: " + 
                          Duration.between(start, end).toMillis() + " ms");
    }
}
```

#### 虚拟线程与结构化并发

Java 21还引入了结构化并发API，它与虚拟线程结合使用可以简化并发编程。

```java
import java.time.Duration;
import java.util.concurrent.*;

public class StructuredConcurrencyExample {
    public static void main(String[] args) throws Exception {
        // 使用结构化并发API
        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
            // 提交多个子任务
            Callable<String> task1 = () -> {
                Thread.sleep(1000);
                return "任务1结果";
            };
            
            Callable<String> task2 = () -> {
                Thread.sleep(2000);
                return "任务2结果";
            };
            
            StructuredTaskScope.Subtask<String> subtask1 = scope.fork(task1);
            StructuredTaskScope.Subtask<String> subtask2 = scope.fork(task2);
            
            // 等待所有任务完成或有任务失败
            scope.join();
            // 检查是否有任务失败
            scope.throwIfFailed();
            
            // 获取结果
            String result1 = subtask1.get();
            String result2 = subtask2.get();
            
            System.out.println("结果1: " + result1);
            System.out.println("结果2: " + result2);
        }
        
        // 处理异常情况
        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
            Callable<String> successTask = () -> {
                Thread.sleep(1000);
                return "成功任务";
            };
            
            Callable<String> failingTask = () -> {
                Thread.sleep(500);
                throw new RuntimeException("任务失败");
            };
            
            StructuredTaskScope.Subtask<String> subtask1 = scope.fork(successTask);
            StructuredTaskScope.Subtask<String> subtask2 = scope.fork(failingTask);
            
            try {
                scope.join();
                scope.throwIfFailed();
                
                // 如果没有异常，获取结果
                System.out.println("所有任务成功完成");
            } catch (ExecutionException e) {
                System.out.println("任务执行失败: " + e.getCause().getMessage());
                
                // 检查哪个任务成功了
                if (subtask1.state() == StructuredTaskScope.Subtask.State.SUCCESS) {
                    System.out.println("任务1成功: " + subtask1.get());
                }
                
                if (subtask2.state() == StructuredTaskScope.Subtask.State.SUCCESS) {
                    System.out.println("任务2成功: " + subtask2.get());
                }
            }
        }
        
        // 使用自定义策略
        try (var scope = new StructuredTaskScope.ShutdownOnSuccess<String>()) {
            // 提交多个可能的解决方案，接受第一个成功的
            scope.fork(() -> {
                Thread.sleep(2000);
                return "慢速服务响应";
            });
            
            scope.fork(() -> {
                Thread.sleep(1000);
                return "中速服务响应";
            });
            
            scope.fork(() -> {
                Thread.sleep(500);
                return "快速服务响应";
            });
            
            // 等待第一个成功的任务
            scope.join();
            
            // 获取结果
            String result = scope.result();
            System.out.println("最快的成功响应: " + result);
        }
    }
}
```

#### 虚拟线程实战应用

下面是虚拟线程在实际应用场景中的使用示例：

```java
import java.net.URI;
import java.net.http.*;
import java.time.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

public class VirtualThreadRealWorldExample {
    // 模拟API客户端
    static class ApiClient {
        private final HttpClient httpClient;
        
        public ApiClient() {
            this.httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration
我将继续编写Java发展历史与特性实战篇的内容。

```java
import java.net.URI;
import java.net.http.*;
import java.time.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

public class VirtualThreadRealWorldExample {
    // 模拟API客户端
    static class ApiClient {
        private final HttpClient httpClient;
        
        public ApiClient() {
            this.httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(5))
                .build();
        }
        
        public String fetchData(String endpoint) throws Exception {
            HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create("https://api.example.com/" + endpoint))
                .GET()
                .build();
            
            // 模拟网络延迟
            Thread.sleep(100 + (int)(Math.random() * 200));
            
            // 在实际应用中，这里会发送真实的HTTP请求
            // HttpResponse<String> response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            // return response.body();
            
            return "Data from " + endpoint + " at " + LocalTime.now();
        }
    }
    
    // 模拟数据库客户端
    static class DatabaseClient {
        public Map<String, Object> query(String sql) throws Exception {
            // 模拟数据库查询延迟
            Thread.sleep(150 + (int)(Math.random() * 100));
            
            // 模拟查询结果
            Map<String, Object> result = new HashMap<>();
            result.put("query", sql);
            result.put("timestamp", LocalTime.now().toString());
            result.put("rows", (int)(Math.random() * 100));
            
            return result;
        }
        
        public void update(String sql, Map<String, Object> params) throws Exception {
            // 模拟数据库更新延迟
            Thread.sleep(100 + (int)(Math.random() * 150));
            
            // 在实际应用中，这里会执行真实的数据库更新
            System.out.println("执行更新: " + sql + " 参数: " + params + " 时间: " + LocalTime.now());
        }
    }
    
    // 模拟用户服务
    static class UserService {
        private final ApiClient apiClient;
        private final DatabaseClient dbClient;
        
        public UserService(ApiClient apiClient, DatabaseClient dbClient) {
            this.apiClient = apiClient;
            this.dbClient = dbClient;
        }
        
        public Map<String, Object> getUserProfile(String userId) throws Exception {
            // 使用结构化并发同时获取用户数据和订单数据
            try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
                // 获取用户基本信息
                var userInfoTask = scope.fork(() -> {
                    return dbClient.query("SELECT * FROM users WHERE id = '" + userId + "'");
                });
                
                // 获取用户订单
                var ordersTask = scope.fork(() -> {
                    return dbClient.query("SELECT * FROM orders WHERE user_id = '" + userId + "' LIMIT 10");
                });
                
                // 获取用户偏好
                var preferencesTask = scope.fork(() -> {
                    return apiClient.fetchData("users/" + userId + "/preferences");
                });
                
                // 等待所有任务完成或失败
                scope.join();
                // 如果有任务失败，抛出异常
                scope.throwIfFailed();
                
                // 合并结果
                Map<String, Object> profile = new HashMap<>();
                profile.put("userInfo", userInfoTask.get());
                profile.put("recentOrders", ordersTask.get());
                profile.put("preferences", preferencesTask.get());
                
                return profile;
            }
        }
    }
    
    // 模拟产品服务
    static class ProductService {
        private final ApiClient apiClient;
        private final DatabaseClient dbClient;
        
        public ProductService(ApiClient apiClient, DatabaseClient dbClient) {
            this.apiClient = apiClient;
            this.dbClient = dbClient;
        }
        
        public List<Map<String, Object>> searchProducts(String query, int limit) throws Exception {
            // 并行查询多个数据源
            try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
                // 查询数据库
                Future<Map<String, Object>> dbResultsFuture = executor.submit(() -> {
                    return dbClient.query("SELECT * FROM products WHERE name LIKE '%" + query + "%' LIMIT " + limit);
                });
                
                // 查询外部API
                Future<String> apiResultsFuture = executor.submit(() -> {
                    return apiClient.fetchData("products/search?q=" + query + "&limit=" + limit);
                });
                
                // 查询推荐系统
                Future<String> recommendationsFuture = executor.submit(() -> {
                    return apiClient.fetchData("recommendations?q=" + query + "&limit=" + limit);
                });
                
                // 获取所有结果
                Map<String, Object> dbResults = dbResultsFuture.get();
                String apiResults = apiResultsFuture.get();
                String recommendations = recommendationsFuture.get();
                
                // 合并结果（实际应用中会解析JSON等）
                List<Map<String, Object>> results = new ArrayList<>();
                results.add(dbResults);
                results.add(Map.of("apiResults", apiResults));
                results.add(Map.of("recommendations", recommendations));
                
                return results;
            }
        }
    }
    
    // 模拟订单处理服务
    static class OrderProcessingService {
        private final DatabaseClient dbClient;
        private final ApiClient apiClient;
        
        public OrderProcessingService(DatabaseClient dbClient, ApiClient apiClient) {
            this.dbClient = dbClient;
            this.apiClient = apiClient;
        }
        
        public String processOrder(Map<String, Object> orderData) throws Exception {
            String orderId = UUID.randomUUID().toString();
            Instant start = Instant.now();
            
            // 使用虚拟线程并行执行多个步骤
            try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
                // 步骤1: 验证库存
                executor.submit(() -> {
                    try {
                        System.out.println("验证库存: " + orderData.get("items") + " 线程: " + Thread.currentThread());
                        Thread.sleep(100);
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                }).get();
                
                // 步骤2: 处理支付
                executor.submit(() -> {
                    try {
                        System.out.println("处理支付: " + orderData.get("payment") + " 线程: " + Thread.currentThread());
                        Thread.sleep(200);
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                }).get();
                
                // 步骤3: 保存订单
                executor.submit(() -> {
                    try {
                        Map<String, Object> params = new HashMap<>(orderData);
                        params.put("order_id", orderId);
                        dbClient.update("INSERT INTO orders VALUES (:order_id, :customer_id, :amount)", params);
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                }).get();
                
                // 步骤4: 发送确认邮件
                executor.submit(() -> {
                    try {
                        System.out.println("发送确认邮件到: " + orderData.get("email") + " 线程: " + Thread.currentThread());
                        Thread.sleep(150);
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                }).get();
                
                // 步骤5: 更新客户订单历史
                executor.submit(() -> {
                    try {
                        Map<String, Object> params = new HashMap<>();
                        params.put("customer_id", orderData.get("customer_id"));
                        params.put("order_id", orderId);
                        dbClient.update("UPDATE customers SET last_order_id = :order_id WHERE id = :customer_id", params);
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                }).get();
            }
            
            Instant end = Instant.now();
            System.out.println("订单处理完成，耗时: " + Duration.between(start, end).toMillis() + "ms");
            
            return orderId;
        }
    }
    
    // 模拟高并发Web服务器
    static class WebServer {
        private final UserService userService;
        private final ProductService productService;
        private final OrderProcessingService orderService;
        
        public WebServer() {
            ApiClient apiClient = new ApiClient();
            DatabaseClient dbClient = new DatabaseClient();
            
            this.userService = new UserService(apiClient, dbClient);
            this.productService = new ProductService(apiClient, dbClient);
            this.orderService = new OrderProcessingService(dbClient, apiClient);
        }
        
        public void start() throws Exception {
            System.out.println("Web服务器启动，使用虚拟线程处理请求...");
            
            // 模拟并发请求
            int concurrentRequests = 100;
            
            Instant start = Instant.now();
            
            try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
                // 提交多个并发请求
                List<Future<?>> futures = new ArrayList<>();
                
                for (int i = 0; i < concurrentRequests; i++) {
                    int requestId = i;
                    
                    // 随机选择请求类型
                    int requestType = (int)(Math.random() * 3);
                    
                    Future<?> future = executor.submit(() -> {
                        try {
                            switch (requestType) {
                                case 0:
                                    // 用户资料请求
                                    String userId = "user" + (requestId % 10);
                                    Map<String, Object> profile = userService.getUserProfile(userId);
                                    System.out.println("请求 #" + requestId + ": 获取用户资料 " + userId);
                                    break;
                                    
                                case 1:
                                    // 产品搜索请求
                                    String[] queries = {"手机", "电脑", "耳机", "相机", "平板"};
                                    String query = queries[requestId % queries.length];
                                    List<Map<String, Object>> products = productService.searchProducts(query, 10);
                                    System.out.println("请求 #" + requestId + ": 搜索产品 '" + query + "', 找到 " + products.size() + " 个结果");
                                    break;
                                    
                                case 2:
                                    // 订单处理请求
                                    Map<String, Object> orderData = new HashMap<>();
                                    orderData.put("customer_id", "cust" + (requestId % 10));
                                    orderData.put("items", List.of("item1", "item2"));
                                    orderData.put("payment", Map.of("type", "credit_card", "amount", 99.99));
                                    orderData.put("email", "customer" + (requestId % 10) + "@example.com");
                                    
                                    String orderId = orderService.processOrder(orderData);
                                    System.out.println("请求 #" + requestId + ": 处理订单，生成订单ID: " + orderId);
                                    break;
                            }
                        } catch (Exception e) {
                            System.err.println("请求 #" + requestId + " 失败: " + e.getMessage());
                            e.printStackTrace();
                        }
                        
                        return null;
                    });
                    
                    futures.add(future);
                }
                
                // 等待所有请求完成
                for (Future<?> future : futures) {
                    future.get();
                }
            }
            
            Instant end = Instant.now();
            long duration = Duration.between(start, end).toMillis();
            
            System.out.println("所有 " + concurrentRequests + " 个请求已处理完成");
            System.out.println("总耗时: " + duration + " ms");
            System.out.println("平均每个请求耗时: " + (duration / concurrentRequests) + " ms");
        }
    }
    
    public static void main(String[] args) throws Exception {
        WebServer server = new WebServer();
        server.start();
    }
}
```

#### 虚拟线程与传统线程对比

虚拟线程与传统平台线程相比有显著的优势，特别是在处理I/O密集型任务时。

```java
import java.time.*;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.*;

public class VirtualThreadComparisonExample {
    // 模拟I/O操作
    static void simulateIoOperation() throws Exception {
        Thread.sleep(100); // 模拟网络或磁盘I/O
    }
    
    // 使用平台线程执行任务
    static void runWithPlatformThreads(int tasks, int threadPoolSize) throws Exception {
        System.out.println("\n使用平台线程执行 " + tasks + " 个任务 (线程池大小: " + threadPoolSize + ")");
        
        Instant start = Instant.now();
        
        ExecutorService executor = Executors.newFixedThreadPool(threadPoolSize);
        
        try {
            List<Future<Integer>> futures = new ArrayList<>();
            
            for (int i = 0; i < tasks; i++) {
                final int taskId = i;
                futures.add(executor.submit(() -> {
                    simulateIoOperation();
                    return taskId;
                }));
            }
            
            // 等待所有任务完成
            for (Future<Integer> future : futures) {
                future.get();
            }
        } finally {
            executor.shutdown();
        }
        
        Instant end = Instant.now();
        long duration = Duration.between(start, end).toMillis();
        
        System.out.println("总耗时: " + duration + " ms");
        System.out.println("平均每个任务耗时: " + (duration / tasks) + " ms");
        System.out.println("任务吞吐量: " + (tasks * 1000.0 / duration) + " 任务/秒");
    }
    
    // 使用虚拟线程执行任务
    static void runWithVirtualThreads(int tasks) throws Exception {
        System.out.println("\n使用虚拟线程执行 " + tasks + " 个任务");
        
        Instant start = Instant.now();
        
        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            List<Future<Integer>> futures = new ArrayList<>();
            
            for (int i = 0; i < tasks; i++) {
                final int taskId = i;
                futures.add(executor.submit(() -> {
                    simulateIoOperation();
                    return taskId;
                }));
            }
            
            // 等待所有任务完成
            for (Future<Integer> future : futures) {
                future.get();
            }
        }
        
        Instant end = Instant.now();
        long duration = Duration.between(start, end).toMillis();
        
        System.out.println("总耗时: " + duration + " ms");
        System.out.println("平均每个任务耗时: " + (duration / tasks) + " ms");
        System.out.println("任务吞吐量: " + (tasks * 1000.0 / duration) + " 任务/秒");
    }
    
    // 测试不同数量任务的性能
    static void runScalabilityTest() throws Exception {
        System.out.println("\n=== 可扩展性测试 ===");
        
        int[] taskCounts = {100, 1000, 10000};
        
        for (int tasks : taskCounts) {
            // 使用固定大小的线程池
            runWithPlatformThreads(tasks, 100);
            
            // 使用虚拟线程
            runWithVirtualThreads(tasks);
        }
    }
    
    // 测试内存使用
    static void runMemoryUsageTest() throws Exception {
        System.out.println("\n=== 内存使用测试 ===");
        
        // 在测试前请求垃圾回收
        System.gc();
        Thread.sleep(1000);
        
        long initialMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        System.out.println("初始内存使用: " + (initialMemory / 1024 / 1024) + " MB");
        
        // 创建大量平台线程
        System.out.println("\n创建10000个平台线程...");
        try {
            List<Thread> platformThreads = new ArrayList<>();
            for (int i = 0; i < 10000; i++) {
                Thread t = new Thread(() -> {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                });
                t.start();
                platformThreads.add(t);
                
                if (i % 1000 == 0) {
                    System.gc();
                    long currentMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
                    System.out.println("创建 " + i + " 个平台线程后内存使用: " + 
                                      (currentMemory / 1024 / 1024) + " MB");
                }
            }
            
            // 等待所有线程完成
            for (Thread t : platformThreads) {
                t.join();
            }
        } catch (OutOfMemoryError e) {
            System.out.println("创建平台线程时内存不足: " + e.getMessage());
        }
        
        // 请求垃圾回收
        System.gc();
        Thread.sleep(1000);
        
        // 创建大量虚拟线程
        System.out.println("\n创建100000个虚拟线程...");
        List<Thread> virtualThreads = new ArrayList<>();
        for (int i = 0; i < 100000; i++) {
            Thread t = Thread.startVirtualThread(() -> {
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            });
            virtualThreads.add(t);
            
            if (i % 10000 == 0) {
                System.gc();
                long currentMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
                System.out.println("创建 " + i + " 个虚拟线程后内存使用: " + 
                                  (currentMemory / 1024 / 1024) + " MB");
            }
        }
        
        // 等待所有虚拟线程完成
        for (Thread t : virtualThreads) {
            t.join();
        }
        
        // 最终内存使用
        System.gc();
        Thread.sleep(1000);
        long finalMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
        System.out.println("最终内存使用: " + (finalMemory / 1024 / 1024) + " MB");
    }
    
    public static void main(String[] args) throws Exception {
        // 比较平台线程和虚拟线程
        runWithPlatformThreads(1000, 100);
        runWithVirtualThreads(1000);
        
        // 可扩展性测试
        runScalabilityTest();
        
        // 内存使用测试
        // 注意：这个测试可能会导致OutOfMemoryError
        // runMemoryUsageTest();
    }
}
```

## Java平台选择与应用场景

### 企业级应用开发技术栈选择

Java在企业级应用开发中有多种技术栈选择，根据不同的应用场景和需求，可以选择不同的框架和工具。

#### Spring生态系统

Spring框架是Java企业级应用开发的主流选择，提供了全面的解决方案。

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.*;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

import javax.persistence.*;
import java.util.List;
import java.util.Optional;

// Spring Boot应用示例
@SpringBootApplication
public class EnterpriseApplication {
    public static void main(String[] args) {
        SpringApplication.run(EnterpriseApplication.class, args);
    }
}

// 实体类
@Entity
class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String description;
    private double price;
    
    // 构造函数、getter和setter
    // ...
}

// 数据访问层
interface ProductRepository extends JpaRepository<Product, Long> {
    List<Product> findByNameContaining(String name);
}

// 服务层
@Service
class ProductService {
    @Autowired
    private ProductRepository repository;
    
    public List<Product> findAll() {
        return repository.findAll();
    }
    
    public Optional<Product> findById(Long id) {
        return repository.findById(id);
    }
    
    public Product save(Product product) {
        return repository.save(product);
    }
    
    public void deleteById(Long id) {
        repository.deleteById(id);
    }
    
    public List<Product> search(String keyword) {
        return repository.findByNameContaining(keyword);
    }
}

// 控制器层
@RestController
@RequestMapping("/api/products")
class ProductController {
    @Autowired
    private ProductService service;
    
    @GetMapping
    public List<Product> getAllProducts() {
        return service.findAll();
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<Product> getProductById(@PathVariable Long id) {
        return service.findById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
    
    @PostMapping
    public Product createProduct(@RequestBody Product product) {
        return service.save(product);
    }
    
    @PutMapping("/{id}")
    public ResponseEntity<Product> updateProduct(@PathVariable Long id, @RequestBody Product product) {
        return service.findById(id)
            .map(existingProduct -> {
                // 更新产品属性
                // ...
                return ResponseEntity.ok(service.save(existingProduct));
            })
            .orElse(ResponseEntity.notFound().build());
    }
    
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        return service.findById(id)
            .map(product -> {
                service.deleteById(id);
                return ResponseEntity.ok().<Void>build();
            })
            .orElse(ResponseEntity.notFound().build());
    }
    
    @GetMapping("/search")
    public List<Product> searchProducts(@RequestParam String keyword) {
        return service.search(keyword);
    }
}
```

#### Jakarta EE (原Java EE)

Jakarta EE是企业级Java应用的标准平台，提供了一套完整的API和规范。

```java
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jakarta.persistence.*;
import jakarta.ws.rs.*;
import jakarta.ws.rs.core.MediaType;
import jakarta.ws.rs.core.Response;

import java.util.List;

// Jakarta EE应用示例

// 实体类
@Entity
@Table(name = "customers")
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    
    // 构造函数、getter和setter
    // ...
}

// 数据访问层
@ApplicationScoped
public class CustomerRepository {
    @PersistenceContext
    private EntityManager em;
    
    public List<Customer> findAll() {
        return em.createQuery("SELECT c FROM Customer c", Customer.class).getResultList();
    }
    
    public Customer findById(Long id) {
        return em.find(Customer.class, id);
    }
    
    public void save(Customer customer) {
        if (customer.getId() == null) {
            em.persist(customer);
        } else {
            em.merge(customer);
        }
    }
    
    public void delete(Long id) {
        Customer customer = findById(id);
        if (customer != null) {
            em.remove(customer);
        }
    }
}

// 服务层
@ApplicationScoped
public class CustomerService {
    @Inject
    private CustomerRepository repository;
    
    public List<Customer> findAll() {
        return repository.findAll();
    }
    
    public Customer findById(Long id) {
        return repository.findById(id);
    }
    
    public void save(Customer customer) {
        repository.save(customer);
    }
    
    public void delete(Long id) {
        repository.delete(id);
    }
}

// REST API
@Path("/api/customers")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
public class CustomerResource {
    @Inject
    private CustomerService service;
    
    @GET
    public List<Customer> getAllCustomers() {
        return service.findAll();
    }
    
    @GET
    @Path("/{id}")
    public Response getCustomerById(@PathParam("id") Long id) {
        Customer customer = service.findById(id);
        if (customer != null) {
            return Response.ok(customer).build();
        } else {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
    }
    
    @POST
    public Response createCustomer(Customer customer) {
        service.save(customer);
        return Response.status(Response.Status.CREATED).build();
    }
    
    @PUT
    @Path("/{id}")
    public Response updateCustomer(@PathParam("id") Long id, Customer customer) {
        Customer existingCustomer = service.findById(id);
        if (existingCustomer != null) {
            customer.setId(id);
            service.save(customer);
            return Response.ok().build();
        } else {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
    }
    
    @DELETE
    @Path("/{id}")
    public Response deleteCustomer(@PathParam("id") Long id) {
        Customer customer = service.findById(id);
        if (customer != null) {
            service.delete(id);
            return Response.ok().build();
        } else {
            return Response.status(Response.Status.NOT_FOUND).build();
        }
    }
}
```

#### 轻量级框架

对于需要更轻量级解决方案的项目，可以选择Micronaut、Quarkus或Helidon等框架。

```java
// Micronaut示例
import io.micronaut.http.annotation.*;
import io.micronaut.http.HttpResponse;
import io.micronaut.data.annotation.*;
import io.micronaut.data.repository.CrudRepository;
import io.micronaut.core.annotation.NonNull;

import javax.validation.constraints.NotBlank;
import java.util.List;
import java.util.Optional;

// 实体类
@MappedEntity
class User {
    @Id
    @GeneratedValue
    private Long id;
    
    @NotBlank
    private String name;
    
    @NotBlank
    private String email;
    
    // 构造函数、getter和setter
    // ...
}

// 数据访问层
@Repository
interface UserRepository extends CrudRepository<User, Long> {
    List<User> findAll();
    Optional<User> findByEmail(String email);
}

// 服务层
@jakarta.inject.Singleton
class UserService {
    private final UserRepository repository;
    
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
    
    public List<User> findAll() {
        return repository.findAll();
    }
    
    public Optional<User> findById(@NonNull Long id) {
        return repository.findById(id);
    }
    
    public User save(@NonNull User user) {
        return repository.save(user);
    }
    
    public void deleteById(@NonNull Long id) {
        repository.deleteById(id);
    }
}

// 控制器
@Controller("/api/users")
class UserController {
    private final UserService service;
    
    public UserController(UserService service) {
        this.service = service;
    }
    
    @Get
    public List<User> getAll() {
        return service.findAll();
    }
    
    @Get("/{id}")
    public HttpResponse<User> getById(Long id) {
        return service.findById(id)
            .map(HttpResponse::ok)
            .orElse(HttpResponse.notFound());
    }
    
    @Post
    public HttpResponse<User> create(@Body User user) {
        User savedUser = service.save(user);
        return HttpResponse.created(savedUser);
    }
    
    @Put("/{id}")
    public HttpResponse<User> update(Long id, @Body User user) {
        return service.findById(id)
            .map(existingUser -> {
                user.setId(id);
                return HttpResponse.ok(service.save(user));
            })
            .orElse(HttpResponse.notFound());
    }
    
    @Delete("/{id}")
    public HttpResponse<?> delete(Long id) {
        service.deleteById(id);
        return HttpResponse.noContent();
    }
}
```

#### 技术栈选择指南

选择合适的Java技术栈需要考虑多种因素：

1. **应用规
我将继续编写Java发展历史与特性实战篇的内容。

#### 技术栈选择指南

选择合适的Java技术栈需要考虑多种因素：

1. **应用规模与复杂度**：大型企业应用可能更适合Spring或Jakarta EE，而微服务或轻量级应用可以考虑Micronaut、Quarkus等。

2. **团队经验与技能**：选择团队熟悉的技术栈可以提高开发效率。

3. **性能需求**：如果启动时间和内存占用很重要，可以考虑GraalVM原生镜像兼容的框架。

4. **云原生支持**：对于部署在云环境的应用，选择具有良好云原生支持的框架。

5. **生态系统成熟度**：考虑框架的社区支持、文档质量和第三方库集成。

```java
// 技术栈选择决策表
/*
+----------------+-------------------+------------------+------------------+------------------+
| 考虑因素        | Spring Boot       | Jakarta EE       | Micronaut        | Quarkus          |
+----------------+-------------------+------------------+------------------+------------------+
| 应用类型        | 全栈应用、微服务   | 企业级应用       | 微服务、云函数    | 微服务、云原生    |
| 启动时间        | 中等              | 较长             | 快               | 快               |
| 内存占用        | 中等              | 较高             | 低               | 低               |
| 开发体验        | 优秀              | 良好             | 良好             | 良好             |
| 社区支持        | 非常强大          | 强大             | 良好             | 良好             |
| 云原生支持      | 良好              | 中等             | 优秀             | 优秀             |
| GraalVM支持    | 部分支持          | 部分支持         | 完全支持         | 完全支持         |
| 反应式支持      | Spring WebFlux    | 有限             | 内置             | 内置             |
+----------------+-------------------+------------------+------------------+------------------+
*/
```

### Java在不同领域的应用

Java是一种通用编程语言，可以应用于多种领域。以下是Java在不同领域的应用示例。

#### Web应用开发

Java在Web应用开发领域有着广泛的应用，从传统的MVC架构到现代的RESTful API。

```java
// Spring MVC控制器示例
@Controller
public class WebController {
    @GetMapping("/")
    public String home(Model model) {
        model.addAttribute("message", "欢迎来到Java Web应用");
        return "home";
    }
    
    @GetMapping("/form")
    public String showForm(Model model) {
        model.addAttribute("user", new User());
        return "form";
    }
    
    @PostMapping("/submit")
    public String submitForm(@Valid User user, BindingResult result, Model model) {
        if (result.hasErrors()) {
            return "form";
        }
        
        model.addAttribute("user", user);
        return "result";
    }
}

// RESTful API示例
@RestController
@RequestMapping("/api")
public class ApiController {
    @Autowired
    private DataService service;
    
    @GetMapping("/data")
    public List<DataItem> getAllData() {
        return service.findAll();
    }
    
    @GetMapping("/data/{id}")
    public ResponseEntity<DataItem> getDataById(@PathVariable Long id) {
        return service.findById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
    
    @PostMapping("/data")
    public ResponseEntity<DataItem> createData(@RequestBody @Valid DataItem item) {
        DataItem saved = service.save(item);
        URI location = ServletUriComponentsBuilder
            .fromCurrentRequest()
            .path("/{id}")
            .buildAndExpand(saved.getId())
            .toUri();
        
        return ResponseEntity.created(location).body(saved);
    }
}
```

#### 移动应用开发

Java是Android应用开发的官方语言之一，通过Android SDK可以开发功能丰富的移动应用。

```java
// Android活动示例
public class MainActivity extends AppCompatActivity {
    private EditText editText;
    private Button button;
    private TextView resultText;
    
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        
        // 初始化视图
        editText = findViewById(R.id.edit_text);
        button = findViewById(R.id.submit_button);
        resultText = findViewById(R.id.result_text);
        
        // 设置按钮点击监听器
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                String input = editText.getText().toString();
                if (!input.isEmpty()) {
                    resultText.setText("你输入了: " + input);
                } else {
                    resultText.setText("请输入内容");
                }
            }
        });
    }
    
    // 菜单创建
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.main_menu, menu);
        return true;
    }
    
    // 菜单项选择
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        int id = item.getItemId();
        
        if (id == R.id.action_settings) {
            // 打开设置活动
            Intent intent = new Intent(this, SettingsActivity.class);
            startActivity(intent);
            return true;
        }
        
        return super.onOptionsItemSelected(item);
    }
}

// RecyclerView适配器示例
public class ItemAdapter extends RecyclerView.Adapter<ItemAdapter.ViewHolder> {
    private List<Item> items;
    private OnItemClickListener listener;
    
    public interface OnItemClickListener {
        void onItemClick(Item item);
    }
    
    public ItemAdapter(List<Item> items, OnItemClickListener listener) {
        this.items = items;
        this.listener = listener;
    }
    
    @NonNull
    @Override
    public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
        View view = LayoutInflater.from(parent.getContext())
            .inflate(R.layout.item_layout, parent, false);
        return new ViewHolder(view);
    }
    
    @Override
    public void onBindViewHolder(@NonNull ViewHolder holder, int position) {
        Item item = items.get(position);
        holder.titleText.setText(item.getTitle());
        holder.descriptionText.setText(item.getDescription());
        
        holder.itemView.setOnClickListener(v -> {
            if (listener != null) {
                listener.onItemClick(item);
            }
        });
    }
    
    @Override
    public int getItemCount() {
        return items.size();
    }
    
    static class ViewHolder extends RecyclerView.ViewHolder {
        TextView titleText;
        TextView descriptionText;
        
        public ViewHolder(@NonNull View itemView) {
            super(itemView);
            titleText = itemView.findViewById(R.id.item_title);
            descriptionText = itemView.findViewById(R.id.item_description);
        }
    }
}
```

#### 大数据处理

Java在大数据处理领域有着重要地位，许多大数据框架如Hadoop、Spark都支持Java。

```java
// Hadoop MapReduce示例
public class WordCount {
    public static class TokenizerMapper extends Mapper<Object, Text, Text, IntWritable> {
        private final static IntWritable one = new IntWritable(1);
        private Text word = new Text();
        
        public void map(Object key, Text value, Context context) throws IOException, InterruptedException {
            StringTokenizer itr = new StringTokenizer(value.toString());
            while (itr.hasMoreTokens()) {
                word.set(itr.nextToken());
                context.write(word, one);
            }
        }
    }
    
    public static class IntSumReducer extends Reducer<Text, IntWritable, Text, IntWritable> {
        private IntWritable result = new IntWritable();
        
        public void reduce(Text key, Iterable<IntWritable> values, Context context) 
                throws IOException, InterruptedException {
            int sum = 0;
            for (IntWritable val : values) {
                sum += val.get();
            }
            result.set(sum);
            context.write(key, result);
        }
    }
    
    public static void main(String[] args) throws Exception {
        Configuration conf = new Configuration();
        Job job = Job.getInstance(conf, "word count");
        job.setJarByClass(WordCount.class);
        job.setMapperClass(TokenizerMapper.class);
        job.setCombinerClass(IntSumReducer.class);
        job.setReducerClass(IntSumReducer.class);
        job.setOutputKeyClass(Text.class);
        job.setOutputValueClass(IntWritable.class);
        FileInputFormat.addInputPath(job, new Path(args[0]));
        FileOutputFormat.setOutputPath(job, new Path(args[1]));
        System.exit(job.waitForCompletion(true) ? 0 : 1);
    }
}

// Spark Java API示例
public class SparkWordCount {
    public static void main(String[] args) {
        // 创建Spark上下文
        SparkConf conf = new SparkConf().setAppName("Word Count").setMaster("local[*]");
        JavaSparkContext sc = new JavaSparkContext(conf);
        
        // 加载文本文件
        JavaRDD<String> lines = sc.textFile("input.txt");
        
        // 分词并计数
        JavaRDD<String> words = lines.flatMap(line -> Arrays.asList(line.split(" ")).iterator());
        JavaPairRDD<String, Integer> wordCounts = words.mapToPair(word -> new Tuple2<>(word, 1))
            .reduceByKey((a, b) -> a + b);
        
        // 按计数排序
        JavaPairRDD<String, Integer> sortedCounts = wordCounts.sortByKey();
        
        // 保存结果
        sortedCounts.saveAsTextFile("output");
        
        // 关闭Spark上下文
        sc.close();
    }
}
```

#### 云原生应用

Java适合开发云原生应用，特别是使用Spring Cloud、Quarkus等框架。

```java
// Spring Cloud微服务示例
@SpringBootApplication
@EnableDiscoveryClient
public class UserServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }
}

@RestController
@RequestMapping("/users")
public class UserController {
    @Autowired
    private UserService userService;
    
    @GetMapping
    public List<User> getAllUsers() {
        return userService.findAll();
    }
    
    @GetMapping("/{id}")
    public ResponseEntity<User> getUserById(@PathVariable String id) {
        return userService.findById(id)
            .map(ResponseEntity::ok)
            .orElse(ResponseEntity.notFound().build());
    }
    
    // 其他CRUD操作
}

// 配置服务客户端
@Configuration
@EnableConfigurationProperties
public class AppConfig {
    @Value("${app.message}")
    private String message;
    
    @Bean
    public String messageBean() {
        return message;
    }
}

// 断路器示例
@Service
public class RemoteServiceClient {
    @Autowired
    private RestTemplate restTemplate;
    
    @CircuitBreaker(name = "remoteService", fallbackMethod = "fallback")
    public String callRemoteService() {
        return restTemplate.getForObject("http://remote-service/api/data", String.class);
    }
    
    public String fallback(Exception e) {
        return "远程服务不可用，使用备用响应";
    }
}
```

#### 物联网(IoT)应用

Java可以用于开发物联网应用，特别是在网关和边缘设备上。

```java
// MQTT客户端示例
public class MqttIoTClient {
    private MqttClient client;
    private final String broker = "tcp://mqtt.example.com:1883";
    private final String clientId = "JavaIoTClient";
    
    public void connect() throws MqttException {
        client = new MqttClient(broker, clientId);
        MqttConnectOptions options = new MqttConnectOptions();
        options.setCleanSession(true);
        options.setConnectionTimeout(60);
        options.setKeepAliveInterval(60);
        
        // 连接到MQTT代理
        client.connect(options);
        System.out.println("已连接到MQTT代理: " + broker);
        
        // 设置消息回调
        client.setCallback(new MqttCallback() {
            @Override
            public void connectionLost(Throwable cause) {
                System.out.println("连接丢失: " + cause.getMessage());
            }
            
            @Override
            public void messageArrived(String topic, MqttMessage message) throws Exception {
                System.out.println("收到消息: " + new String(message.getPayload()));
                processMessage(topic, message);
            }
            
            @Override
            public void deliveryComplete(IMqttDeliveryToken token) {
                System.out.println("消息已发送");
            }
        });
        
        // 订阅主题
        client.subscribe("sensors/#", 1);
    }
    
    public void publishData(String topic, String payload) throws MqttException {
        MqttMessage message = new MqttMessage(payload.getBytes());
        message.setQos(1);
        client.publish(topic, message);
        System.out.println("已发布消息: " + payload);
    }
    
    private void processMessage(String topic, MqttMessage message) {
        // 处理接收到的消息
        String payload = new String(message.getPayload());
        
        if (topic.startsWith("sensors/temperature")) {
            double temperature = Double.parseDouble(payload);
            if (temperature > 30) {
                try {
                    publishData("actuators/cooling", "ON");
                } catch (MqttException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    
    public void disconnect() throws MqttException {
        if (client != null && client.isConnected()) {
            client.disconnect();
            System.out.println("已断开连接");
        }
    }
    
    public static void main(String[] args) {
        MqttIoTClient iotClient = new MqttIoTClient();
        try {
            iotClient.connect();
            
            // 模拟发送传感器数据
            for (int i = 0; i < 10; i++) {
                double temperature = 20 + Math.random() * 15;
                iotClient.publishData("sensors/temperature", String.format("%.2f", temperature));
                Thread.sleep(5000);
            }
            
            iotClient.disconnect();
        } catch (MqttException | InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

#### 游戏开发

Java可以用于游戏开发，特别是使用LibGDX等游戏引擎。

```java
// LibGDX游戏示例
public class SimpleGame extends ApplicationAdapter {
    private SpriteBatch batch;
    private Texture playerTexture;
    private Sprite playerSprite;
    private OrthographicCamera camera;
    private Vector3 touchPosition;
    
    @Override
    public void create() {
        batch = new SpriteBatch();
        playerTexture = new Texture("player.png");
        playerSprite = new Sprite(playerTexture);
        playerSprite.setPosition(
            Gdx.graphics.getWidth() / 2 - playerSprite.getWidth() / 2,
            Gdx.graphics.getHeight() / 2 - playerSprite.getHeight() / 2
        );
        
        camera = new OrthographicCamera();
        camera.setToOrtho(false, Gdx.graphics.getWidth(), Gdx.graphics.getHeight());
        touchPosition = new Vector3();
    }
    
    @Override
    public void render() {
        // 清屏
        Gdx.gl.glClearColor(0.1f, 0.1f, 0.2f, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);
        
        // 更新相机
        camera.update();
        batch.setProjectionMatrix(camera.combined);
        
        // 处理输入
        if (Gdx.input.isTouched()) {
            touchPosition.set(Gdx.input.getX(), Gdx.input.getY(), 0);
            camera.unproject(touchPosition);
            playerSprite.setPosition(
                touchPosition.x - playerSprite.getWidth() / 2,
                touchPosition.y - playerSprite.getHeight() / 2
            );
        }
        
        // 绘制精灵
        batch.begin();
        playerSprite.draw(batch);
        batch.end();
    }
    
    @Override
    public void dispose() {
        batch.dispose();
        playerTexture.dispose();
    }
    
    public static void main(String[] args) {
        LwjglApplicationConfiguration config = new LwjglApplicationConfiguration();
        config.title = "Simple Game";
        config.width = 800;
        config.height = 480;
        new LwjglApplication(new SimpleGame(), config);
    }
}
```

### Java与其他语言的比较

Java与其他编程语言相比有其独特的优势和劣势。以下是Java与几种主要编程语言的比较。

#### Java vs Python

```java
// Java示例：计算斐波那契数列
public class Fibonacci {
    public static long fibonacci(int n) {
        if (n <= 1) return n;
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
    
    public static void main(String[] args) {
        long startTime = System.nanoTime();
        long result = fibonacci(40);
        long endTime = System.nanoTime();
        
        System.out.println("结果: " + result);
        System.out.println("耗时: " + (endTime - startTime) / 1_000_000 + " ms");
    }
}

/*
Python等效代码:

def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

import time

start_time = time.time()
result = fibonacci(40)
end_time = time.time()

print("结果:", result)
print("耗时:", (end_time - start_time) * 1000, "ms")
*/

// Java与Python比较
/*
+----------------+-------------------+------------------+
| 特性           | Java              | Python           |
+----------------+-------------------+------------------+
| 类型系统       | 静态类型          | 动态类型         |
| 性能           | 较快              | 较慢             |
| 语法简洁性     | 较冗长            | 简洁             |
| 并发支持       | 强大              | 有限(GIL)        |
| 内存管理       | 自动垃圾回收      | 自动垃圾回收     |
| 应用领域       | 企业级应用、Android| 数据科学、脚本   |
| 学习曲线       | 中等              | 较低             |
| 生态系统       | 丰富              | 丰富             |
+----------------+-------------------+------------------+
*/
```

#### Java vs JavaScript/TypeScript

```java
// Java示例：处理JSON数据
import com.fasterxml.jackson.databind.ObjectMapper;

public class JsonProcessor {
    static class Person {
        private String name;
        private int age;
        
        // 构造函数、getter和setter
        // ...
        
        @Override
        public String toString() {
            return "Person{name='" + name + "', age=" + age + "}";
        }
    }
    
    public static void main(String[] args) throws Exception {
        String json = "{\"name\":\"张三\",\"age\":30}";
        
        ObjectMapper mapper = new ObjectMapper();
        Person person = mapper.readValue(json, Person.class);
        
        System.out.println("解析的对象: " + person);
        
        // 修改对象
        person.setAge(31);
        
        // 序列化回JSON
        String updatedJson = mapper.writeValueAsString(person);
        System.out.println("更新后的JSON: " + updatedJson);
    }
}

/*
JavaScript等效代码:

// 解析JSON
const json = '{"name":"张三","age":30}';
const person = JSON.parse(json);

console.log("解析的对象:", person);

// 修改对象
person.age = 31;

// 序列化回JSON
const updatedJson = JSON.stringify(person);
console.log("更新后的JSON:", updatedJson);
*/

// Java与JavaScript/TypeScript比较
/*
+----------------+-------------------+------------------+
| 特性           | Java              | JavaScript/TypeScript |
+----------------+-------------------+------------------+
| 运行环境       | JVM               | 浏览器/Node.js   |
| 类型系统       | 静态类型          | JS:动态类型, TS:静态类型 |
| 并发模型       | 多线程            | 单线程+事件循环  |
| 面向对象支持   | 完全支持          | 原型继承/类      |
| 函数式编程     | 部分支持          | 良好支持         |
| 应用领域       | 后端、企业级应用  | 前端、全栈       |
| 生态系统       | Maven、Gradle     | npm              |
| 性能           | 较高              | 中等             |
+----------------+-------------------+------------------+
*/
```

#### Java vs C#

```java
// Java示例：LINQ类似功能
import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;

public class StreamExample {
    static class Product {
        private String name;
        private String category;
        private double price;
        
        public Product(String name, String category, double price) {
            this.name = name;
            this.category = category;
            this.price = price;
        }
        
        // Getter方法
        public String getName() { return name; }
        public String getCategory() { return category; }
        public double getPrice() { return price; }
        
        @Override
        public String toString() {
            return "Product{name='" + name + "', category='" + category + "', price=" + price + "}";
        }
    }
    
    public static void main(String[] args) {
        List<Product> products = Arrays.asList(
            new Product("笔记本电脑", "电子产品", 5999.99),
            new Product("智能手机", "电子产品", 2999.99),
            new Product("咖啡机", "家电", 899.99),
            new Product("电视", "家电", 3999.99),
            new Product("耳机", "电子产品", 499.99)
        );
        
        // 使用Stream API过滤、分组和聚合数据
        double avgElectronicsPrice = products.stream()
            .filter(p -> p.getCategory().equals("电子产品"))
            .mapToDouble(Product::getPrice)
            .average()
            .orElse(0);
        
        System.out.println("电子产品平均价格: " + avgElectronicsPrice);
        
        // 按类别分组
        Map<String, List<Product>> groupedByCategory = products.stream()
            .collect(Collectors.groupingBy(Product::getCategory));
        
        groupedByCategory.forEach((category, prods) -> {
            System.out.println("类别: " + category);
            prods.forEach(p -> System.out.println("  - " + p.getName() + ": " + p.getPrice()));
        });
        
        // 找出每个类别中最贵的产品
        Map<String, Optional<Product>> mostExpensiveByCategory = products.stream()
            .collect(Collectors.groupingBy(
                Product::getCategory,
                Collectors.maxBy(Comparator.comparing(Product::getPrice))
            ));
        
        System.out.println("\n各类别最贵产品:");
        mostExpensiveByCategory.forEach((category, product) -> {
            product.ifPresent(p -> System.out.println(category + ": " + p.getName() + " - " + p.getPrice()));
        });
    }
}

/*
C#等效代码:

var products = new List<Product> {
    new Product { Name = "笔记本电脑", Category = "电子产品", Price = 5999.99 },
    new Product { Name = "智能手机", Category = "电子产品", Price = 2999.99 },
    new Product { Name = "咖啡机", Category = "家电", Price = 899.99 },
    new Product { Name = "电视", Category = "家电", Price = 3999.99 },
    new Product { Name = "耳机", Category = "电子产品", Price = 499.99 }
};

// 使用LINQ过滤、分组和聚合数据
var avgElectronicsPrice = products
    .Where(p => p.Category == "电子产品")
    .Average(p => p.Price);

Console.WriteLine($"电子产品平均价格: {avgElectronicsPrice}");

// 按类别分组
var groupedByCategory = products.GroupBy(p => p.Category);

foreach (var group in groupedByCategory) {
    Console.WriteLine($"类别: {group.Key}");
    foreach (var p in group) {
        Console.WriteLine($"  - {p.Name}: {p.Price}");
    }
}

// 找出每个类别中最贵的产品
var mostExpensiveByCategory = products
    .GroupBy(p => p.Category)
    .Select(g => new {
        Category = g.Key,
        MostExpensive = g.OrderByDescending(p => p.Price).First()
    });

Console.WriteLine("\n各类别最贵产品:");
foreach (var item in mostExpensiveByCategory) {
    Console.WriteLine($"{item.Category}: {item.MostExpensive.Name} - {item.MostExpensive.Price}");
}
*/

// Java与C#比较
/*
+----------------+-------------------+------------------+
| 特性           | Java              | C#               |
+----------------+-------------------+------------------+
| 平台           | 跨平台(JVM)       | 主要是.NET平台   |
| 语法           | 较传统            | 更现代           |
| 特性更新       | 较慢              | 较快             |
| 属性支持       | 无内置支持        | 内置支持         |
| 泛型实现       | 类型擦除          | 真实类型         |
| 异步编程       | CompletableFuture | async/await      |
| 语言集成查询   | Stream API        | LINQ             |
| 元编程         | 注解处理          | 特性+反射        |
| 生态系统       | 更成熟            | 紧密集成微软生态 |
+----------------+-------------------+------------------+
*/
```

#### Java vs Kotlin

```java
// Java示例：空安全处理
public class NullSafetyExample {
    static class User {
        private String name;
        private Address address;
        
        public User(String name, Address address) {
            this.name = name;
            this.address = address;
        }
        
        public String getName() {
            return name;
        }
        
        public Address getAddress() {
            return address;
        }
    }
    
    static class Address {
        private String street;
        private String city;
        
        public Address(String street, String city) {
            this.street = street;
            this.city = city;
        }
        
        public String getStreet() {
            return street;
        }
        
        public String getCity() {
            return city;
        }
    }
    
    public static void main(String[] args) {
        User user1 = new User("张三", new Address("中关村大街", "北京"));
        User user2 = new User("李四", null);
        
        // Java中处理可能为null的值
        printUserCity(user1); // 正常工作
        printUserCity(user2); // 需要null检查
        
        // 使用Optional
        Optional<String> city1 = getUserCity(user1);
        Optional<String> city2 = getUserCity(user2);
        
        System.out.println("用户1城市: " + city1.orElse("未知"));
        System.out.println("用户2城市: " + city2.orElse("未知"));
    }
    
    static void printUserCity(User user) {
        // 需要进行多重null检查
        if (user != null && user.getAddress() != null && user.getAddress().getCity() != null) {
            System.out.println("城市: " + user.getAddress().getCity());
        } else {
            System.out.println("城市信息不可用");
        }
    }
    
    static Optional<String> getUserCity(User user) {
        return Optional.ofNullable(user)
            .map(User::getAddress)
            .map(Address::getCity);
    }
}

/*
Kotlin等效代码:

data class User(val name: String, val address: Address?)
data class Address(val street: String, val city: String)

fun main() {
    val user1 = User("张三", Address("中关村大街", "北京"))
    val user2 = User
我将继续编写Java发展历史与特性实战篇的内容。

```java
/*
Kotlin等效代码:

data class User(val name: String, val address: Address?)
data class Address(val street: String, val city: String)

fun main() {
    val user1 = User("张三", Address("中关村大街", "北京"))
    val user2 = User("李四", null)
    
    // Kotlin中处理可能为null的值
    printUserCity(user1) // 正常工作
    printUserCity(user2) // 安全调用操作符处理null
    
    // 使用安全调用和Elvis操作符
    val city1 = getUserCity(user1)
    val city2 = getUserCity(user2)
    
    println("用户1城市: ${city1 ?: "未知"}")
    println("用户2城市: ${city2 ?: "未知"}")
}

fun printUserCity(user: User) {
    // 使用安全调用操作符
    println("城市: ${user.address?.city ?: "城市信息不可用"}")
}

fun getUserCity(user: User): String? {
    return user.address?.city
}
*/

// Java与Kotlin比较
/*
+----------------+-------------------+------------------+
| 特性           | Java              | Kotlin           |
+----------------+-------------------+------------------+
| 空安全         | 无内置支持        | 内置支持         |
| 扩展函数       | 不支持            | 支持             |
| 数据类         | 需手动实现        | 内置支持         |
| 协程           | 不支持            | 支持             |
| 函数式编程     | 部分支持          | 完全支持         |
| 智能类型转换   | 不支持            | 支持             |
| 属性委托       | 不支持            | 支持             |
| 互操作性       | -                 | 与Java完全兼容   |
| 学习曲线       | 中等              | 较低(对Java开发者)|
+----------------+-------------------+------------------+
*/
```

## Java未来发展趋势

### 语言演进路线图

Java语言在未来将继续演进，以下是一些可能的发展方向：

```java
// Java未来特性预览

// 1. 模式匹配增强 (Java 21+)
public void patternMatchingEnhancements(Object obj) {
    // 记录模式匹配
    if (obj instanceof Point(int x, int y)) {
        System.out.println("点坐标: (" + x + ", " + y + ")");
    }
    
    // switch模式匹配
    String formatted = switch (obj) {
        case Integer i -> String.format("整数: %d", i);
        case String s -> String.format("字符串: %s", s);
        case Point(int x, int y) -> String.format("点: (%d, %d)", x, y);
        case null -> "null";
        default -> obj.toString();
    };
}

// 2. 值类型 (Project Valhalla)
/*
value class Point {
    int x;
    int y;
    
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    public int distanceFromOrigin() {
        return (int) Math.sqrt(x * x + y * y);
    }
}
*/

// 3. 外部函数和内存API (Project Panama)
/*
// 直接调用本地函数
import jdk.incubator.foreign.*;

public class PanamaExample {
    public static void main(String[] args) {
        // 加载C库
        var stdlib = CLinker.systemLibrary();
        
        // 查找printf函数
        var printf = stdlib.lookup("printf").get();
        
        // 创建方法句柄
        var methodType = MethodType.methodType(int.class, MemoryAddress.class, Object[].class);
        var printfHandle = CLinker.getInstance().downcallHandle(printf, methodType);
        
        // 创建字符串
        try (var arena = MemorySegment.allocateNative(100, SegmentScope.auto())) {
            var cString = arena.allocateUtf8String("Hello from Panama!");
            
            // 调用printf
            try {
                int result = (int) printfHandle.invokeExact(cString.address(), new Object[0]);
                System.out.println("\nprintf返回值: " + result);
            } catch (Throwable t) {
                t.printStackTrace();
            }
        }
    }
}
*/

// 4. 结构化并发增强 (Java 21+)
/*
public void enhancedStructuredConcurrency() throws Exception {
    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
        // 提交多个任务
        var task1 = scope.fork(() -> fetchUserData());
        var task2 = scope.fork(() -> fetchUserOrders());
        var task3 = scope.fork(() -> fetchUserPreferences());
        
        // 等待所有任务完成或有任务失败
        scope.join();
        scope.throwIfFailed();
        
        // 处理结果
        var userData = task1.get();
        var orders = task2.get();
        var preferences = task3.get();
        
        // 合并结果
        createUserProfile(userData, orders, preferences);
    }
}
*/

// 5. 字符串模板 (Java 21+)
/*
public void stringTemplates() {
    String name = "世界";
    int count = 3;
    double price = 123.45;
    
    // 使用字符串模板
    String message = STR."你好，\{name}！";
    String repeated = STR."\{name}被重复了\{count}次: \{name.repeat(count)}";
    String formatted = STR."价格: \{price}元";
    
    System.out.println(message);
    System.out.println(repeated);
    System.out.println(formatted);
    
    // 使用格式化模板
    String money = FMT."价格: \{price;%.2f}元";
    System.out.println(money);
}
*/

// 6. 更多的密封类应用
sealed interface Shape permits Circle, Rectangle, Triangle, Polygon {}

final class Circle implements Shape {
    private final double radius;
    
    Circle(double radius) {
        this.radius = radius;
    }
    
    double area() {
        return Math.PI * radius * radius;
    }
}

final class Rectangle implements Shape {
    private final double width;
    private final double height;
    
    Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    double area() {
        return width * height;
    }
}

final class Triangle implements Shape {
    private final double base;
    private final double height;
    
    Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }
    
    double area() {
        return 0.5 * base * height;
    }
}

// 可扩展的形状
non-sealed class Polygon implements Shape {
    private final double[] sides;
    
    Polygon(double... sides) {
        this.sides = sides;
    }
    
    // 实现...
}
```

### Java与新兴技术的结合

Java正在与多种新兴技术结合，以下是一些示例：

#### Java与人工智能

```java
// 使用Deep Java Library (DJL)的AI示例
import ai.djl.*;
import ai.djl.inference.*;
import ai.djl.ndarray.*;
import ai.djl.translate.*;

public class ImageClassificationExample {
    public static void main(String[] args) throws Exception {
        // 加载预训练模型
        Criteria<Image, Classifications> criteria = Criteria.builder()
            .setTypes(Image.class, Classifications.class)
            .optEngine("PyTorch")
            .optApplication(Application.CV.IMAGE_CLASSIFICATION)
            .optProgress(new ProgressBar())
            .build();
        
        try (ZooModel<Image, Classifications> model = ModelZoo.loadModel(criteria)) {
            try (Predictor<Image, Classifications> predictor = model.newPredictor()) {
                // 加载图像
                Image img = ImageFactory.getInstance().fromUrl("https://example.com/image.jpg");
                
                // 执行推理
                Classifications classifications = predictor.predict(img);
                
                // 输出结果
                System.out.println(classifications);
            }
        }
    }
}

// 使用Deeplearning4j的示例
import org.deeplearning4j.nn.conf.MultiLayerConfiguration;
import org.deeplearning4j.nn.conf.NeuralNetConfiguration;
import org.deeplearning4j.nn.conf.layers.DenseLayer;
import org.deeplearning4j.nn.conf.layers.OutputLayer;
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.deeplearning4j.nn.weights.WeightInit;
import org.nd4j.linalg.activations.Activation;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.dataset.DataSet;
import org.nd4j.linalg.factory.Nd4j;
import org.nd4j.linalg.learning.config.Adam;
import org.nd4j.linalg.lossfunctions.LossFunctions;

public class SimpleNeuralNetworkExample {
    public static void main(String[] args) {
        // 配置神经网络
        MultiLayerConfiguration conf = new NeuralNetConfiguration.Builder()
            .seed(123)
            .updater(new Adam(0.001))
            .weightInit(WeightInit.XAVIER)
            .list()
            .layer(0, new DenseLayer.Builder()
                .nIn(4) // 输入特征数
                .nOut(10) // 隐藏层神经元数
                .activation(Activation.RELU)
                .build())
            .layer(1, new OutputLayer.Builder(LossFunctions.LossFunction.NEGATIVELOGLIKELIHOOD)
                .nIn(10)
                .nOut(3) // 输出类别数
                .activation(Activation.SOFTMAX)
                .build())
            .build();
        
        // 创建神经网络
        MultiLayerNetwork model = new MultiLayerNetwork(conf);
        model.init();
        
        // 创建训练数据
        INDArray input = Nd4j.rand(150, 4);
        INDArray output = Nd4j.zeros(150, 3);
        // 设置标签...
        
        // 训练模型
        DataSet dataSet = new DataSet(input, output);
        model.fit(dataSet, 100);
        
        // 使用模型进行预测
        INDArray testInput = Nd4j.rand(1, 4);
        INDArray prediction = model.output(testInput);
        System.out.println("预测结果: " + prediction);
    }
}
```

#### Java与区块链

```java
// 使用Web3j与以太坊区块链交互
import org.web3j.crypto.Credentials;
import org.web3j.protocol.Web3j;
import org.web3j.protocol.core.methods.response.Web3ClientVersion;
import org.web3j.protocol.http.HttpService;
import org.web3j.tx.Transfer;
import org.web3j.utils.Convert;

import java.math.BigDecimal;

public class EthereumExample {
    public static void main(String[] args) throws Exception {
        // 连接到以太坊节点
        Web3j web3j = Web3j.build(new HttpService("https://mainnet.infura.io/v3/YOUR_INFURA_KEY"));
        
        // 检查连接
        Web3ClientVersion clientVersion = web3j.web3ClientVersion().send();
        System.out.println("客户端版本: " + clientVersion.getWeb3ClientVersion());
        
        // 加载凭证
        Credentials credentials = Credentials.create("YOUR_PRIVATE_KEY");
        
        // 发送交易
        Transfer transfer = new Transfer(web3j, credentials);
        transfer.sendFunds(
            "0xRecipientAddress",
            BigDecimal.valueOf(0.01),
            Convert.Unit.ETHER,
            BigDecimal.valueOf(21_000),
            BigDecimal.valueOf(20)
        ).send();
        
        // 部署智能合约
        // YourContract contract = YourContract.deploy(
        //     web3j, credentials, 
        //     BigDecimal.valueOf(20).multiply(Convert.Unit.GWEI.getWeiFactor()).toBigInteger(),
        //     BigDecimal.valueOf(100_000).toBigInteger(),
        //     param1, param2
        // ).send();
        
        // System.out.println("合约地址: " + contract.getContractAddress());
    }
}

// 使用Hyperledger Fabric SDK
import org.hyperledger.fabric.gateway.*;

import java.nio.file.Path;
import java.nio.file.Paths;

public class FabricExample {
    public static void main(String[] args) throws Exception {
        // 加载网络配置
        Path networkConfigPath = Paths.get("connection.json");
        Path walletPath = Paths.get("wallet");
        
        // 加载身份钱包
        Wallet wallet = Wallets.newFileSystemWallet(walletPath);
        
        // 配置网关
        Gateway.Builder builder = Gateway.createBuilder()
            .identity(wallet, "user1")
            .networkConfig(networkConfigPath);
        
        // 连接到网关
        try (Gateway gateway = builder.connect()) {
            // 获取网络
            Network network = gateway.getNetwork("mychannel");
            
            // 获取合约
            Contract contract = network.getContract("mycontract");
            
            // 调用合约
            byte[] result = contract.submitTransaction("createAsset", "asset1", "value1");
            System.out.println("交易结果: " + new String(result));
            
            // 查询合约
            result = contract.evaluateTransaction("readAsset", "asset1");
            System.out.println("查询结果: " + new String(result));
        }
    }
}
```

#### Java与云原生技术

```java
// 使用Quarkus构建云原生应用
import io.quarkus.runtime.Quarkus;
import io.quarkus.runtime.annotations.QuarkusMain;

import javax.enterprise.context.ApplicationScoped;
import javax.inject.Inject;
import javax.ws.rs.*;
import javax.ws.rs.core.MediaType;
import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;

@QuarkusMain
public class CloudNativeApplication {
    public static void main(String[] args) {
        Quarkus.run(args);
    }
}

// 数据模型
class Item {
    private String id;
    private String name;
    private String description;
    
    // 构造函数、getter和setter
    // ...
}

// 服务层
@ApplicationScoped
class ItemService {
    private List<Item> items = new CopyOnWriteArrayList<>();
    
    public List<Item> getAll() {
        return items;
    }
    
    public Item getById(String id) {
        return items.stream()
            .filter(item -> item.getId().equals(id))
            .findFirst()
            .orElse(null);
    }
    
    public void add(Item item) {
        items.add(item);
    }
    
    public boolean update(String id, Item item) {
        for (int i = 0; i < items.size(); i++) {
            if (items.get(i).getId().equals(id)) {
                items.set(i, item);
                return true;
            }
        }
        return false;
    }
    
    public boolean delete(String id) {
        return items.removeIf(item -> item.getId().equals(id));
    }
}

// REST API
@Path("/api/items")
@Produces(MediaType.APPLICATION_JSON)
@Consumes(MediaType.APPLICATION_JSON)
class ItemResource {
    @Inject
    ItemService service;
    
    @GET
    public List<Item> getAll() {
        return service.getAll();
    }
    
    @GET
    @Path("/{id}")
    public Item getById(@PathParam("id") String id) {
        Item item = service.getById(id);
        if (item == null) {
            throw new NotFoundException("Item not found");
        }
        return item;
    }
    
    @POST
    public Item create(Item item) {
        service.add(item);
        return item;
    }
    
    @PUT
    @Path("/{id}")
    public Item update(@PathParam("id") String id, Item item) {
        if (!service.update(id, item)) {
            throw new NotFoundException("Item not found");
        }
        return item;
    }
    
    @DELETE
    @Path("/{id}")
    public void delete(@PathParam("id") String id) {
        if (!service.delete(id)) {
            throw new NotFoundException("Item not found");
        }
    }
}
```

### Java生态系统的可持续发展

Java生态系统的可持续发展依赖于社区参与、企业支持和技术创新。

```java
// Java生态系统可持续发展的关键因素

/*
1. 开源社区参与
   - OpenJDK: https://openjdk.java.net/
   - Jakarta EE: https://jakarta.ee/
   - MicroProfile: https://microprofile.io/
   - Spring: https://spring.io/

2. 企业支持
   - Oracle: 主要JDK提供商
   - Eclipse Foundation: Jakarta EE管理
   - Pivotal/VMware: Spring生态系统
   - Red Hat: Quarkus, WildFly
   - IBM: OpenJ9, WebSphere
   - Amazon: Corretto

3. 教育与培训
   - Oracle认证
   - 在线学习平台
   - 大学课程
   - 技术会议

4. 技术创新
   - GraalVM: 提高性能和多语言支持
   - Loom: 轻量级线程
   - Valhalla: 值类型
   - Panama: 外部函数接口
   - Amber: 语言特性增强

5. 标准化
   - JCP (Java Community Process)
   - JSRs (Java Specification Requests)
   - TCK (Technology Compatibility Kit)

6. 向后兼容性
   - 保持API稳定性
   - 渐进式弃用
   - 迁移工具

7. 性能优化
   - JIT编译器改进
   - GC算法优化
   - 内存管理增强
*/

// Java版本采用示例
public class JavaVersionAdoption {
    public static void main(String[] args) {
        // 获取当前Java版本
        String version = System.getProperty("java.version");
        String vendor = System.getProperty("java.vendor");
        String vmName = System.getProperty("java.vm.name");
        
        System.out.println("Java版本: " + version);
        System.out.println("供应商: " + vendor);
        System.out.println("VM名称: " + vmName);
        
        // 检查是否支持特定特性
        boolean supportsVirtualThreads = false;
        try {
            Class.forName("java.lang.Thread").getMethod("startVirtualThread", Runnable.class);
            supportsVirtualThreads = true;
        } catch (NoSuchMethodException | ClassNotFoundException e) {
            // 不支持虚拟线程
        }
        
        System.out.println("支持虚拟线程: " + supportsVirtualThreads);
        
        // 根据Java版本使用不同的API
        if (Integer.parseInt(version.split("\\.")[0]) >= 17) {
            System.out.println("使用Java 17+特性");
            // 使用Java 17+特性
        } else {
            System.out.println("使用兼容性API");
            // 使用兼容性API
        }
    }
}
```

## 结语

Java作为一种成熟且不断发展的编程语言，已经走过了近30年的历程。从最初的"一次编写，到处运行"的愿景，到如今的企业级应用、云原生、大数据和人工智能领域的广泛应用，Java展现了其强大的生命力和适应性。

Java的成功不仅在于语言本身的设计，还在于其丰富的生态系统、强大的社区支持和持续的创新。随着虚拟线程、模式匹配、记录类等新特性的引入，以及与云原生、人工智能等新兴技术的结合，Java正在迎来新的发展机遇。

对于开发者而言，掌握Java不仅意味着学习一门编程语言，更意味着获得一套完整的解决方案和广阔的职业发展空间。无论是构建企业级应用、开发移动应用、处理大数据还是探索人工智能，Java都能提供强大的支持。

随着技术的不断发展，Java也将继续演进，保持其在编程语言领域的重要地位。我们期待Java在未来能够继续创新，为开发者提供更多可能性，为用户创造更多价值。
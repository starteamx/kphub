---
title: JDK版本演进历程(1.0-21)
icon: versions
order: 3
---

# JDK版本演进历程(1.0-21)

Java语言自1995年首次发布以来，经历了多次重大版本更新，每个版本都为开发者带来了新的特性和改进。本文将详细介绍Java从JDK 1.0到JDK 21的演进历程，帮助读者了解Java语言的发展脉络和技术积累。

## 早期版本(JDK 1.0-1.4)

早期版本奠定了Java的基础架构和核心功能，为后续发展打下了坚实基础。

### JDK 1.0: 初代Java发布(1996)

1996年1月23日，Sun Microsystems公司正式发布了JDK 1.0，这是Java语言的第一个正式版本。JDK 1.0包含了Java语言的基础特性：

- **面向对象编程**：类、接口、继承、多态等面向对象的核心概念
- **Java虚拟机(JVM)**：实现"一次编写，到处运行"的关键技术
- **自动内存管理**：垃圾回收机制，避免手动内存管理的复杂性
- **多线程支持**：内置的线程API，简化并发编程
- **安全模型**：沙箱安全机制，保护系统免受恶意代码攻击
- **Applet技术**：允许Java程序在Web浏览器中运行

JDK 1.0的核心API相对简单，包含约200个类，主要集中在`java.lang`、`java.util`、`java.io`、`java.net`和`java.awt`等包中。

```java
// JDK 1.0中的Hello World示例
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

尽管功能有限，但JDK 1.0展示了Java的核心理念和潜力，吸引了大量开发者的关注。

### JDK 1.1: 内部类、JavaBeans、JDBC等(1997)

1997年2月，JDK 1.1发布，带来了多项重要改进和新特性：

- **内部类(Inner Classes)**：允许在一个类内部定义另一个类，增强了封装性和代码组织能力

```java
public class OuterClass {
    private int outerField = 10;
    
    // 内部类可以访问外部类的私有成员
    class InnerClass {
        public void printOuterField() {
            System.out.println("外部类字段值: " + outerField);
        }
    }
    
    public void createInner() {
        InnerClass inner = new InnerClass();
        inner.printOuterField();
    }
}
```

- **JavaBeans**：组件模型，为可视化开发工具和企业级框架奠定基础

```java
public class PersonBean implements java.io.Serializable {
    private String name;
    private int age;
    
    // 无参构造函数（JavaBeans规范要求）
    public PersonBean() {}
    
    // Getter和Setter方法
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
}
```

- **JDBC(Java Database Connectivity)**：统一的数据库访问API，简化数据库编程

```java
// JDBC示例
Connection conn = DriverManager.getConnection("jdbc:mysql://localhost/test", "user", "password");
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM users");

while (rs.next()) {
    String name = rs.getString("name");
    int age = rs.getInt("age");
    System.out.println("用户: " + name + ", 年龄: " + age);
}

rs.close();
stmt.close();
conn.close();
```

- **Java远程方法调用(RMI)**：允许在不同JVM之间调用方法，支持分布式应用开发
- **反射API**：运行时检查类、接口、字段和方法的能力，为框架开发提供基础
- **国际化支持**：Unicode字符集和Locale类，支持多语言应用开发
- **事件处理模型**：基于委托的事件模型，改进了GUI编程

JDK 1.1显著扩展了Java的功能，特别是在企业级应用开发方面，为Java在服务器端的应用奠定了基础。

### JDK 1.2: Collections框架、JIT编译器(1998)

1998年12月，JDK 1.2发布，这个版本引入了许多重要的改进，Sun公司也将Java平台分为三个版本：J2SE(标准版)、J2EE(企业版)和J2ME(微型版)。主要特性包括：

- **Collections框架**：提供了一套统一的集合接口和实现类，包括List、Set、Map等，大大简化了数据结构的使用

```java
// Collections框架示例
List<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
list.add("C++");

// 排序
Collections.sort(list);

// 遍历
for (String language : list) {
    System.out.println(language);
}

// Map使用
Map<String, Integer> scores = new HashMap<>();
scores.put("Alice", 95);
scores.put("Bob", 85);
scores.put("Charlie", 90);

// 获取值
int aliceScore = scores.get("Alice");
```

- **JIT(Just-In-Time)编译器**：将字节码即时编译为本地机器码，显著提高了Java程序的执行速度
- **Swing GUI工具包**：纯Java实现的GUI组件库，提供了跨平台的图形界面开发能力
- **Java插件**：改进了浏览器中Java Applet的支持
- **strictfp关键字**：确保浮点运算在不同平台上的一致性
- **Java IDL**：支持CORBA(公共对象请求代理架构)，增强了与其他语言的互操作性

JDK 1.2是Java发展的一个重要里程碑，特别是Collections框架的引入，至今仍是Java开发的核心部分。

### JDK 1.3: HotSpot VM、JNDI等(2000)

2000年5月，JDK 1.3发布，这个版本的改进主要集中在性能和稳定性方面：

- **HotSpot虚拟机**：作为默认JVM，HotSpot提供了更好的性能和内存管理
- **JNDI(Java Naming and Directory Interface)**：提供了统一的API来访问各种命名和目录服务

```java
// JNDI示例
InitialContext context = new InitialContext();
// 查找数据源
DataSource dataSource = (DataSource) context.lookup("java:comp/env/jdbc/MyDataSource");
// 获取连接
Connection conn = dataSource.getConnection();
```

- **JavaSound API**：提供了捕获、处理和播放音频数据的能力
- **JPDA(Java Platform Debugger Architecture)**：改进的调试架构，增强了开发工具的能力
- **RMI改进**：支持CORBA的IIOP协议，增强了分布式计算能力

JDK 1.3虽然没有引入太多新的语言特性，但HotSpot VM的引入对Java的性能提升有着重要意义，为Java在企业级应用中的广泛采用奠定了基础。

### JDK 1.4: 正则表达式、NIO、日志API(2002)

2002年2月，JDK 1.4发布，这是Java平台的一次重要更新，引入了多项实用功能：

- **正则表达式**：内置的正则表达式支持，简化了文本处理

```java
// 正则表达式示例
String text = "John's email is john@example.com and Mary's is mary@example.org";
Pattern pattern = Pattern.compile("[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}");
Matcher matcher = pattern.matcher(text);

while (matcher.find()) {
    System.out.println("找到邮箱: " + matcher.group());
}
```

- **NIO(New Input/Output)**：提供了更高效的I/O操作，包括缓冲区、通道和选择器

```java
// NIO示例 - 读取文件
FileChannel channel = new FileInputStream("data.txt").getChannel();
ByteBuffer buffer = ByteBuffer.allocate(1024);
channel.read(buffer);
buffer.flip();

while (buffer.hasRemaining()) {
    System.out.print((char) buffer.get());
}
channel.close();
```

- **日志API**：内置的日志框架，提供了灵活的日志记录能力

```java
// 日志API示例
Logger logger = Logger.getLogger("com.example.app");
logger.setLevel(Level.INFO);

// 添加处理器
ConsoleHandler handler = new ConsoleHandler();
handler.setLevel(Level.ALL);
logger.addHandler(handler);

// 记录日志
logger.info("应用启动");
logger.warning("配置文件不存在，使用默认配置");
```

- **断言(assert)**：用于开发和测试阶段的代码验证
- **XML处理**：JAXP(Java API for XML Processing)，提供了解析和处理XML的能力
- **安全套接字(SSL)**：JSSE(Java Secure Socket Extension)，支持安全网络通信
- **JDBC 3.0**：改进的数据库访问功能，包括连接池和批处理更新

JDK 1.4是Java 1.x系列的最后一个主要版本，它显著增强了Java的功能，特别是在I/O、文本处理和企业级应用方面。

## 成熟期版本(Java 5-8)

成熟期版本为Java带来了现代编程语言的许多重要特性，大幅提高了开发效率和代码质量。

### Java 5: 泛型、注解、枚举、自动装箱/拆箱(2004)

2004年9月，Java 5(内部版本号1.5)发布，这是Java语言自诞生以来最重大的更新之一，引入了多项改变Java编程方式的特性：

- **泛型(Generics)**：类型安全的集合和类型参数化，减少了类型转换和运行时错误

```java
// 泛型示例
// 不使用泛型（Java 5之前）
List list = new ArrayList();
list.add("Hello");
list.add(123); // 可以添加任何类型
String s = (String) list.get(0); // 需要类型转换
// Integer i = (Integer) list.get(0); // 运行时会抛出ClassCastException

// 使用泛型（Java 5及以后）
List<String> stringList = new ArrayList<>();
stringList.add("Hello");
// stringList.add(123); // 编译错误，类型安全
String str = stringList.get(0); // 不需要类型转换
```

- **注解(Annotations)**：代码元数据机制，为框架开发和代码分析提供基础

```java
// 注解定义
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Test {
    String description() default "";
    boolean enabled() default true;
}

// 注解使用
class MyTests {
    @Test(description = "测试加法功能")
    public void testAddition() {
        // 测试代码
    }
    
    @Test(enabled = false)
    public void disabledTest() {
        // 暂时禁用的测试
    }
}
```

- **枚举(Enums)**：类型安全的枚举类型，替代了常量整数的使用

```java
// 枚举示例
enum Day {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;
    
    public boolean isWeekend() {
        return this == SATURDAY || this == SUNDAY;
    }
}

// 使用枚举
Day today = Day.MONDAY;
if (today.isWeekend()) {
    System.out.println("周末愉快!");
} else {
    System.out.println("工作日加油!");
}
```

- **自动装箱/拆箱(Autoboxing/Unboxing)**：基本类型和包装类型之间的自动转换

```java
// 自动装箱/拆箱示例
// 自动装箱
Integer i = 10; // 自动将int装箱为Integer

// 自动拆箱
int j = i; // 自动将Integer拆箱为int

// 在集合中使用
List<Integer> numbers = new ArrayList<>();
numbers.add(5); // 自动装箱
int sum = 0;
for (Integer n : numbers) {
    sum += n; // 自动拆箱
}
```

- **可变参数(Varargs)**：方法参数数量可变

```java
// 可变参数示例
public static int sum(int... numbers) {
    int total = 0;
    for (int num : numbers) {
        total += num;
    }
    return total;
}

// 调用
int result1 = sum(1, 2, 3);
int result2 = sum(10, 20, 30, 40, 50);
```

- **增强for循环(Enhanced for loop)**：简化集合和数组的遍历

```java
// 增强for循环示例
// 数组遍历
int[] numbers = {1, 2, 3, 4, 5};
for (int num : numbers) {
    System.out.println(num);
}

// 集合遍历
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
for (String name : names) {
    System.out.println(name);
}
```

- **静态导入(Static Import)**：直接访问静态成员，无需类名限定

```java
// 静态导入示例
import static java.lang.Math.PI;
import static java.lang.Math.sqrt;

// 使用
double area = PI * radius * radius;
double length = sqrt(x * x + y * y);
```

- **并发工具(java.util.concurrent)**：提供了高级并发编程工具，如线程池、并发集合、原子变量等

Java 5的这些特性极大地改进了Java的表达能力和类型安全性，使Java成为一种更现代、更高效的编程语言。这些特性至今仍是Java开发的核心部分。

### Java 6: 性能优化、脚本语言支持(2006)

2006年12月，Java 6(内部版本号1.6)发布，这个版本主要关注性能优化和开发工具改进，而不是语言特性的增加：

- **性能优化**：改进的JVM性能，包括更快的启动时间、更低的内存占用和更好的垃圾回收
- **脚本语言支持**：通过JSR 223(Scripting for the Java Platform)，支持在Java应用中嵌入JavaScript等脚本语言

```java
// 脚本语言支持示例
ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName("JavaScript");

// 执行JavaScript代码
engine.eval("print('Hello from JavaScript!')");

// 在Java和JavaScript之间传递变量
engine.put("x", 10);
engine.put("y", 20);
engine.eval("var sum = x + y; print('Sum: ' + sum);");

// 获取JavaScript变量
engine.eval("var result = x * y;");
Object result = engine.get("result");
System.out.println("JavaScript计算结果: " + result);
```

- **JDBC 4.0**：改进的数据库访问，包括自动驱动加载和更好的异常处理
- **Java编译器API**：允许程序以编程方式访问Java编译器
- **Swing改进**：新的Look and Feel和SwingWorker类，改进了GUI开发体验
- **Web服务支持**：内置的JAX-WS 2.0和JAXB 2.0，简化了Web服务的开发
- **诊断和监控工具**：Java VisualVM等工具，帮助开发者分析和监控Java应用

Java 6虽然没有引入太多新的语言特性，但其性能优化和工具改进使Java平台更加成熟和稳定，为企业级应用提供了更好的支持。

### Java 7: Try-with-resources、Diamond操作符(2011)

2011年7月，Java 7(内部版本号1.7)发布，这是Oracle收购Sun后发布的第一个主要Java版本。Java 7引入了一些语言改进和新功能：

- **Try-with-resources**：自动资源管理，简化了I/O操作中的资源关闭

```java
// Try-with-resources示例
// Java 7之前
BufferedReader reader = null;
try {
    reader = new BufferedReader(new FileReader("data.txt"));
    String line = reader.readLine();
    System.out.println(line);
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (reader != null) {
        try {
            reader.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

// Java 7及以后
try (BufferedReader reader = new BufferedReader(new FileReader("data.txt"))) {
    String line = reader.readLine();
    System.out.println(line);
} catch (IOException e) {
    e.printStackTrace();
}
```

- **Diamond操作符**：类型推断，简化泛型代码

```java
// Diamond操作符示例
// Java 7之前
Map<String, List<String>> map = new HashMap<String, List<String>>();

// Java 7及以后
Map<String, List<String>> map = new HashMap<>(); // 编译器自动推断类型
```

- **多重捕获异常**：在一个catch块中捕获多种异常类型

```java
// 多重捕获异常示例
// Java 7之前
try {
    // 可能抛出多种异常的代码
} catch (IOException e) {
    // 处理IOException
    e.printStackTrace();
} catch (SQLException e) {
    // 处理SQLException
    e.printStackTrace();
}

// Java 7及以后
try {
    // 可能抛出多种异常的代码
} catch (IOException | SQLException e) {
    // 同时处理两种异常
    e.printStackTrace();
}
```

- **字符串在switch语句中的使用**：允许在switch语句中使用字符串

```java
// 字符串switch示例
String day = "MONDAY";
switch (day) {
    case "MONDAY":
        System.out.println("星期一");
        break;
    case "TUESDAY":
        System.out.println("星期二");
        break;
    // 其他情况
    default:
        System.out.println("其他日子");
}
```

- **数字字面量改进**：支持二进制字面量和数字分隔符

```java
// 数字字面量改进示例
// 二进制字面量
int binary = 0b1010; // 二进制表示10

// 数字分隔符
int million = 1_000_000; // 更易读的数字表示
long creditCardNumber = 1234_5678_9012_3456L;
```

- **NIO 2.0(JSR 203)**：全新的文件系统API，提供了更强大的文件操作能力

```java
// NIO 2.0文件操作示例
// 读取文件
Path path = Paths.get("data.txt");
List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8);

// 写入文件
Path outputPath = Paths.get("output.txt");
Files.write(outputPath, lines, StandardCharsets.UTF_8);

// 目录遍历
try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get("."))) {
    for (Path entry : stream) {
        System.out.println(entry.getFileName());
    }
}
```

- **Fork/Join框架**：用于并行执行任务的框架，提高多核处理器上的性能

```java
// Fork/Join框架示例
class SumTask extends RecursiveTask<Long> {
    private static final int THRESHOLD = 1000;
    private int[] array;
    private int start;
    private int end;
    
    public SumTask(int[] array, int start, int end) {
        this.array = array;
        this.start = start;
        this.end = end;
    }
    
    @Override
    protected Long compute() {
        if (end - start <= THRESHOLD) {
            // 小任务直接计算
            long sum = 0;
            for (int i = start; i < end; i++) {
                sum += array[i];
            }
            return sum;
        } else {
            // 大任务分解为小任务
            int middle = (start + end) / 2;
            SumTask leftTask = new SumTask(array, start, middle);
            SumTask rightTask = new SumTask(array, middle, end);
            
            leftTask.fork(); // 异步执行左任务
            long rightResult = rightTask.compute(); // 同步执行右任务
            long leftResult = leftTask.join(); // 等待左任务结果
            
            return leftResult + rightResult;
        }
    }
}

// 使用Fork/Join框架
int[] array = new int[10000];
// 初始化数组...
ForkJoinPool pool = new ForkJoinPool();
long sum = pool.invoke(new SumTask(array, 0, array.length));
```

Java 7的这些改进使Java编程更加简洁和高效，特别是在处理I/O和并发编程方面。

### Java 8: Lambda表达式、Stream API、新日期时间API(2014)

2014年3月，Java 8(内部版本号1.8)发布，这是Java自Java 5以来最具革命性的版本，引入了函数式编程特性和其他重要改进：

- **Lambda表达式**：支持将函数作为方法参数传递，简化了匿名内部类的使用

```java
// Lambda表达式示例
// Java 8之前（使用匿名内部类）
button.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("按钮被点击");
    }
});

// Java 8及以后（使用Lambda表达式）
button.addActionListener(e -> System.out.println("按钮被点击"));

// 带参数的Lambda
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");
Collections.sort(names, (a, b) -> a.compareToIgnoreCase(b));

// 多行Lambda
Runnable task = () -> {
    System.out.println("任务开始");
    performTask();
    System.out.println("任务完成");
};
```

- **方法引用**：更简洁地引用已有方法

```java
// 方法引用示例
// 静态方法引用
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);
numbers.forEach(System.out::println);

// 实例方法引用
String[] names = {"Alice", "Bob", "Charlie"};
Arrays.sort(names, String::compareToIgnoreCase);

// 构造函数引用
List<String> strings = Arrays.asList("a", "b", "c");
List<StringBuilder> builders = strings.stream()
    .map(StringBuilder::new)
    .collect(Collectors.toList());
```

- **Stream API**：支持对集合进行函数式操作，如过滤、映射、归约等

```java
// Stream API示例
List<Person> persons = Arrays.asList(
    new Person("Alice", 25),
    new Person("Bob", 30),
    new Person("Charlie", 35),
    new Person("David", 40)
);

// 过滤和映射
List<String> names = persons.stream()
    .filter(p -> p.getAge() > 30)
    .map(Person::getName)
    .collect(Collectors.toList());

// 统计
double averageAge = persons.stream()
    .mapToInt(Person::getAge)
    .average()
    .orElse(0);

// 分组
Map<Integer, List<Person>> personsByAge = persons.stream()
    .collect(Collectors.groupingBy(Person::getAge));

// 并行处理
long count = persons.parallelStream()
    .filter(p -> p.getAge() > 30)
    .count();
```

- **新日期时间API(java.time)**：解决了旧日期API的设计缺陷，提供了不可变的日期时间类

```java
// 新日期时间API示例
// 创建日期
LocalDate today = LocalDate.now();
LocalDate birthday = LocalDate.of(1990, Month.JANUARY, 1);

// 日期计算
LocalDate nextWeek = today.plusWeeks(1);
LocalDate lastMonth = today.minusMonths(1);

// 日期比较
boolean isBefore = birthday.isBefore(today);
Period period = Period.between(birthday, today);
System.out.println("年龄: " + period.getYears() + "年");

// 时间操作
LocalTime now = LocalTime.now();
LocalTime bedtime = LocalTime.of(23, 0);
Duration timeUntilBed = Duration.between(now, bedtime);
System.out.println("距离睡觉时间: " + timeUntilBed.toHours() + "小时");

// 日期时间组合
LocalDateTime dateTime = LocalDateTime.of(today, now);
ZonedDateTime zonedDateTime = ZonedDateTime.of(dateTime, ZoneId.of("Asia/Shanghai"));
```

- **接口默认方法和静态方法**：允许在接口中定义默认实现和静态方法

```java
// 接口默认方法和静态方法示例
interface Vehicle {
    // 抽象方法
    void start();
    
    // 默认方法
    default void honk() {
        System.out.println("喇叭声!");
    }
    
    // 静态方法
    static Vehicle createElectricVehicle() {
        return new ElectricCar();
    }
}

class Car implements Vehicle {
    @Override
    public void start() {
        System.out.println("汽车启动");
    }
    
    // 可以选择性地覆盖默认方法
    @Override
    public void honk() {
        System.out.println("汽车喇叭声!");
    }
}
```

- **Optional类**：更优雅地处理空值，避免NullPointerException

```java
// Optional示例
// 创建Optional
Optional<String> optional = Optional.of("Hello");
Optional<String> empty = Optional.empty();

// 检查值是否存在
if (optional.isPresent()) {
    System.out.println("值存在: " + optional.get());
}

// 使用默认值
String result = empty.orElse("默认值");

// 条件执行
optional.ifPresent(s -> System.out.println("值存在: " + s));

// 转换值
Optional<Integer> length = optional.map(String::length);

// 链式调用
String name = Optional.ofNullable(getUser())
    .map(User::getAddress)
    .map(Address::getCity)
    .orElse("未知城市");
```

- **CompletableFuture**：增强的Future API，支持组合异步操作

```java
// CompletableFuture示例
// 创建异步任务
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    // 模拟长时间运行的任务
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    return "任务结果";
});

// 添加回调
future.thenAccept(result -> System.out.println("获得结果: " + result));

// 转换结果
CompletableFuture<Integer> lengthFuture = future.thenApply(String::length);

// 组合多个Future
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> "Hello");
CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> "World");

CompletableFuture<String> combined = future1.thenCombine(future2, (s1, s2) -> s1 
让我继续完成Java 8的特性介绍，然后继续讲解现代Java版本和最新发展。

```java
// CompletableFuture示例（续）
CompletableFuture<String> combined = future1.thenCombine(future2, (s1, s2) -> s1 + " " + s2);
combined.thenAccept(System.out::println); // 输出: Hello World

// 异常处理
CompletableFuture<String> failedFuture = CompletableFuture.supplyAsync(() -> {
    throw new RuntimeException("计算失败");
});

failedFuture.exceptionally(ex -> "错误: " + ex.getMessage())
           .thenAccept(System.out::println);
```

- **Nashorn JavaScript引擎**：替代了旧的Rhino引擎，提供了更好的JavaScript执行性能

```java
// Nashorn JavaScript引擎示例
ScriptEngineManager manager = new ScriptEngineManager();
ScriptEngine engine = manager.getEngineByName("nashorn");

// 执行JavaScript代码
engine.eval("print('Hello from Nashorn!')");

// 在JavaScript中调用Java方法
engine.eval("var ArrayList = Java.type('java.util.ArrayList');" +
            "var list = new ArrayList();" +
            "list.add('Item 1');" +
            "list.add('Item 2');" +
            "print(list.size());");
```

Java 8的这些特性，特别是Lambda表达式和Stream API，彻底改变了Java编程的风格，使Java更加现代化，并引入了函数式编程的概念。这个版本被认为是Java历史上最重要的版本之一，至今仍被广泛使用。

## 现代Java版本(Java 9-17)

从Java 9开始，Oracle采用了新的发布模式，每六个月发布一个新版本，并且每三年发布一个长期支持(LTS)版本。这一时期的Java版本引入了许多现代化特性。

### Java 9: 模块系统、JShell、集合工厂方法(2017)

2017年9月，Java 9发布，引入了几项重要的新特性：

- **模块系统(Project Jigsaw)**：Java平台模块系统(JPMS)，允许开发者将应用程序和库打包为模块，并明确声明依赖关系

```java
// module-info.java文件示例
module com.example.myapp {
    // 依赖的模块
    requires java.base; // 隐式依赖，可以省略
    requires java.sql;
    requires transitive java.logging; // 传递依赖
    
    // 导出的包
    exports com.example.myapp.api;
    exports com.example.myapp.util to com.example.othermodule; // 限制导出
    
    // 使用的服务
    uses com.example.myapp.spi.MyService;
    
    // 提供的服务实现
    provides com.example.myapp.spi.MyService with com.example.myapp.impl.MyServiceImpl;
}
```

- **JShell**：Java的交互式REPL(Read-Eval-Print Loop)工具，方便快速测试Java代码片段

```
// JShell使用示例（在命令行中）
$ jshell
| Welcome to JShell -- Version 9
| For an introduction type: /help intro

jshell> int x = 10
x ==> 10

jshell> int y = 20
y ==> 20

jshell> x + y
$3 ==> 30

jshell> String greeting = "Hello, JShell!"
greeting ==> "Hello, JShell!"

jshell> greeting.toUpperCase()
$5 ==> "HELLO, JSHELL!"

jshell> /exit
| Goodbye
```

- **集合工厂方法**：创建不可变集合的便捷方法

```java
// 集合工厂方法示例
// 不可变List
List<String> list = List.of("a", "b", "c");

// 不可变Set
Set<Integer> set = Set.of(1, 2, 3);

// 不可变Map
Map<String, Integer> map = Map.of(
    "one", 1,
    "two", 2,
    "three", 3
);

// 更多键值对的Map
Map<String, Integer> largeMap = Map.ofEntries(
    Map.entry("one", 1),
    Map.entry("two", 2),
    Map.entry("three", 3),
    Map.entry("four", 4)
);
```

- **私有接口方法**：允许在接口中定义私有方法，进一步提高代码复用

```java
// 私有接口方法示例
interface Logger {
    void log(String message);
    
    default void logInfo(String message) {
        log(addSeverity("INFO", message));
    }
    
    default void logWarning(String message) {
        log(addSeverity("WARNING", message));
    }
    
    // 私有接口方法，供默认方法使用
    private String addSeverity(String severity, String message) {
        return "[" + severity + "] " + message;
    }
}
```

- **改进的Stream API**：新增了takeWhile、dropWhile、iterate等方法

```java
// 改进的Stream API示例
// takeWhile: 获取元素直到条件不满足
List<Integer> numbers = List.of(2, 4, 6, 8, 9, 10, 12);
List<Integer> evenNumbersUntilOdd = numbers.stream()
    .takeWhile(n -> n % 2 == 0)
    .collect(Collectors.toList()); // [2, 4, 6, 8]

// dropWhile: 丢弃元素直到条件不满足
List<Integer> numbersStartingFromOdd = numbers.stream()
    .dropWhile(n -> n % 2 == 0)
    .collect(Collectors.toList()); // [9, 10, 12]

// iterate方法的重载版本，支持终止条件
Stream<Integer> stream = Stream.iterate(1, n -> n <= 10, n -> n + 1);
stream.forEach(System.out::println); // 打印1到10
```

- **HTTP/2客户端API(孵化器)**：新的HTTP客户端API，支持HTTP/2
- **多版本兼容JAR**：允许一个JAR文件包含针对不同Java版本的类文件
- **G1作为默认垃圾收集器**：G1(Garbage-First)垃圾收集器成为默认选项，提供更好的性能

Java 9的模块系统是一个重大变化，它改变了Java平台的结构，使其更加模块化和可维护。

### Java 10: 局部变量类型推断(var)(2018)

2018年3月，Java 10发布，这是第一个遵循新的六个月发布周期的版本。主要特性包括：

- **局部变量类型推断(var)**：允许使用var关键字进行局部变量类型推断，减少冗余代码

```java
// 局部变量类型推断示例
// Java 10之前
String message = "Hello, Java 10";
ArrayList<String> list = new ArrayList<>();
Map<String, Integer> map = new HashMap<>();

// Java 10及以后
var message = "Hello, Java 10"; // 推断为String
var list = new ArrayList<String>(); // 推断为ArrayList<String>
var map = new HashMap<String, Integer>(); // 推断为HashMap<String, Integer>

// 在for循环中使用
for (var i = 0; i < 10; i++) {
    System.out.println(i);
}

// 使用var接收方法返回值
var result = getComplexResult();

// var的限制
// var不能用于字段
// var不能用于方法参数
// var不能用于方法返回类型
// var不能用于没有初始化器的变量
// var不能赋值为null
```

- **垃圾收集器改进**：并行全垃圾收集器的改进，G1垃圾收集器的性能优化
- **应用类数据共享**：扩展了类数据共享功能，减少了内存占用和启动时间
- **线程本地握手**：一种在不执行全局VM安全点的情况下执行线程回调的方式
- **根证书**：在JDK中包含一组默认的根证书
- **基于时间的发布版本控制**：新的版本号格式，如10.0.1，表示主版本、次版本和安全补丁级别

Java 10虽然是一个短期支持版本，但局部变量类型推断(var)是一个重要的语言特性，它使Java代码更加简洁。

### Java 11: HTTP客户端API、String新方法(2018)

2018年9月，Java 11发布，这是Java 8之后的第一个长期支持(LTS)版本。主要特性包括：

- **标准化HTTP客户端API**：将Java 9中引入的孵化HTTP客户端API标准化

```java
// HTTP客户端API示例
// 创建HTTP客户端
HttpClient client = HttpClient.newHttpClient();

// 构建请求
HttpRequest request = HttpRequest.newBuilder()
    .uri(URI.create("https://api.example.com/data"))
    .header("Content-Type", "application/json")
    .GET()
    .build();

// 发送同步请求
HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
System.out.println("状态码: " + response.statusCode());
System.out.println("响应体: " + response.body());

// 发送异步请求
client.sendAsync(request, HttpResponse.BodyHandlers.ofString())
    .thenApply(HttpResponse::body)
    .thenAccept(System.out::println)
    .join();

// POST请求示例
HttpRequest postRequest = HttpRequest.newBuilder()
    .uri(URI.create("https://api.example.com/submit"))
    .header("Content-Type", "application/json")
    .POST(HttpRequest.BodyPublishers.ofString("{\"name\":\"John\",\"age\":30}"))
    .build();

HttpResponse<String> postResponse = client.send(postRequest, HttpResponse.BodyHandlers.ofString());
```

- **String新方法**：增加了strip()、isBlank()、lines()等方法

```java
// String新方法示例
String text = "  Hello, Java 11!  ";

// strip()方法：去除首尾空白，支持Unicode空白字符
String stripped = text.strip(); // "Hello, Java 11!"

// stripLeading()和stripTrailing()：分别去除首部和尾部空白
String leadingStripped = text.stripLeading(); // "Hello, Java 11!  "
String trailingStripped = text.stripTrailing(); // "  Hello, Java 11!"

// isBlank()：检查字符串是否为空或仅包含空白字符
boolean blank = "   ".isBlank(); // true

// lines()：将字符串分割为行流
String multiline = "Line 1\nLine 2\nLine 3";
multiline.lines().forEach(System.out::println);

// repeat()：重复字符串指定次数
String repeated = "Java".repeat(3); // "JavaJavaJava"
```

- **Lambda参数的局部变量语法**：允许在Lambda表达式的参数中使用var

```java
// Lambda参数的局部变量语法示例
// Java 10
Consumer<String> consumer = (var s) -> System.out.println(s.toUpperCase());

// 使用注解
Consumer<String> annotatedConsumer = (@NotNull var s) -> System.out.println(s.toUpperCase());
```

- **ZGC(实验性)**：可扩展的低延迟垃圾收集器
- **Flight Recorder**：用于收集诊断和分析数据的工具
- **Epsilon GC**：一个不执行任何垃圾回收的GC实现，用于性能测试和短生命周期应用
- **移除Java EE和CORBA模块**：这些模块在Java 9中已被标记为废弃
- **支持TLS 1.3**：增强了安全性和性能

Java 11作为LTS版本，被广泛采用，特别是在企业环境中。

### Java 14-16: Records、Pattern Matching、Sealed Classes(2020-2021)

在Java 14到16这几个版本中，引入了一些重要的预览特性，这些特性在后续版本中得到了完善和正式发布：

- **Records(Java 14预览，Java 16正式)**：简化数据类的定义，自动生成构造函数、getter、equals、hashCode和toString方法

```java
// Records示例
// 传统的数据类
class PersonOld {
    private final String name;
    private final int age;
    
    public PersonOld(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    public String getName() { return name; }
    public int getAge() { return age; }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        PersonOld person = (PersonOld) o;
        return age == person.age && Objects.equals(name, person.name);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
    
    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}

// 使用Record（Java 16及以后）
record Person(String name, int age) {
    // 所有上面的方法都自动生成
    
    // 可以添加自定义方法
    public boolean isAdult() {
        return age >= 18;
    }
    
    // 可以自定义紧凑构造函数
    public Person {
        if (age < 0) {
            throw new IllegalArgumentException("年龄不能为负数");
        }
    }
    
    // 可以添加静态字段和方法
    public static final int MINIMUM_AGE = 0;
    
    public static Person createAdult(String name) {
        return new Person(name, 18);
    }
}

// 使用Record
Person person = new Person("Alice", 30);
String name = person.name(); // 使用自动生成的访问器
int age = person.age();
System.out.println(person); // 自动生成的toString
```

- **Pattern Matching for instanceof(Java 14预览，Java 16正式)**：简化类型检查和转换

```java
// Pattern Matching for instanceof示例
// 传统方式
if (obj instanceof String) {
    String s = (String) obj;
    if (s.length() > 5) {
        System.out.println(s.toUpperCase());
    }
}

// 使用Pattern Matching（Java 16及以后）
if (obj instanceof String s && s.length() > 5) {
    System.out.println(s.toUpperCase());
}
```

- **Sealed Classes(Java 15预览，Java 17正式)**：限制哪些类可以继承一个类或实现一个接口

```java
// Sealed Classes示例
// 密封接口
sealed interface Shape permits Circle, Rectangle, Triangle {
    double area();
}

// 允许的实现类
final class Circle implements Shape {
    private final double radius;
    
    Circle(double radius) {
        this.radius = radius;
    }
    
    @Override
    public double area() {
        return Math.PI * radius * radius;
    }
}

final class Rectangle implements Shape {
    private final double width;
    private final double height;
    
    Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double area() {
        return width * height;
    }
}

// 密封类可以被non-sealed类继承，允许进一步继承
non-sealed class Triangle implements Shape {
    private final double base;
    private final double height;
    
    Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }
    
    @Override
    public double area() {
        return 0.5 * base * height;
    }
}

// 使用密封类进行模式匹配
static double calculateArea(Shape shape) {
    return switch (shape) {
        case Circle c -> Math.PI * c.radius * c.radius;
        case Rectangle r -> r.width * r.height;
        case Triangle t -> 0.5 * t.base * t.height;
    };
}
```

- **Text Blocks(Java 13预览，Java 15正式)**：多行字符串字面量，简化HTML、JSON等多行文本的表示

```java
// Text Blocks示例
// 传统字符串连接
String json = "{\n" +
              "  \"name\": \"John\",\n" +
              "  \"age\": 30,\n" +
              "  \"address\": {\n" +
              "    \"street\": \"Main St\",\n" +
              "    \"city\": \"New York\"\n" +
              "  }\n" +
              "}";

// 使用Text Blocks（Java 15及以后）
String jsonTextBlock = """
    {
      "name": "John",
      "age": 30,
      "address": {
        "street": "Main St",
        "city": "New York"
      }
    }
    """;

// HTML示例
String html = """
    <html>
        <body>
            <h1>Hello, World!</h1>
        </body>
    </html>
    """;

// 使用\表示行连续
String query = """
    SELECT id, name, email \
    FROM users \
    WHERE active = true \
    ORDER BY name
    """;
```

- **Switch表达式(Java 12预览，Java 14正式)**：增强的switch语句，可以作为表达式使用，并支持箭头语法

```java
// Switch表达式示例
// 传统switch语句
String dayType;
switch (day) {
    case "MONDAY":
    case "TUESDAY":
    case "WEDNESDAY":
    case "THURSDAY":
    case "FRIDAY":
        dayType = "工作日";
        break;
    case "SATURDAY":
    case "SUNDAY":
        dayType = "周末";
        break;
    default:
        dayType = "未知";
}

// 使用Switch表达式（Java 14及以后）
String dayTypeNew = switch (day) {
    case "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY" -> "工作日";
    case "SATURDAY", "SUNDAY" -> "周末";
    default -> "未知";
};

// 使用代码块和yield
int numLetters = switch (day) {
    case "MONDAY", "FRIDAY", "SUNDAY" -> {
        System.out.println("六个字母");
        yield 6;
    }
    case "TUESDAY" -> {
        System.out.println("七个字母");
        yield 7;
    }
    case "THURSDAY", "SATURDAY" -> {
        System.out.println("八个字母");
        yield 8;
    }
    case "WEDNESDAY" -> {
        System.out.println("九个字母");
        yield 9;
    }
    default -> {
        System.out.println("未知天数");
        yield -1;
    }
};
```

这些版本还包含其他一些特性和改进：

- **Helpful NullPointerExceptions**：更详细的空指针异常信息，帮助定位问题
- **Foreign-Memory Access API(孵化器)**：安全高效地访问Java堆外内存
- **Vector API(孵化器)**：利用CPU的SIMD指令进行向量计算
- **JFR Event Streaming**：允许持续监控Java Flight Recorder事件
- **ZGC改进**：并发类卸载、取消未使用内存等功能
- **Shenandoah GC**：低暂停时间垃圾收集器

### Java 17: LTS版本、模式匹配增强(2021)

2021年9月，Java 17发布，这是Java 11之后的第二个长期支持(LTS)版本。主要特性包括：

- **密封类(Sealed Classes)正式版**：如前所述，限制哪些类可以继承一个类或实现一个接口
- **模式匹配for switch(预览)**：在switch表达式中使用模式匹配

```java
// 模式匹配for switch预览示例
static String formatter(Object obj) {
    return switch (obj) {
        case Integer i -> String.format("int %d", i);
        case Long l -> String.format("long %d", l);
        case Double d -> String.format("double %f", d);
        case String s -> String.format("String %s", s);
        case null -> "null";
        default -> obj.toString();
    };
}
```

- **恢复始终严格的浮点语义**：恢复了Java 1.2之前的严格浮点计算
- **增强的伪随机数生成器**：提供了新的伪随机数生成器接口和实现

```java
// 增强的伪随机数生成器示例
// 创建随机数生成器
RandomGenerator generator = RandomGenerator.of("L64X128MixRandom");

// 生成随机数
int randomInt = generator.nextInt();
double randomDouble = generator.nextDouble();

// 生成指定范围的随机数
int randomInRange = generator.nextInt(1, 101); // 1到100之间的随机数

// 创建随机数流
IntStream randomInts = generator.ints(10); // 10个随机整数
```

- **新的macOS渲染管线**：基于Apple Metal API的新渲染管线，替代了已弃用的OpenGL
- **外部函数和内存API(孵化器)**：简化了Java代码调用本地代码和访问外部内存的方式
- **Vector API(第二次孵化)**：向量计算API的改进版本
- **上下文特定的反序列化过滤器**：增强了反序列化的安全性
- **弃用安全管理器以待将来移除**：安全管理器在未来版本中将被移除

Java 17作为LTS版本，被广泛采用，特别是在企业环境中。它包含了Java 11以来的所有改进，并提供了长期支持。

## 最新发展(Java 18-21)

最新的Java版本引入了一些革命性的特性，特别是在并发编程和语言表达能力方面。

### Java 18-20: 虚拟线程预览、结构化并发(2022-2023)

Java 18到20是短期支持版本，引入了一些重要的预览特性：

- **虚拟线程(预览)**：轻量级线程实现，显著提高了并发应用的吞吐量

```java
// 虚拟线程预览示例
// 创建单个虚拟线程
Thread vThread = Thread.startVirtualThread(() -> {
    System.out.println("在虚拟线程中运行");
    try {
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    System.out.println("虚拟线程完成");
});

// 等待虚拟线程完成
vThread.join();

// 创建大量虚拟线程
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    // 提交1000个任务，每个任务在单独的虚拟线程中执行
    for (int i = 0; i < 1000; i++) {
        int taskId = i;
        executor.submit(() -> {
            // 模拟I/O操作
            try {
                Thread.sleep(100);
                System.out.println("任务 " + taskId + " 完成");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            return taskId;
        });
    }
    // executor关闭时会等待所有任务完成
}
```

- **结构化并发(预览)**：简化多线程编程，确保线程安全和资源管理

```java
// 结构化并发预览示例
void fetchUserData() throws Exception {
    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
        // 并行获取用户信息和订单
        Future<UserInfo> userInfoFuture = scope.fork(() -> fetchUserInfo(userId));
        Future<List<Order>> ordersFuture = scope.fork(() -> fetchUserOrders(userId));
        
        // 等待所有任务完成或有任务失败
        scope.join();
        // 如果有任务失败，抛出异常
        scope.throwIfFailed();
        
        // 处理结果
        UserInfo userInfo = userInfoFuture.resultNow();
        List<Order> orders = ordersFuture.resultNow();
        
        // 使用获取的数据
        displayUserData(userInfo, orders);
    }
}
```

- **模式匹配for switch(第二次预览)**：switch表达式和语句的模式匹配增强
- **Record模式(预览)**：在模式匹配中使用record进行解构

```java
// Record模式预览示例
record Point(int x, int y) {}
record Rectangle(Point upperLeft, Point lowerRight) {}
record Circle(Point center, int radius) {}

static void printShape(Object shape) {
    switch (shape) {
        case Rectangle(Point(var x1, var y1), Point(var x2, var y2)) ->
            System.out.printf("矩形从(%d,%d)到(%d,%d)%n", x1, y1, x2, y2);
        case Circle(Point(var x, var y), var r) ->
            System.out.printf("圆心在(%d,%d)，半径为%d%n", x, y, r);
        default ->
            System.out.println("未知形状");
    }
}
```

- **外部函数和内存API(第二次孵化)**：改进的本地代码调用和外部内存访问
- **Vector API(第四次孵化)**：向量计算API的进一步改进
- **外部链接器API(孵化器)**：简化了与本地代码的互操作
- **字符串模板(预览)**：字符串插值和处理的新机制

```java
// 字符串模板预览示例
String name = "Alice";
int age = 30;

// 基本字符串模板
String message = STR."Hello, \{name}! You are \{age} years old.";

// 格式化字符串模板
String formatted = FMT."Name: \{name}, Age: \{age}, Balance: \{balance:%.2f}";

// 自定义模板处理器
String json = JSON."""
    {
      "name": "\{name}",
      "age": \{age},
      "isAdult": \{age >= 18}
    }
    """;
```

### Java 21: 虚拟线程正式版、记录模式、字符串模板(2023)

2023年9月，Java 21发布，这是Java 17之后的第三个长期支持(LTS)版本。主要特性包括：

- **虚拟线程(正式版)**：轻量级线程实现，显著提高了并发应用的吞吐量

```java
// 虚拟线程正式版示例
// 创建和启动虚拟线程
Thread.startVirtualThread(() -> {
    System.out.println("虚拟线程正在执行");
});

// 使用ExecutorService
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    IntStream.range(0, 10_000).forEach(i -> {
        executor.submit(() -> {
            // 任务代码
            Thread.sleep(Duration.ofMillis(100));
            return i;
        });
    });
}

// 虚拟线程与平台线程的比较
// 平台线程（传统线程）
try (var executor = Executors.newFixedThreadPool(100)) { // 最多100个并发线程
    // 提交任务...
}

// 虚拟线程（可以创建数百万个）
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
    // 提交数百万个任务，每个任务一个虚拟线程
}
```

- **记录模式(正式版)**：在模式匹配中使用record进行解构
- **模式匹配for switch(正式版)**：switch表达式和语句的模式匹配增强

```java
// 模式匹配for switch正式版示例
static String describeShape(Shape shape) {
    return switch (shape) {
        case Circle c -> "圆，半径 = " + c.radius();
        case Rectangle r when r.width() == r.height() -> "正方形，边长 = " + r.width();
        case Rectangle r -> "矩形，宽 = " + r.width() + ", 高 = " + r.height();
让我继续完成Java 21的特性介绍：

```java
// 模式匹配for switch正式版示例（续）
static String describeShape(Shape shape) {
    return switch (shape) {
        case Circle c -> "圆，半径 = " + c.radius();
        case Rectangle r when r.width() == r.height() -> "正方形，边长 = " + r.width();
        case Rectangle r -> "矩形，宽 = " + r.width() + ", 高 = " + r.height();
        case Triangle t -> "三角形，底 = " + t.base() + ", 高 = " + t.height();
        case null -> "空值";
        default -> "未知形状";
    };
}

// 记录模式正式版示例
record Point(int x, int y) {}
record ColoredPoint(Point p, Color c) {}

// 使用记录模式进行解构
static void printColoredPoint(Object obj) {
    if (obj instanceof ColoredPoint(Point(var x, var y), var color)) {
        System.out.println("彩色点在坐标(" + x + "," + y + ")，颜色为" + color);
    }
}
```

- **字符串模板(正式版)**：字符串插值和处理的新机制

```java
// 字符串模板正式版示例
String name = "张三";
int age = 30;
double salary = 12345.67;

// 基本字符串模板
String message = STR."您好，\{name}！您今年\{age}岁。";

// 格式化字符串模板
String formatted = STR."姓名: \{name}\n年龄: \{age}\n薪资: \{salary}元";

// 使用表达式
String status = STR."状态: \{age >= 18 ? "成年" : "未成年"}";

// 多行字符串模板
String html = STR."""
    <html>
        <body>
            <h1>用户信息</h1>
            <p>姓名: \{name}</p>
            <p>年龄: \{age}</p>
            <p>薪资: \{String.format("%.2f", salary)}元</p>
        </body>
    </html>
    """;

// 格式化模板处理器
String formattedCurrency = FMT."薪资: \{salary;%.2f}元";
```

- **结构化并发(正式版)**：简化多线程编程，确保线程安全和资源管理

```java
// 结构化并发正式版示例
public class StructuredConcurrencyExample {
    public static void main(String[] args) throws Exception {
        // 获取用户数据并显示
        UserData userData = fetchUserData(100);
        System.out.println("用户信息: " + userData.userInfo());
        System.out.println("订单数量: " + userData.orders().size());
    }
    
    record UserData(UserInfo userInfo, List<Order> orders) {}
    record UserInfo(int id, String name, String email) {}
    record Order(int id, String product, double price) {}
    
    static UserData fetchUserData(int userId) throws Exception {
        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
            // 并行获取用户信息和订单
            Future<UserInfo> userInfoFuture = scope.fork(() -> fetchUserInfo(userId));
            Future<List<Order>> ordersFuture = scope.fork(() -> fetchUserOrders(userId));
            
            // 等待所有任务完成或有任务失败
            scope.join();
            // 如果有任务失败，抛出异常
            scope.throwIfFailed();
            
            // 处理结果
            UserInfo userInfo = userInfoFuture.resultNow();
            List<Order> orders = ordersFuture.resultNow();
            
            return new UserData(userInfo, orders);
        }
    }
    
    static UserInfo fetchUserInfo(int userId) throws InterruptedException {
        // 模拟网络延迟
        Thread.sleep(1000);
        return new UserInfo(userId, "用户" + userId, "user" + userId + "@example.com");
    }
    
    static List<Order> fetchUserOrders(int userId) throws InterruptedException {
        // 模拟网络延迟
        Thread.sleep(1500);
        return List.of(
            new Order(1, "商品A", 99.9),
            new Order(2, "商品B", 199.9),
            new Order(3, "商品C", 299.9)
        );
    }
}
```

- **序列化集合**：新的不可变集合工厂方法，支持序列化

```java
// 序列化集合示例
// 创建不可变且可序列化的集合
List<String> list = List.of("a", "b", "c");
Set<Integer> set = Set.of(1, 2, 3);
Map<String, Integer> map = Map.of("one", 1, "two", 2, "three", 3);

// 序列化和反序列化
try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("collections.ser"))) {
    out.writeObject(list);
    out.writeObject(set);
    out.writeObject(map);
}

try (ObjectInputStream in = new ObjectInputStream(new FileInputStream("collections.ser"))) {
    List<String> deserializedList = (List<String>) in.readObject();
    Set<Integer> deserializedSet = (Set<Integer>) in.readObject();
    Map<String, Integer> deserializedMap = (Map<String, Integer>) in.readObject();
    
    System.out.println(deserializedList);
    System.out.println(deserializedSet);
    System.out.println(deserializedMap);
}
```

- **外部函数和内存API(正式版)**：简化了Java代码调用本地代码和访问外部内存的方式

```java
// 外部函数和内存API示例
// 导入必要的包
import java.lang.foreign.*;
import java.lang.invoke.MethodHandle;

// 使用外部函数API调用C标准库函数
void callCFunction() throws Throwable {
    // 获取C标准库
    SymbolLookup stdlib = SymbolLookup.loaderLookup();
    
    // 查找printf函数
    MethodHandle printf = Linker.nativeLinker().downcallHandle(
        stdlib.lookup("printf").orElseThrow(),
        FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS)
    );
    
    // 创建包含C字符串的内存段
    try (Arena arena = Arena.ofConfined()) {
        MemorySegment cString = arena.allocateUtf8String("Hello from Java 21 Foreign Function API!\n");
        
        // 调用printf
        int result = (int) printf.invoke(cString);
        System.out.println("printf返回值: " + result);
    }
}

// 使用内存API访问堆外内存
void useOffHeapMemory() {
    try (Arena arena = Arena.ofConfined()) {
        // 分配1MB的堆外内存
        MemorySegment segment = arena.allocate(1024 * 1024);
        
        // 获取内存段的地址
        long address = segment.address().toRawLongValue();
        System.out.println("分配的内存地址: 0x" + Long.toHexString(address));
        
        // 写入数据
        for (int i = 0; i < 100; i++) {
            segment.setAtIndex(ValueLayout.JAVA_INT, i, i * 10);
        }
        
        // 读取数据
        for (int i = 0; i < 10; i++) {
            int value = segment.getAtIndex(ValueLayout.JAVA_INT, i);
            System.out.println("内存位置 " + i + ": " + value);
        }
    }
}
```

- **未命名模式和变量(预览)**：简化模式匹配中不需要的变量

```java
// 未命名模式和变量预览示例
// 使用下划线作为未命名模式
if (obj instanceof Point(int x, int _)) {
    // 只关心x坐标，忽略y坐标
    System.out.println("X坐标: " + x);
}

// 在switch中使用未命名模式
static String getShapeType(Shape shape) {
    return switch (shape) {
        case Circle(_) -> "圆形";
        case Rectangle(_, _) -> "矩形";
        case Triangle(_, _) -> "三角形";
        default -> "未知形状";
    };
}

// 未命名变量
void processData(List<String> data) {
    for (int _ = 0; _ < 3; _++) {
        // 重复执行3次，不关心计数器值
        System.out.println("处理数据...");
    }
}
```

- **Vector API(第六次孵化)**：向量计算API的进一步改进
- **外部链接器API(预览)**：简化了与本地代码的互操作
- **分代ZGC**：ZGC垃圾收集器的分代版本，进一步提高性能
- **密封类的反射API**：用于检查密封类层次结构的反射API

Java 21作为LTS版本，集成了过去几个版本中的许多预览特性，并将它们标准化。虚拟线程的正式发布是一个重要的里程碑，它彻底改变了Java的并发编程模型，使Java应用能够更有效地利用现代多核处理器。

## 总结与展望

### Java版本演进的关键里程碑

Java语言从1995年首次发布至今，经历了多次重大版本更新，每个版本都为开发者带来了新的特性和改进。以下是Java版本演进的关键里程碑：

1. **JDK 1.0 (1996)**：Java的首次正式发布，奠定了面向对象、跨平台、自动内存管理等核心特性。

2. **JDK 1.1 (1997)**：引入内部类、JavaBeans、JDBC等重要特性，为企业级应用开发奠定基础。

3. **JDK 1.2 (1998)**：引入Collections框架和JIT编译器，显著提高了Java的性能和易用性。

4. **Java 5 (2004)**：引入泛型、注解、枚举、自动装箱/拆箱等革命性特性，使Java成为更现代的编程语言。

5. **Java 8 (2014)**：引入Lambda表达式、Stream API、新日期时间API等，将函数式编程引入Java，是Java历史上最重要的版本之一。

6. **Java 9 (2017)**：引入模块系统，重构了JDK的内部结构，提高了Java平台的可维护性和安全性。

7. **Java 11 (2018)**：第一个采用新发布模式的LTS版本，标准化了HTTP客户端API等特性。

8. **Java 17 (2021)**：引入密封类等特性，是第二个采用新发布模式的LTS版本。

9. **Java 21 (2023)**：引入虚拟线程、记录模式、字符串模板等特性，显著提高了Java的并发性能和表达能力。

### Java语言的未来发展方向

Java语言的未来发展将继续关注以下几个方向：

1. **并发编程模型的革新**：虚拟线程和结构化并发是Java并发编程的重大革新，未来将进一步完善这些特性，使并发编程更简单、更高效。

2. **语言表达能力的增强**：模式匹配、记录类、字符串模板等特性提高了Java的表达能力，未来将继续引入更多现代语言特性，使代码更简洁、更易读。

3. **性能优化**：通过JIT编译器改进、GC算法优化、值类型(Project Valhalla)等技术，进一步提高Java的性能，减少内存占用。

4. **原生镜像技术**：GraalVM和Project Leyden等技术将使Java应用能够编译为原生可执行文件，减少启动时间和内存占用，适应云原生和微服务架构。

5. **与新兴技术的结合**：Java将继续与人工智能、大数据、云计算等新兴技术结合，提供更好的工具和库支持。

6. **生态系统的持续发展**：Java生态系统将继续发展，包括框架、工具、库等，为开发者提供更全面的支持。

### Java在现代软件开发中的地位

尽管面临来自其他编程语言的竞争，Java在现代软件开发中仍然保持着重要地位：

1. **企业级应用的首选语言**：Java在企业级应用开发中仍然是首选语言，特别是在金融、电信、政府等领域。

2. **Android应用开发**：尽管Kotlin的兴起，Java仍然是Android应用开发的重要语言。

3. **大数据生态系统**：Hadoop、Spark等大数据框架主要使用Java开发，Java在大数据领域有着广泛应用。

4. **云原生应用**：Spring Boot、Quarkus等框架使Java适应了云原生和微服务架构的需求。

5. **持续的创新**：Java语言和平台的持续创新，如虚拟线程、模块系统等，使其保持了竞争力。

6. **庞大的开发者社区**：全球数百万Java开发者和丰富的学习资源，使Java保持了强大的生态系统。

Java语言经过近30年的发展，已经从一个简单的编程语言发展成为一个完整的技术生态系统。尽管技术环境不断变化，但Java通过持续创新和适应，仍然保持着其在软件开发领域的重要地位。未来，Java将继续演进，为开发者提供更强大、更高效的工具，应对不断变化的技术挑战。
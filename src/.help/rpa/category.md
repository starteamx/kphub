-4.1.2多态
4.2作为类型的类
-4.2.1把类作为一种类型
-4.2.2空指针nil
-专栏关系表达式
-4.2.3静态类型检查
-4.2.4静态类型检查的总结
4.3编程中的类型定义
-4.3.1签名不一致时的情况
-专栏重载
-4.3.2类的前置声明
-4.3.3强制类型转换的使用示例
4.4实例变量的数据封装
-4.4.1实例变量的访问权限
-4.4.2访问器
-4.4.3实例变量的可见性
-4.4.4在实现部分中定义实例变量
4.5类对象
-4.5.1什么是类对象
-4.5.2类对象的类型
-4.5.3类方法的定义
-4.5.4类变量
-4.5.5类对象的初始化
-4.5.6初始化方法的返回值
第5章基于引用计数的内存管理
5.1动态内存管理
-5.1.1内存管理的必要性
-5.1.2引用计数、自动引用计数和自动垃圾回收
5.2手动引用计数内存管理
-5.2.1引用计数
-5.2.2测试引用计数的例子
-5.2.3释放对象的方法
-5.2.4访问方法和对象所有权
-专栏静态对象
-5.2.5自动释放
-5.2.6使用自动释放池时需要注意的地方
-5.2.7临时对象的生成
-5.2.8运行回路和自动释放池
-专栏常量修饰符const
5.3分数计算器的例子
-5.3.1分数类Faction
-5.3.2保存计算结果的FracRegister类
-5.3.3主函数和执行示例
5.4ARC概要
-5.4.1什么是ARC
-5.4.2禁止调用引用计数的相关函数
-5.4.3管理自动释放池的新语法
-5.4.4变量的初始值
-5.4.5方法族
-5.4.6方法dealloc的定义
-5.4.7使用ARC的程序的编译
-5.4.8ARC的基本注意事项
-5.4.9使用ARC重构分数计算器
5.5循环引用和弱引用
-5.5.1循环引用
-5.5.2所有权和对象间的关系
-5.5.3弱引用
-5.5.4自动nil化的弱引用
-5.5.5对象之间引用关系的基本原则
5.6ARC编程时其他一些注意事项
-5.6.1可以像通常的指针一样使用的对象
-5.6.2setter方法的注意事项
-5.6.3通过函数的参数返回结果对象
-5.6.4C语言数组保存Objective-C对象
-5.6.5ARC对结构体的一些限制
-5.6.6提示编译器进行特别处理
第6章垃圾回收
-6.1垃圾回收的概要
-6.1.1查找不再使用的对象
-6.1.2编程时的注意事项
-6.1.3垃圾收集器
-6.1.4finalize方法的定义
-6.1.5编译时的设定
-6.1.6引用计数管理方式中方法的处理
-6.1.7使用垃圾回收编程小结
-6.2垃圾回收的详细功能
-6.2.1分代垃圾回收
-6.2.2弱引用
-6.2.3自动nil化
-6.2.4通过垃圾回收回收动态分配的内存
-6.2.5__strong修饰符的使用方法
-6.2.6NSGarbageCollector类
-6.2.7实时API
-6.3内存管理方式的比较
-6.3.1引用计数和垃圾回收
-6.3.2更改内存管理方式
-6.3.3各种内存管理方式的比较
第7章属性声明
-7.1属性是什么
-7.1.1使用属性编程
-7.1.2属性的概念
-专栏内省
-7.2属性的声明和功能
-7.2.1显式声明属性
-7.2.2属性的实现
-7.2.3@synthesize和实例变量
-7.2.4通过@synthesize生成实例变量
-7.2.5给属性指定选项
-7.2.6赋值时的选项
-7.2.7原子性
-7.2.8属性声明和继承
-7.2.9方法族和属性的关系
-7.3通过点操作符访问属性
-7.3.1点操作符的使用方法
-7.3.2复杂的点操作符的使用方法
-7.3.3何时使用点操作符
第8章类NSObject和运行时系统
8.1类NSObject
-8.1.1根类的作用
-8.1.2类和实例
-8.1.3实例对象的生成和释放
-8.1.4初始化
-8.1.5对象的比较
-8.1.6对象的内容描述
8.2消息发送机制
-8.2.1选择器和SEL类型
-8.2.2消息搜索
-8.2.3以函数的形式来调用方法
-专栏函数指针
-8.2.4对self进行赋值
-8.2.5发送消息的速度
-8.2.6类对象和根类
-8.2.7Target-actionparadigm
-8.2.8Xcode中的动作方法和Outlet的写法
8.3Objective-C和Cocoa环境
-8.3.1Cocoa环境和MacOSX
-8.3.2CocoaTouch和iOS
-8.3.3框架
-8.3.4框架的构成和头文件
8.4全新的运行时系统
-8.4.1对64位的对应和现代运行时系统
-8.4.2数据模型
-8.4.364位模型和整数类型
-8.4.4CoreGraphics的浮点数类型
-8.4.5健壮实例变量
-专栏条件编译
第9章Foundation框架中常用的类
9.1对象的可变性
-9.1.1可变对象和不可变对象
-9.1.2可变对象的生成
9.2字符串类NSString
-9.2.1常量字符串
-9.2.2NSString
-9.2.3NSMutableString
9.3NSData
-9.3.1NSData
-9.3.2NSMutableData
9.4数组类
-9.4.1NSArray
-9.4.2NSMutableArray
-9.4.3数组对象的所有权
-9.4.4快速枚举
-9.4.5枚举器NSEnumerator
-9.4.6快速枚举和枚举器
-9.4.7集合类
9.5词典类
9.6包裹类
-9.6.1NSNumber
-9.6.2NSValue
-9.6.3类型编码和@encode()
-9.6.4NSNull
9.7NSURL
-9.7.1关于URL
-9.7.2NSURL的概要
-9.7.3使用NSURL来访问资源
第10章范畴
10.1范畴
-10.1.1范畴
-10.1.2范畴和文件的组织
-10.1.3作为子模块的范畴
-10.1.4方法的前向声明
-10.1.5私有方法
-10.1.6类扩展
-10.1.7范畴和属性声明
10.2给现有类追加范畴
-10.2.1追加新的方法
-10.2.2追加方法的例子
-专栏可变参数的方法的定义
-10.2.3覆盖已有的方法
10.3关联引用
-10.3.1关联引用的概念
-10.3.2添加和检索关联
-10.3.3对象的存储方法
-10.3.4断开关联
-10.3.5利用范畴的例子
第11章抽象类和类簇
-11.1抽象类
-11.1.1什么是抽象类
-11.1.2抽象类的例子
-11.2类簇
-11.2.1类簇的概念
-11.2.2测试程序
-11.2.3编程中的注意事项
-11.3生成类簇的子类
-11.3.1使用范畴
-11.3.2基本方法的重定义
-11.3.3生成字符串的子类
第12章协议
-12.1协议的概念
-12.1.1什么是协议
-12.1.2对象的协议
-12.2Objective-C中协议的声明
-12.2.1协议的声明
-12.2.2协议的采用
-12.2.3协议的继承
-12.2.4指定协议的类型声明
-12.2.5协议的前置声明
-12.2.6协议适用性检查
-12.2.7必选功能和可选功能
-12.2.8使用协议的程序示例
-专栏类的多重继承
-12.3非正式协议
-12.3.1什么是非正式协议
-12.3.2非正式协议的用途
-专栏使用宏（macro）来区分系统版本的差异
第13章对象的复制及存储
-13.1对象的复制
-13.1.1浅复制和深复制
-13.1.2区域
-13.1.3复制方法的定义
-13.1.4复制方法的例子
-13.1.5实现可变复制
-13.2归档
-13.2.1对象的归档
-13.2.2Foundation框架的归档功能
-13.2.3归档方法的定义
-13.2.4归档方法定义
-13.2.5归档和解档的初始化方法
-13.3属性表
-13.3.1属性表概况
-13.3.2ASCII码格式属性表
-13.3.3XML格式属性表
-13.3.4属性表的变换和检查
第14章块对象
-14.1什么是块对象
-14.1.1C编译器和GCD
-14.1.2块对象的定义
-14.1.3块对象和类型声明
-14.1.4块对象中的变量行为
-14.1.5排序函数和块对象
-14.2块对象的构成
-14.2.1块对象的实例和生命周期
-14.2.2应该避免的编码模式
-14.2.3块对象的复制
-14.2.4指定特殊变量_block
-14.3Objective-C和块对象
-14.3.1方法定义和块对象
-14.3.2作为Objective-C对象的块对象
-14.3.3ARC和块对象
-14.3.4对象内变量的行为
-14.3.5集合类中添加的方法
-14.3.6在窗体中使用块对象
-14.3.7ARC中使用块对象的注意事项
第15章消息发送模式
-15.1应用和运行回路
-15.1.1运行回路
-15.1.2定时器对象
-15.1.3消息的延迟执行
-15.2委托
-15.2.1委托的概念
-15.2.2Cocoa环境中的委托
-15.2.3委托的设置和协议
-15.2.4使用委托的程序
-15.3通知
-15.3.1通知和通知中心的概念
-15.3.2通知对象
-15.3.3通知中心
-15.3.4通知队列
-专栏通知名或异常名的定义
-15.4反应链
-15.4.1反应链概述
-15.4.2应用中的反应链
-15.5消息转送
-15.5.1消息转送的构成
-15.5.2消息转送需要的信息
-15.5.3消息转送的定义
-15.5.4禁止使用消息
-15.5.5程序示例
-15.6撤销构造
-15.6.1撤销构造的概念
-15.6.2在撤销管理器中记录操作
第16章应用的构造
16.1应用束
-16.1.1应用束的构造
-16.1.2nib文件和各语言资源
-专栏指定语言和地区
-16.1.3信息文件的主要内容
-16.1.4通过NSBundle访问资源
-16.1.5iOS中资源的访问
-16.1.6通用二进制
16.2加载nib文件
-16.2.1nib文件实例化
-16.2.2在MacOSX中加载nib文件
-16.2.3在iOS中加载nib文件
-16.2.4nib文件内的包含循环
-16.2.5nib文件内对象的初始化
-16.2.6启动应用
16.3iOS的文件保存场所
-16.3.1主要目录及功能
-16.3.2获取目录路径
16.4用户默认
-16.4.1保存设定值
-16.4.2默认域
-16.4.3查找用户默认的工具
-16.4.4NSUserDefaults概要
16.5应用的本地化
-16.5.1消息的本地化
-16.5.2本地化指针
-专栏本地化应用名
-16.5.3本地化
-专栏消息内的语序
16.6模块的动态加载
-16.6.1可加载束
-16.6.2使用可加载束的程序
-16.6.3插件概述
-专栏沙盒（AppSandbox）
第17章实例：简单图像视图
17.1Application框架和InterfaceBuilder
17.2程序概况
-17.2.1对象间的关系
-17.2.2通知
-17.2.3撤销和重做
-17.2.4可加载束和本地化
-17.2.5用户默认
17.3编程介绍
-17.3.1main函数和MyViewerCtrl类
-17.3.2类WinCtr
-17.3.3类MyInspector
17.4应用束的组织
-17.4.1创建编译和设置文件
-17.4.2程序运行例子
-17.4.3GUI定义文件和程序
-专栏Objective-C调试器的功能
第18章异常和错误
18.1异常
-18.1.1异常处理的概念
-18.1.2Objective-C中的异常处理
18.2异常处理机制概述
-18.2.1异常句柄和异常处理域
-18.2.2异常表示类NSException
-18.2.3异常处理机制的语法
-18.2.4简单的异常处理的示例程序
-专栏日志输出函数NSLog()
18.3异常的发生和传播
-18.3.1异常的传播
-18.3.2自己触发异常
-18.3.3用@throw语法产生异常
-18.3.4@catch的特殊语法
-18.3.5异常传播和@finally
-18.3.6异常处理程序的注意点
18.4断言
-18.4.1断言是什么
-18.4.2断言宏
-专栏包含可变个数的参数的宏
18.5错误处理
-18.5.1错误处理结构的目的
-18.5.2表示错误的类NSError的使用方法
-18.5.3获取错误对象的信息
-18.5.4生成自定义错误对象
18.6错误反应链
-18.6.1错误反应链的结构
-18.6.2错误对象的更改和恢复
-专栏单元测试
第19章并行编程
19.1多线程
-19.1.1线程的基本概念
-19.1.2线程安全
-19.1.3注意点
-19.1.4使用NSThread创建线程
-19.1.5当前线程
-19.1.6GUI应用和线程
19.2互斥
-19.2.1需要互斥的例子
-19.2.2锁
-19.2.3死锁
-19.2.4尝试获得锁
-19.2.5条件锁
-19.2.6NSRecursiveLock
-19.2.7@synchronized
19.3操作对象和并行处理
-19.3.1新的并行处理程序
-19.3.2使用NSOperation的处理概述
-19.3.3NSOperation和NSOperationQueue的简单用法
-19.3.4等待至聚合任务终止
-19.3.5使用操作对象的简单程序
-19.3.6NSInvocationOperation的使用方法
-19.3.7NSBlockOperation的使用方法
-19.3.8NSBlockOperation中添加多个块对象
-19.3.9设置任务间的依赖
-19.3.10任务的优先级设置
-19.3.11设置最大并行任务数
-19.3.12终止任务
-19.3.13设置队列调度为中断状态
19.4并行处理的示例程序
-19.4.1程序概要
-19.4.2类BrowsingViewCtrl
-19.4.3类BrowsingWinCtrl
-19.4.4类DrawOperation
-19.4.5其他改变
19.5使用连接的通信
-19.5.1连接
-19.5.2代理
-19.5.3方法的指针参数
-19.5.4对象的副本传递
-19.5.5异步通信
-19.5.6设置协议
-19.5.7运行回路的开始
-19.5.8接收消息时的处理
19.9线程间连接
-19.9.9线程间连接
-19.5.10进程间连接的例子
第20章键值编码
20.1键值编码概况
-20.1.1什么是键值编码
-20.1.2键值编码的基本处理
20.2访问属性
-20.2.1键值编码的方法的行为
-20.2.2属性值的自动转换
-20.2.3字典对象和键值编码
-20.2.4根据键路径进行访问
-20.2.5一对一关系和一对多关系
-20.2.6数组对象和键值编码
20.3一对多关系的访问
-20.3.1带索引的访问器模式
-20.3.2一对多关系的可变访问
20.4KVC标准
-20.4.1验证属性值
-20.4.2键值编码的准则
20.5键值观察
-20.5.1键值观察的基础
-20.5.2示例程序
-20.5.3一对多关系的属性监视
-20.5.4依赖键的登记
20.6Cocoa绑定概述
-20.6.1目标－行为－模式的弱点
-20.6.2什么是Cocoa绑定
-20.6.3Cocoa绑定所需的方法
-20.6.4例题：绘制二次函数图的软件
-20.6.5自定义视图的方法定义
第21章现代Objective-C开发
-21.1Swift互操作
-21.2ModernObjective-C特性
-21.3新框架集成
-21.4混合开发策略
第22章开发工具与调试
-22.1Xcode高级使用
-22.2调试技巧
-22.3性能优化
-22.4持续集成
第23章设计模式与架构
-23.1常用设计模式
-23.2架构设计原则
-23.3组件化开发
-23.4代码重构
第24章测试与质量保证
-24.1单元测试
-24.2UI测试
-24.3性能测试
-24.4代码覆盖率
第25章安全开发指南
-25.1数据安全
-25.2网络安全
-25.3加密技术
-25.4安全最佳实践
#Swift编程语言知识库
##1.Swift基础
1.1欢迎来到Swift
1.2基本语法与数据类型
1.3常量与变量
1.4运算符与表达式
1.5字符串与字符
1.6集合类型
1.7控制流
##2.函数与闭包
2.1函数
2.2闭包
2.3高阶函数
2.4函数式编程概念
##3.类型系统
3.1枚举
3.2结构体和类
3.3属性
3.4方法
3.5下标
3.6继承
3.7构造过程
3.8析构过程
3.9类型转换
3.10嵌套类型
##4.高级特性
4.1可选链式调用
4.2错误处理
4.3并发
4.4宏
4.5泛型
4.6不透明类型和封装协议类型
4.7扩展
4.8协议
4.9自动引用计数
4.10内存安全
4.11访问控制
4.12高级运算符
##5.Swift生态系统
5.1SwiftUI开发
5.2Combine框架
5.3SwiftPackageManager
5.4Swift与Objective-C互操作
5.5SwiftonServer
##6.实战与最佳实践
6.1Swift设计模式
6.2函数式编程实践
6.3性能优化技巧
6.4测试与调试
6.5代码规范与风格指南
##7.高级主题
7.1Swift并发编程深入
7.2Swift元编程
7.3底层实现原理
7.4Swift演进历史与版本特性
7.5Swift与LLVM
##8.应用场景
8.1iOS/iPadOS应用开发
8.2macOS应用开发
8.3watchOS与tvOS开发
8.4跨平台Swift应用
##9.语言参考
9.1关于语言参考
9.2词法结构
9.3类型
9.4表达式
9.5声明
9.6特性
9.7模式
9.8语法总结